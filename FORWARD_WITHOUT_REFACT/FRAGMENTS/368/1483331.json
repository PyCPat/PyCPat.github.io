{"BEFORE":"        bs = outputs[\"pred_logits\"].shape[0]\n\n        # Split queries in individual classes\n        if self.anchor_matching:\n            classes_queries_boxes = anchors[None].repeat((bs, 1, 1)).reshape(bs, 20, 27, -1).cpu().float() \n        else:\n            classes_queries_boxes = outputs[\"pred_boxes\"].reshape(bs, 20, 27, -1).cpu().float()\n        classes_queries_probs = outputs[\"pred_logits\"].reshape(bs, 20, 27, -1).cpu().float()\n\n        # Get targets\n        tgt = [{label.item(): box.cpu() for box, label in zip(target['boxes'], target['labels'])} for target in targets]\n\n        # Generate soft query labels based on IoU with target\n        soft_labels = torch.zeros_like(classes_queries_probs).squeeze(-1)\n        matches = torch.zeros_like(classes_queries_probs, dtype=torch.long).squeeze(-1)\n\n        for batch, (batch_pred_logits, batch_pred_boxes) in enumerate(zip(classes_queries_probs, classes_queries_boxes)):\n            for class_, (class_pred_logits, class_pred_boxes) in enumerate(zip(batch_pred_logits, batch_pred_boxes), 1):\n                try:\n                    tgt_box = tgt[batch][class_]\n                except KeyError:\n                    soft_labels[batch, class_ -1] = -1\n                    continue\n\n                # Determine cost based on different metrices\n                cost_class = -class_pred_logits.sigmoid().squeeze()\n                cost_bbox = torch.cdist(class_pred_boxes, tgt_box[None], p=1).squeeze()\n                cost_giou = -generalized_bbox_iou_3d(box_cxcyczwhd_to_xyzxyz(class_pred_boxes.clip(min=0)), box_cxcyczwhd_to_xyzxyz(tgt_box[None])).squeeze()\n\n                C = self.cost_bbox * cost_bbox + self.cost_class * cost_class + self.cost_giou * cost_giou\n                best_query_ids = torch.topk(C, num_top_queries, largest=False)[-1]\n\n                # Assign soft labels and match\n                soft_labels[batch,  class_ - 1] = ((cost_giou - cost_giou.max()) \/ (cost_giou.min() - cost_giou.max())).clip(min=0) # nomalize\n\n                for query_id in best_query_ids:\n                    matches[batch, class_ -1, query_id] = 1\n\n        return matches, soft_labels\n","AFTER":"        bs, num_queries, _ = outputs[\"pred_logits\"].shape\n        num_queries_per_organ = int(num_queries \/ 20)\n\n        # Split queries in individual classes\n        if self.anchor_matching:\n            classes_queries_boxes = anchors[None].repeat((bs, 1, 1)).reshape(bs, 20, num_queries_per_organ, -1).cpu().float() \n        else:\n            classes_queries_boxes = outputs[\"pred_boxes\"].reshape(bs, 20, num_queries_per_organ, -1).cpu().float()\n        classes_queries_probs = outputs[\"pred_logits\"].reshape(bs, 20, num_queries_per_organ, -1).cpu().float()\n\n        # Get targets\n        tgt = [{label.item(): box.cpu() for box, label in zip(target['boxes'], target['labels'])} for target in targets]\n\n        # Generate soft query labels based on IoU with target\n        soft_labels = torch.zeros_like(classes_queries_probs).squeeze(-1)\n        matches = torch.zeros_like(classes_queries_probs, dtype=torch.long).squeeze(-1)\n\n        for batch, (batch_pred_logits, batch_pred_boxes) in enumerate(zip(classes_queries_probs, classes_queries_boxes)):\n            for class_, (class_pred_logits, class_pred_boxes) in enumerate(zip(batch_pred_logits, batch_pred_boxes), 1):\n                try:\n                    tgt_box = tgt[batch][class_]\n                except KeyError:\n                    soft_labels[batch, class_ -1] = -1\n                    continue\n\n                # Determine cost based on different metrices\n                cost_class = -class_pred_logits.sigmoid().squeeze()\n                cost_bbox = torch.cdist(class_pred_boxes, tgt_box[None], p=1).squeeze()\n                cost_giou = -generalized_bbox_iou_3d(box_cxcyczwhd_to_xyzxyz(class_pred_boxes.clip(min=0)), box_cxcyczwhd_to_xyzxyz(tgt_box[None])).squeeze()\n\n                C = self.cost_bbox * cost_bbox + self.cost_class * cost_class + self.cost_giou * cost_giou\n                best_query_ids = torch.topk(C, num_top_queries, largest=False)[-1]\n\n                # Assign soft labels and match\n                soft_labels[batch,  class_ - 1] = ((cost_giou - cost_giou.max()) \/ (cost_giou.min() - cost_giou.max())).clip(min=0) # nomalize\n\n                try:\n                    for query_id in best_query_ids:\n                        matches[batch, class_ -1, query_id] = 1\n                except TypeError:\n                    matches[batch, class_ -1, 0] = 1\n\n        return matches, soft_labels\n"}