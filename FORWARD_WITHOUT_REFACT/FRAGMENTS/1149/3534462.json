{"BEFORE":"    def forward(self, predict, target):\n        assert predict.shape == target.shape, 'predict & target shape do not match'\n        dice = BinaryDiceLoss(**self.kwargs)\n        total_loss = 0\n        predict = F.softmax(predict, dim=1)\n\n        for i in range(target.shape[1]):\n            if i != self.ignore_index:\n                dice_loss = dice(predict[:, i], target[:, i])\n                if self.weight is not None:\n                    assert self.weight.shape[0] == target.shape[1], \\\n                        'Expect weight shape [{}], get[{}]'.format(target.shape[1], self.weight.shape[0])\n                    dice_loss *= self.weights[i]\n                total_loss += dice_loss\n\n        return total_loss\/target.shape[1]\n","AFTER":"    def forward(self, inputs, target, weight=None, softmax=False):\n        if softmax:\n            inputs = torch.softmax(inputs, dim=1)\n        target = self._one_hot_encoder(target)\n        if weight is None:\n            weight = [1] * self.n_classes\n        assert inputs.size() == target.size(), 'predict & target shape do not match'\n        class_wise_dice = []\n        loss = 0.0\n        for i in range(0, self.n_classes):\n            dice = self._dice_loss(inputs[:, i], target[:, i])\n            class_wise_dice.append(1.0 - dice.item())\n            loss += dice * weight[i]\n        return loss \/ self.n_classes\n"}