{"BEFORE":"        if compressed_depth is None or compressed_depth[key] is None:\n            in_channels_d2block = 2 * num_d2blocks[key][-1] * depth[key][-1] * growth_rate[key][-1]\n        else:\n            in_channels_d2block = 2 * num_d2blocks[key][-1] * compressed_depth[key][-1] * growth_rate[key][-1]\n\n        self.net = nn.ModuleDict(net)\n","AFTER":"        self, in_channels, num_features, growth_rate, bottleneck_channels, kernel_size, sections=[256,1344], scale=(2,2),\n        num_d3blocks=5, num_d2blocks=3, depth=None, compressed_depth=None,\n        growth_rate_d2block=None, kernel_size_d2block=None, depth_d2block=None,\n        kernel_size_gated=None,\n        norm=True, nonlinear='relu',\n        eps=EPS, **kwargs\n    ):\n        super().__init__()\n\n        self.band_split = BandSplit(sections=sections)\n\n        in_channels_d2block = 0\n        net = {}\n        self.bands = ['low', 'high', 'full']\n\n        for key in self.bands:\n            if compressed_depth is None:\n                net[key] = D3NetBackbone(in_channels, num_features[key], growth_rate[key], bottleneck_channels, kernel_size[key], scale=scale[key], num_d3blocks=num_d3blocks[key], num_d2blocks=num_d2blocks[key], depth=depth[key], norm=norm, nonlinear=nonlinear, eps=eps, **kwargs)\n            else:\n                net[key] = D3NetBackbone(in_channels, num_features[key], growth_rate[key], bottleneck_channels, kernel_size[key], scale=scale[key], num_d3blocks=num_d3blocks[key], num_d2blocks=num_d2blocks[key], depth=depth[key], compressed_depth=compressed_depth[key], norm=norm, nonlinear=nonlinear, eps=eps, **kwargs)\n        self.net = nn.ModuleDict(net)\n\n        in_channels_d2block = len(self.bands[:-1]) * bottleneck_channels\n"}