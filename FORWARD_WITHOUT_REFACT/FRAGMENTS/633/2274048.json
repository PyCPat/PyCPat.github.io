{"BEFORE":"        pids = torch.FloatTensor(np.arange(len(anchor)))\n        if torch.cuda.is_available():\n            pids = pids.cuda()\n        # if self.metric == 'euclidean':\n            # distance = torch.sqrt(2 - 2 * torch.matmul(anchor, positive.transpose(0, 1)))\n            # return batch_hard(distance, pids, margin=self.margin)\n        dist = cdist(anchor, positive, metric=self.metric)\n        dist_keypts = np.eye(dist_keypts.shape[0]) * 10 + dist_keypts.detach().cpu().numpy()\n        add_matrix = torch.zeros_like(dist)\n        add_matrix[np.where(dist_keypts < self.safe_radius)] += 10\n        dist = dist + add_matrix\n        return batch_hard(dist, pids, self.pos_margin, self.neg_margin)\n","AFTER":"        pids = torch.FloatTensor(np.arange(len(anchor))).to(anchor.device)\n        dist = cdist(anchor, positive, metric=self.metric)\n        dist_keypts = np.eye(dist_keypts.shape[0]) * 10 + dist_keypts.detach().cpu().numpy()\n        add_matrix = torch.zeros_like(dist)\n        add_matrix[np.where(dist_keypts < self.safe_radius)] += 10\n        dist = dist + add_matrix\n        return self.calculate_loss(dist, pids)\n"}