{"BEFORE":"    def forward(self, x: torch.Tensor):\n        \"\"\"Embeds and projects the input image.\n\n        Splits the input batch into q and k following the notation of MoCo.\n        Extracts features with the ResNet backbone and applies the projection\n        head to the output space.\n\n        Args:\n            x:\n                Tensor of shape bsz x channels x W x H\n\n        Returns:\n            Tensor of shape bsz x out_dim\n\n        \"\"\"\n        self._momentum_update(self.m)\n\n        # adopting the notation of the moco paper\n        batch_size = x.shape[0] \/\/ 2\n        q = x[:batch_size]\n        k = x[batch_size:]\n        \n        # embed queries\n        emb_q = self.backbone(q).squeeze()\n        out_q = self.projection_head(emb_q)\n\n        # embed keys\n        with torch.no_grad():\n\n            # shuffle for batchnorm\n            if self.batch_shuffle:\n                k, shuffle = self._batch_shuffle(k)\n\n            emb_k = self.momentum_backbone(k).squeeze()\n            out_k = self.momentum_projection_head(emb_k).detach()\n        \n            # unshuffle for batchnorm\n            if self.batch_shuffle:\n                out_k = self._batch_unshuffle(out_k, shuffle)\n\n        return torch.cat([out_q, out_k], axis=0)\n","AFTER":"    def forward(self,\n                x0: torch.Tensor,\n                x1: torch.Tensor = None,\n                return_features: bool = False):\n        \"\"\"Embeds and projects the input image.\n\n        Splits the input batch into q and k following the notation of MoCo.\n        Extracts features with the ResNet backbone and applies the projection\n        head to the output space.\n\n        Args:\n            x0:\n                Tensor of shape bsz x channels x W x H\n            x1:\n                TODO\n            return_features:\n                TODO\n\n        Returns:\n            Tensor of shape bsz x out_dim\n\n        \"\"\"\n        self._momentum_update(self.m)\n        \n        # TODO\n        f0 = self.backbone(x0).squeeze()\n        out0 = self.projection_head(f0)\n\n        # TODO\n        if return_features:\n            out0 = (out0, f0)\n\n        # TODO\n        if x1 is None:\n            return out0\n\n        # embed keys\n        with torch.no_grad():\n\n            # shuffle for batchnorm\n            if self.batch_shuffle:\n                x1, shuffle = self._batch_shuffle(x1)\n\n            f1 = self.momentum_backbone(x1).squeeze()\n            out1 = self.momentum_projection_head(f1).detach()\n        \n            # unshuffle for batchnorm\n            if self.batch_shuffle:\n                f1 = self._batch_unshuffle(f1, shuffle)\n                out1 = self._batch_unshuffle(out1, shuffle)\n\n            # TODO\n            if return_features:\n                out1 = (out1, f1)\n\n        return out0, out1\n"}