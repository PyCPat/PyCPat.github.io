{"BEFORE":"    def __init__(self, dim, block_num, heads, qk_dim, mlp_dim, upscale, patch_size):\r\n        super(HPINet, self).__init__()\r\n        self.dim = dim\r\n        self.block_num = block_num\r\n        self.upscale = upscale\r\n        self.patch_size = patch_size\r\n\r\n        self.first_conv = nn.Conv2d(3, dim, 3, 1, 1)\r\n        self.cross_match = nn.ModuleList()\r\n        self.blocks = nn.ModuleList()\r\n        self.mid_convs = nn.ModuleList()\r\n        for _ in range(block_num):\r\n            self.cross_match.append(Match(dim))\r\n            self.blocks.append(Block(dim=dim, num=3, heads=heads, qk_dim=qk_dim, mlp_dim=mlp_dim))\r\n            self.mid_convs.append(nn.Conv2d(dim, dim, 3, 1, 1))\r\n\r\n        if upscale == 4:\r\n            self.upconv1 = nn.Conv2d(dim, dim * 4, 3, 1, 1, bias=True)\r\n            self.upconv2 = nn.Conv2d(dim, dim * 4, 3, 1, 1, bias=True)\r\n            self.pixel_shuffle = nn.PixelShuffle(2)\r\n        elif upscale == 2 or upscale ==3:\r\n            self.upconv = nn.Conv2d(dim, dim * (upscale**2), 3, 1, 1, bias=True)\r\n            self.pixel_shuffle = nn.PixelShuffle(upscale)\r\n        else:\r\n            raise NotImplementedError\r\n        self.last_conv = nn.Conv2d(dim, 3, 3, 1, 1)\r\n        self.lrelu = nn.LeakyReLU(negative_slope=0.1, inplace=True)\r\n\r\n        num_parameters = sum(map(lambda x: x.numel(), self.parameters()))\r\n        print('#Params : {:<.4f} [K]'.format(num_parameters \/ 10 ** 3))\r\n","AFTER":"    def __init__(self, model_type: str, upscale: int):\r\n        super(HPINet, self).__init__()\r\n        model_type = model_type.upper()\r\n        if model_type not in self.model_settings:\r\n            raise KeyError('Undefined model type: {}'.format(model_type))\r\n        self.model_type = model_type\r\n        setting = self.model_settings[model_type]\r\n\r\n        self.dim = setting['dim']\r\n        self.block_num = setting['block_num']\r\n        self.patch_size = setting['patch_size']\r\n        self.qk_dim = setting['qk_dim']\r\n        self.mlp_dim = setting['mlp_dim']\r\n        self.upscale = upscale\r\n\r\n        self.first_conv = nn.Conv2d(3, self.dim, 3, 1, 1)\r\n        self.cross_match = nn.ModuleList()\r\n        self.blocks = nn.ModuleList()\r\n        self.mid_convs = nn.ModuleList()\r\n        for _ in range(self.block_num):\r\n            self.cross_match.append(Match(self.dim))\r\n            self.blocks.append(Block(dim=self.dim, num=3, qk_dim=self.qk_dim, mlp_dim=self.mlp_dim))\r\n            self.mid_convs.append(nn.Conv2d(self.dim, self.dim, 3, 1, 1))\r\n\r\n        if upscale == 4:\r\n            self.upconv1 = nn.Conv2d(self.dim, self.dim * 4, 3, 1, 1, bias=True)\r\n            self.upconv2 = nn.Conv2d(self.dim, self.dim * 4, 3, 1, 1, bias=True)\r\n            self.pixel_shuffle = nn.PixelShuffle(2)\r\n        elif upscale == 2 or upscale == 3:\r\n            self.upconv = nn.Conv2d(self.dim, self.dim * (upscale ** 2), 3, 1, 1, bias=True)\r\n            self.pixel_shuffle = nn.PixelShuffle(upscale)\r\n        else:\r\n            raise NotImplementedError(\r\n                'Upscale factor is expected to be one of (2, 3, 4), but got {}'.format(upscale))\r\n        self.last_conv = nn.Conv2d(self.dim, 3, 3, 1, 1)\r\n"}