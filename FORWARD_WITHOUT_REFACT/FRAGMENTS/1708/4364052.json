{"BEFORE":"        self.n_lags = n_lags\n        self.n_forecasts = n_forecasts\n        self.n_changepoints = n_changepoints\n\n        self.continuous_trend = True\n        self.segmentwise_trend = True\n        if trend_smoothness < 0:\n            self.continuous_trend = False\n        elif trend_smoothness > 0:\n            # compute trend delta-wise to allow for stable regularization.\n            # has issues with gradient bleedover to past.\n            self.segmentwise_trend = False\n\n        ## model definition\n        ## trend\n        self.trend_k0 = new_param(dims=[1])\n        self.trend_m0 = new_param(dims=[1])\n        if self.n_changepoints > 0:\n            # including first segment\n            self.trend_deltas = new_param(dims=[self.n_changepoints + 1])\n            if not self.continuous_trend:\n                # including first segment\n                self.trend_m = new_param(dims=[self.n_changepoints + 1])\n\n        linear_t = np.arange(self.n_changepoints + 1).astype(float) \/ (self.n_changepoints + 1)\n        # changepoint times, including zero.\n        self.trend_changepoints_t = torch.tensor(linear_t, requires_grad=False, dtype=torch.float)\n\n        # autoregression\n        if self.n_lags > 0:\n            self.ar = nn.Linear(n_lags, n_forecasts, bias=False)\n            nn.init.kaiming_normal_(self.ar.weight, mode='fan_in')\n\n\n    def _deltawise_trend_prophet(self, t):\n","AFTER":"                 num_hidden_layers=0, d_hidden=None):\n        # Perform initialization of the pytorch superclass\n        super(TimeNet, self).__init__()\n        self.n_lags = n_lags\n        self.n_forecasts = n_forecasts\n        self.n_changepoints = n_changepoints\n\n        self.num_hidden_layers = num_hidden_layers\n        if d_hidden is None:\n            d_hidden = n_lags + n_forecasts\n        self.d_hidden = d_hidden\n\n        self.continuous_trend = True\n        self.segmentwise_trend = True\n        if trend_smoothness < 0:\n            self.continuous_trend = False\n        elif trend_smoothness > 0:\n            # compute trend delta-wise to allow for stable regularization.\n            # has issues with gradient bleedover to past.\n            self.segmentwise_trend = False\n\n        ## model definition\n        ## trend\n        self.trend_k0 = new_param(dims=[1])\n        self.trend_m0 = new_param(dims=[1])\n        if self.n_changepoints > 0:\n            # including first segment\n            self.trend_deltas = new_param(dims=[self.n_changepoints + 1])\n            if not self.continuous_trend:\n                # including first segment\n                self.trend_m = new_param(dims=[self.n_changepoints + 1])\n\n        linear_t = np.arange(self.n_changepoints + 1).astype(float) \/ (self.n_changepoints + 1)\n        # changepoint times, including zero.\n        self.trend_changepoints_t = torch.tensor(linear_t, requires_grad=False, dtype=torch.float)\n\n        # autoregression\n        if self.n_lags > 0:\n            # if self.num_hidden_layers == 0:\n            #     self.ar_net = nn.Linear(n_lags, n_forecasts, bias=False)\n            #     nn.init.kaiming_normal_(self.ar_net.weight, mode='fan_in')\n            # else:\n            self.ar_net = nn.ModuleList()\n            d_inputs = self.n_lags\n            for i in range(self.num_hidden_layers):\n                self.ar_net.append(nn.Linear(d_inputs, self.d_hidden, bias=True))\n                d_inputs = d_hidden\n            self.ar_net.append(nn.Linear(d_inputs, self.n_forecasts, bias=True))\n            for lay in self.ar_net:\n                nn.init.kaiming_normal_(lay.weight, mode='fan_in')\n\n\n    def _deltawise_trend_prophet(self, t):\n"}