{"BEFORE":"    def forward(self, x: Tensor, num_steps: int = None) -> Tensor:\n        device = x.device\n        num_steps = default(num_steps, self.num_steps)\n        # Compute sigmas using schedule\n        sigmas = self.sigma_schedule(num_steps, device)\n        # Sample from first sigma distribution\n        x = sigmas[0] * x\n        # Compute gammas\n        gammas = torch.where(\n            (sigmas >= self.s_tmin) & (sigmas <= self.s_tmax),\n            min(self.s_churn \/ num_steps, sqrt(2) - 1),\n            0.0,\n        )\n        # Denoise x\n        for i in range(num_steps - 1):\n            x = self.step(x, sigma=sigmas[i], sigma_next=sigmas[i + 1], gamma=gammas[i])  # type: ignore # noqa\n\n        x = x.clamp(-1.0, 1.0)\n","AFTER":"    def forward(self, noise: Tensor, num_steps: Optional[int] = None) -> Tensor:\n        device = noise.device\n        num_steps = default(num_steps, self.num_steps)  # type: ignore\n        assert exists(num_steps), \"Parameter `num_steps` must be provided\"\n        # Compute sigmas using schedule\n        sigmas = self.sigma_schedule(num_steps, device)\n        # Sample using sampler\n        x = self.sampler(noise, fn=self.denoise_fn, sigmas=sigmas, num_steps=num_steps)\n"}