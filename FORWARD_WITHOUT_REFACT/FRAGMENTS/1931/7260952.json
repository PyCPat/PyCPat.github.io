{"BEFORE":"        shape1 = [make_divisible(x, int(self.stride.max())) for x in np.stack(shape1, 0).max(0)]  # inference shape\n        x = [letterbox(imgs[i], new_shape=shape1, auto=False)[0] for i in batch]  # pad\n        x = np.stack(x, 0) if batch[-1] else x[0][None]  # stack\n        x = np.ascontiguousarray(x.transpose((0, 3, 1, 2)))  # BHWC to BCHW\n        x = torch.from_numpy(x).to(p.device).type_as(p) \/ 255.  # uint8 to fp16\/32\n\n        # Inference\n        with torch.no_grad():\n            y = self.model(x, augment, profile)[0]  # forward\n        y = non_max_suppression(y, conf_thres=self.conf, iou_thres=self.iou, classes=self.classes)  # NMS\n\n        # Post-process\n        for i in batch:\n            if y[i] is not None:\n                y[i][:, :4] = scale_coords(shape1, y[i][:, :4], shape0[i])\n\n        return Detections(imgs, y, self.names)\n","AFTER":"        shape1 = [make_divisible(x, int(self.stride.max())) for x in np.stack(shape1, 0).max(0)]  # inference shape\n        x = [letterbox(imgs[i], new_shape=shape1, auto=False)[0] for i in batch]  # pad\n        x = np.stack(x, 0) if batch[-1] else x[0][None]  # stack\n        x = np.ascontiguousarray(x.transpose((0, 3, 1, 2)))  # BHWC to BCHW\n        x = torch.from_numpy(x).to(p.device).type_as(p) \/ 255.  # uint8 to fp16\/32\n\n        # Inference\n        with torch.no_grad():\n            y = self.model(x, augment, profile)[0]  # forward\n        y = non_max_suppression(y, conf_thres=self.conf, iou_thres=self.iou, classes=self.classes)  # NMS\n\n        # Post-process\n        for i in batch:\n            scale_coords(shape1, y[i][:, :4], shape0[i])\n"}