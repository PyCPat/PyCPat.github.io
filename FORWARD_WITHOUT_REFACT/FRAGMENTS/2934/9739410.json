{"BEFORE":"    def forward(self, feat, rois):\n        if not isinstance(feat, tuple):\n            feat = (feat, )\n\n        if len(feat) >= 2:\n            maxT = max([x.shape[2] for x in feat])\n            max_shape = (maxT, ) + feat[0].shape[3:]\n            # resize each feat to the largest shape (w. nearest)\n            feat = [F.interpolate(x, max_shape).contiguous() for x in feat]\n\n        if self.with_temporal_pool:\n            if self.temporal_pool_mode == 'avg':\n                feat = [torch.mean(x, 2, keepdim=True) for x in feat]\n            elif self.temporal_pool_mode == 'max':\n                feat = [torch.max(x, 2, keepdim=True)[0] for x in feat]\n            else:\n                raise NotImplementedError\n\n        feat = torch.cat(feat, axis=1).contiguous()\n\n        roi_feats = []\n        for t in range(feat.size(2)):\n            frame_feat = feat[:, :, t].contiguous()\n            roi_feat = self.roi_layer(frame_feat, rois)\n            if self.with_global:\n                global_feat = self.global_pool(frame_feat.contiguous())\n                inds = rois[:, 0].type(torch.int64)\n                global_feat = global_feat[inds]\n                roi_feat = torch.cat([roi_feat, global_feat], dim=1)\n                roi_feat = roi_feat.contiguous()\n            roi_feats.append(roi_feat)\n\n        return torch.stack(roi_feats, dim=2), feat\n","AFTER":"                feat: Union[Tensor, Tuple[Tensor]],\n                rois: Tensor) -> tuple:\n        \"\"\"Forward function for extract roi features.\n\n        Args:\n            feat (Tensor or Tuple[Tensor]): The image features extracted by\n                the upstream network. The shape of feat is N, C, T, H, W.\n            rois (Tensor): Input RoIs, shape (k, 5).\n\n        Returns:\n            tuple: A tuple of roi features and global features.\n\n                - roi_feats (Tensor): Extracted bbox RoI features.\n                - feat (Tensor): Global features of the video clip.\n        \"\"\"\n        if not isinstance(feat, tuple):\n            feat = (feat, )\n\n        if len(feat) >= 2:\n            maxT = max([x.shape[2] for x in feat])\n            max_shape = (maxT, ) + feat[0].shape[3:]\n            # resize each feat to the largest shape (w. nearest)\n            feat = [F.interpolate(x, max_shape).contiguous() for x in feat]\n\n        if self.with_temporal_pool:\n            if self.temporal_pool_mode == 'avg':\n                feat = [torch.mean(x, 2, keepdim=True) for x in feat]\n            elif self.temporal_pool_mode == 'max':\n                feat = [torch.max(x, 2, keepdim=True)[0] for x in feat]\n            else:\n                raise NotImplementedError\n\n        feat = torch.cat(feat, axis=1).contiguous()\n\n        roi_feats = []\n        for t in range(feat.size(2)):\n            frame_feat = feat[:, :, t].contiguous()\n            roi_feat = self.roi_layer(frame_feat, rois)\n            if self.with_global:\n                global_feat = self.global_pool(frame_feat.contiguous())\n                inds = rois[:, 0].type(torch.int64)\n                global_feat = global_feat[inds]\n                roi_feat = torch.cat([roi_feat, global_feat], dim=1)\n                roi_feat = roi_feat.contiguous()\n            roi_feats.append(roi_feat)\n\n        roi_feats = torch.stack(roi_feats, dim=2)\n        return roi_feats, feat\n"}