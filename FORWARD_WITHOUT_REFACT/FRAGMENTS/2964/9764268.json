{"BEFORE":"        q = self.to_q(x)\n        kv = self.to_kv(x).chunk(2, dim=-1) if not self.context_only else (context, context)\n\n        assert divisible_by(kv[0].shape[1], self.kv_buckets), 'key\/value sequences need to be divisible by key\/value bucket size'\n\n        qkv = (q, *kv)\n        merge_heads_fn = partial(merge_heads, h)\n        q, k, v = map(merge_heads_fn, qkv)\n\n        split_index_fn = partial(split_at_index, 1, l_h)\n        (lq, q), (lk, k), (lv, v) = map(split_index_fn, (q, k, v))\n\n        out = []\n\n        if lq.shape[1] > 0:\n            out.append(self.local_attention(lq, lk, lv, input_mask = input_mask))\n\n        if q.shape[1] > 0:\n","AFTER":"        q = self.to_q(x)\n        kv = self.to_kv(x).chunk(2, dim=-1) if not self.context_only else (context, context)\n\n        assert divisible_by(kv[0].shape[1], self.kv_buckets), 'key\/value sequences need to be divisible by key\/value bucket size'\n\n        qkv = (q, *kv)\n        merge_heads_fn = partial(merge_heads, h)\n        q, k, v = map(merge_heads_fn, qkv)\n\n        split_index_fn = partial(split_at_index, 1, l_h)\n        (lq, q), (lk, k), (lv, v) = map(split_index_fn, (q, k, v))\n        has_local, has_sinkhorn = map(lambda x: x.shape[1] > 0, (lq, q))\n\n        out = []\n\n        if has_local > 0:\n            out.append(self.local_attention(lq, lk, lv, input_mask = input_mask))\n\n        if has_sinkhorn > 0:\n"}