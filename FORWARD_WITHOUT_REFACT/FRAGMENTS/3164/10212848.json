{"BEFORE":"    def forward(self, feat_maps, smap, lmap=None, shape=None):\n        assert not xor(self.lmap_in is True, lmap is not None)\n        for i, f in enumerate(feat_maps):\n            if f.shape[-2:] != shape:\n                feat_maps[i] = self.upsample(f, shape)\n        x = torch.cat(feat_maps, dim=1)\n        b, c, h, w = x.shape\n        \n        # compute class probability\n        smap = F.interpolate(smap, size=x.shape[-2:], mode='bilinear', align_corners=False)\n        smap = torch.sigmoid(smap)\n        p = smap - self.threshold\n\n        fg = torch.clip(p, 0, 1) # foreground\n        bg = torch.clip(-p, 0, 1) # background\n        cg = self.threshold - torch.abs(p) # confusion area\n\n        if self.lmap_in is True:\n            lmap = F.interpolate(lmap, size=x.shape[-2:], mode='bilinear', align_corners=False)\n            lmap = torch.sigmoid(lmap)\n            lp = lmap - self.lthreshold\n            fp = torch.clip(lp, 0, 1) # foreground\n            bp = torch.clip(-lp, 0, 1) # background\n\n            prob = [fg, bg, cg, fp, bp]\n        else:\n            prob = [fg, bg, cg]\n\n        prob = torch.cat(prob, dim=1)\n\n        # reshape feature & prob\n        f = x.view(b, h * w, -1)\n        prob = prob.view(b, self.ctx, h * w)\n        \n        # compute context vector\n        context = torch.bmm(prob, f).permute(0, 2, 1).unsqueeze(3) # b, 3, c\n\n        # k q v compute\n        query = self.conv_query(x).view(b, self.channel, -1).permute(0, 2, 1)\n        key = self.conv_key(context).view(b, self.channel, -1)\n        value = self.conv_value(context).view(b, self.channel, -1).permute(0, 2, 1)\n\n        # compute similarity map\n        sim = torch.bmm(query, key) # b, hw, c x b, c, 2\n        sim = (self.channel ** -.5) * sim\n        sim = F.softmax(sim, dim=-1)\n\n        # compute refined feature\n        context = torch.bmm(sim, value).permute(0, 2, 1).contiguous().view(b, -1, h, w)\n        out = self.conv_out(context)\n        return out\n","AFTER":"        context = torch.bmm(sim, value).permute(0, 2, 1).contiguous().view(b, -1, h, w)\n        context = self.conv_out1(context)\n        \n        x = torch.cat([x, context], dim=1)\n        x = self.conv_out2(x)\n        x = self.conv_out3(x)\n        out = self.conv_out4(x)\n\n        return x, out\n"}