{"BEFORE":"        self.base_channels = base_channels\n        self.out_conv_channels = out_conv_channels\n        self.encode_conv_channels = encode_conv_channels\n        self.encode_paddings = encode_paddings\n        self.decode_conv_channels = decode_conv_channels\n        self.decode_paddings = decode_paddings\n        self.stage_num = len(self.encode_conv_channels)\n        # Spconv init all weight on its own\n        # TODO: make the network could be modified\n\n        if pre_act:\n            # TODO: use ConvModule to encapsulate\n            self.conv_input = spconv.SparseSequential(\n                spconv.SubMConv3d(\n                    in_channels,\n                    self.base_channels,\n                    3,\n                    padding=1,\n                    bias=False,\n                    indice_key='subm1'), )\n            make_block = self.pre_act_block\n        else:\n            norm_name, norm_layer = build_norm_layer(norm_cfg,\n                                                     self.base_channels)\n            self.conv_input = spconv.SparseSequential(\n                spconv.SubMConv3d(\n                    in_channels,\n                    self.base_channels,\n                    3,\n                    padding=1,\n                    bias=False,\n                    indice_key='subm1'),\n                norm_layer,\n                nn.ReLU(),\n            )\n            make_block = self.post_act_block\n\n        encoder_out_channels = self.make_encode_layers(make_block, norm_cfg,\n                                                       self.base_channels)\n        self.make_decode_layers(make_block, norm_cfg, encoder_out_channels)\n\n        norm_name, norm_layer = build_norm_layer(norm_cfg,\n                                                 self.out_conv_channels)\n        self.conv_out = spconv.SparseSequential(\n            # [200, 176, 5] -> [200, 176, 2]\n            spconv.SparseConv3d(\n                encoder_out_channels,\n                self.out_conv_channels, (3, 1, 1),\n                stride=(2, 1, 1),\n                padding=0,\n                bias=False,\n                indice_key='spconv_down2'),\n            norm_layer,\n            nn.ReLU(),\n        )\n","AFTER":"        self.base_channels = base_channels\n        self.output_channels = output_channels\n        self.encoder_channels = encoder_channels\n        self.encoder_paddings = encoder_paddings\n        self.decoder_channels = decoder_channels\n        self.decoder_paddings = decoder_paddings\n        self.stage_num = len(self.encoder_channels)\n        # Spconv init all weight on its own\n\n        if pre_act:\n            # TODO: use ConvModule to encapsulate\n            self.conv_input = spconv.SparseSequential(\n                spconv.SubMConv3d(\n                    in_channels,\n                    self.base_channels,\n                    3,\n                    padding=1,\n                    bias=False,\n                    indice_key='subm1'), )\n            make_block = self.pre_act_block\n        else:\n            self.conv_input = spconv.SparseSequential(\n                spconv.SubMConv3d(\n                    in_channels,\n                    self.base_channels,\n                    3,\n                    padding=1,\n                    bias=False,\n                    indice_key='subm1'),\n                build_norm_layer(norm_cfg, self.base_channels)[1],\n                nn.ReLU(),\n            )\n            make_block = self.post_act_block\n\n        encoder_out_channels = self.make_encoder_layers(\n            make_block, norm_cfg, self.base_channels)\n        self.make_decoder_layers(make_block, norm_cfg, encoder_out_channels)\n\n        self.conv_out = spconv.SparseSequential(\n            # [200, 176, 5] -> [200, 176, 2]\n            spconv.SparseConv3d(\n                encoder_out_channels,\n                self.output_channels, (3, 1, 1),\n                stride=(2, 1, 1),\n                padding=0,\n                bias=False,\n                indice_key='spconv_down2'),\n            build_norm_layer(norm_cfg, self.output_channels)[1],\n            nn.ReLU(),\n        )\n"}