{"BEFORE":"    def __init__(self, in_planes, planes, stride=1, option='A'):\n        super(BasicBlock_1w1a, self).__init__()\n        self.conv1 = BinarizeConv2d(in_planes, planes, kernel_size=3, stride=stride, padding=1, bias=False)\n        self.bn1 = nn.BatchNorm2d(planes)\n        self.conv2 = BinarizeConv2d(planes, planes, kernel_size=3, stride=1, padding=1, bias=False)\n        self.bn2 = nn.BatchNorm2d(planes)\n        self.prelu = nn.PReLU(planes)\n\n        self.shortcut = nn.Sequential()\n        if stride != 1 or in_planes != planes:\n            if option == 'A':\n                \"\"\"\n                For CIFAR10 ResNet paper uses option A.\n                \"\"\"\n                self.shortcut = LambdaLayer(lambda x:\n                                            F.pad(x[:, :, ::2, ::2], (0, 0, 0, 0, planes\/\/4, planes\/\/4), \"constant\", 0))\n            elif option == 'B':\n                self.shortcut = nn.Sequential(\n                     BinarizeConv2d(in_planes, self.expansion * planes, kernel_size=1, stride=stride, bias=False),\n                     nn.BatchNorm2d(self.expansion * planes)\n                )\n\n\n    def forward(self, x):\n","AFTER":"        pad = 0 if planes == self.expansion*in_planes else planes \/\/ 4\n        if stride != 1 or in_planes != planes:\n            self.shortcut = nn.Sequential(\n                        nn.AvgPool2d((2,2)), \n                        LambdaLayer(lambda x:\n                        F.pad(x, (0, 0, 0, 0, pad, pad), \"constant\", 0)))\n"}