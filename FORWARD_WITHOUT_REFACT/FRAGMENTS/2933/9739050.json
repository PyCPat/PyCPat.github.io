{"BEFORE":"        self.training |= self.export\r\n        for i in range(self.nl):\r\n            x[i] = self.m[i](x[i])  # conv\r\n            bs, _, ny, nx = x[i].shape  # x(bs,255,20,20) to x(bs,3,20,20,85)\r\n            x[i] = x[i].view(bs, self.na, self.no, ny, nx).permute(0, 1, 3, 4, 2).contiguous()\r\n\r\n            if not self.training:  # inference\r\n                if self.grid[i].shape[2:4] != x[i].shape[2:4]:\r\n                    self.grid[i] = self._make_grid(nx, ny).to(x[i].device)\r\n\r\n                y = x[i].sigmoid()\r\n                y[..., 0:2] = (y[..., 0:2] * 2. - 0.5 + self.grid[i]) * self.stride[i]  # xy\r\n                y[..., 2:4] = (y[..., 2:4] * 2) ** 2 * self.anchor_grid[i]  # wh\r\n","AFTER":"        for i in range(self.nl):\r\n            x[i] = self.m[i](x[i])  # conv\r\n            bs, _, ny, nx = x[i].shape  # x(bs,255,20,20) to x(bs,3,20,20,85)\r\n            x[i] = x[i].view(bs, self.na, self.no, ny, nx).permute(0, 1, 3, 4, 2).contiguous()\r\n\r\n            if not self.training:  # inference\r\n                if self.grid[i].shape[2:4] != x[i].shape[2:4] or self.onnx_dynamic:\r\n                    self.grid[i], self.anchor_grid[i] = self._make_grid(nx, ny, i)\r\n\r\n                y = x[i].sigmoid()\r\n                if self.inplace:\r\n                    y[..., 0:2] = (y[..., 0:2] * 2. - 0.5 + self.grid[i]) * self.stride[i]  # xy\r\n                    y[..., 2:4] = (y[..., 2:4] * 2) ** 2 * self.anchor_grid[i]  # wh\r\n                else:  # for YOLOv5 on AWS Inferentia https:\/\/github.com\/ultralytics\/yolov5\/pull\/2953\r\n                    xy = (y[..., 0:2] * 2. - 0.5 + self.grid[i]) * self.stride[i]  # xy\r\n                    wh = (y[..., 2:4] * 2) ** 2 * self.anchor_grid[i]  # wh\r\n                    y = torch.cat((xy, wh, y[..., 4:]), -1)\r\n                z.append(y.view(bs, -1, self.no))\r\n"}