{"BEFORE":"                if self.use_l1:\n                    origin_preds.append(reg_output.clone())\n\n            else:\n","AFTER":"            reg_output = self.reg_preds[k](reg_feat)\n            obj_output = self.obj_preds[k](reg_feat)\n\n            if self.training:\n                output = torch.cat([reg_output, obj_output, cls_output], 1)\n                output, grid = self.get_output_and_grid(output, k, stride_this_level, xin[0].type())\n                x_shifts.append(grid[:, :, 0])\n                y_shifts.append(grid[:, :, 1])\n                expanded_strides.append(\n                    torch.zeros(1, grid.shape[1]).fill_(stride_this_level).type_as(xin[0])\n                )\n                if self.use_l1:\n                    batch_size = reg_output.shape[0]\n                    hsize, wsize = reg_output.shape[-2:]\n                    reg_output = reg_output.view(batch_size, self.n_anchors, 4, hsize, wsize)\n                    reg_output = (\n                        reg_output.permute(0, 1, 3, 4, 2)\n                        .reshape(batch_size, -1, 4)\n                    )\n                    origin_preds.append(reg_output.clone())\n\n            else:\n"}