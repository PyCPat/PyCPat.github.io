{"BEFORE":"        dists = torch.matmul(anchor, positive.permute(1,0))\n        # add 10 to false negative\n        # dist_keypts = np.eye(dist_keypts.shape[0]) * 10 + dist_keypts.detach().cpu().numpy()\n        # add_matrix = torch.zeros_like(dists)\n        # add_matrix[np.where(dist_keypts < self.safe_radius)] += 10\n        # dists = dists + add_matrix\n        false_negative = dist_keypts < self.safe_radius\n\n        pos_mask = torch.eq(torch.unsqueeze(pids, dim=1), torch.unsqueeze(pids, dim=0))\n        # pos_mask = pos_mask | false_negative\n        neg_mask = torch.logical_not(pos_mask | false_negative)\n\n        # dists * pos_mask get the distance of each valid anchor-positive pair.\n        furthest_positive, _ = torch.min(dists + 1e5 * (~pos_mask).float(), dim=1)\n        # here we use \"dists +  10000*pos_mask\" to avoid the anchor-positive pair been selected.\n        closest_negative, _ = torch.max(dists - 1e5 * (~neg_mask).float(), dim=1)\n        # closest_negative_row, _ = torch.min(dists + 1e5 * pos_mask.float(), dim=0)\n        # closest_negative = torch.min(closest_negative_col, closest_negative_row)\n        average_negative = (torch.sum(dists, dim=-1) - furthest_positive) \/ (dists.shape[0] - 1)\n        accuracy = (furthest_positive > closest_negative).sum() * 100.0 \/ dists.shape[0]\n\n\n        # pos = dists + 1e5 * (~pos_mask).float()\n        pos = furthest_positive[:, None]\n        pos_weight = (self.pos_optimal - pos).detach()\n        pos_weight = torch.max(torch.zeros_like(pos_weight), pos_weight)\n        lse_positive = torch.logsumexp(-self.log_scale * (pos - self.pos_margin) * pos_weight, dim=-1)\n\n        neg = dists - 128 * (~neg_mask).float()\n        neg_weight =  (neg - self.neg_optimal).detach()\n        neg_weight = torch.max(torch.zeros_like(neg_weight), neg_weight)\n        lse_negative_row = torch.logsumexp(self.log_scale * (neg - self.neg_margin) * neg_weight, dim=-1)\n        lse_negative_col = torch.logsumexp(self.log_scale * (neg - self.neg_margin) * neg_weight, dim=-2)\n\n        loss_row = F.softplus(lse_positive + lse_negative_row) \/ self.log_scale\n        loss_col = F.softplus(lse_positive + lse_negative_col) \/ self.log_scale\n        loss = (loss_row + loss_col) \/ 2\n","AFTER":"        dists = cdist(anchor, positive, metric='euclidean')\n        # build false negative \n        false_negative = dist_keypts < self.safe_radius\n\n        pos_mask = torch.eq(torch.unsqueeze(pids, dim=1), torch.unsqueeze(pids, dim=0))\n        neg_mask = torch.logical_not(pos_mask | false_negative)\n\n        # dists * pos_mask get the distance of each valid anchor-positive pair.\n        furthest_positive, _ = torch.max(dists * pos_mask.float(), dim=1)\n        # here we use \"dists +  10000*pos_mask\" to avoid the anchor-positive pair been selected.\n        closest_negative, _ = torch.min(dists + 1e5 * pos_mask.float(), dim=1)\n        # closest_negative_row, _ = torch.min(dists + 1e5 * pos_mask.float(), dim=0)\n        # closest_negative = torch.min(closest_negative_col, closest_negative_row)\n        average_negative = (torch.sum(dists, dim=-1) - furthest_positive) \/ (dists.shape[0] - 1)\n        diff = furthest_positive - closest_negative\n        accuracy = (diff < 0).sum() * 100.0 \/ diff.shape[0]\n\n        pos = dists - 1e5 * neg_mask.float()\n        pos_weight = (pos - self.pos_optimal).detach()\n        pos_weight = torch.max(torch.zeros_like(pos_weight), pos_weight)\n        lse_positive = torch.logsumexp(self.log_scale * (pos - self.pos_margin) * pos_weight, dim=-1)\n\n        \n        neg = dists + 1e5 * (~neg_mask).float()\n        neg_weight =  (self.neg_optimal - neg).detach()\n        neg_weight = torch.max(torch.zeros_like(neg_weight), neg_weight)\n        lse_negative_row = torch.logsumexp(self.log_scale * (self.neg_margin - neg) * neg_weight, dim=-1)\n        lse_negative_col = torch.logsumexp(self.log_scale * (self.neg_margin - neg) * neg_weight, dim=-2)\n\n        loss_col = F.softplus(lse_positive + lse_negative_row) \/ self.log_scale\n        loss_row = F.softplus(lse_positive + lse_negative_col) \/ self.log_scale\n        loss = loss_col + loss_row\n"}