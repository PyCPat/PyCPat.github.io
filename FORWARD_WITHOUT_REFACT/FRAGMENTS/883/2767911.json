{"BEFORE":"                mask = (mask_i * mask_j) & nbhd_mask\n            else:\n                mask_j = rearrange(mask, 'b j -> b () j')\n                mask = mask_i * mask_j\n\n        if exists(self.coors_mlp):\n            coor_weights = self.coors_mlp(m_ij)\n            coor_weights = rearrange(coor_weights, 'b i j () -> b i j')\n\n            if self.norm_coor_weights:\n                coor_weights = coor_weights.tanh()\n\n            if self.norm_rel_coors:\n                rel_coors = F.normalize(rel_coors, dim = -1) * self.rel_coors_scale\n\n            if exists(mask):\n                coor_weights.masked_fill_(~mask, 0.)\n\n            coors_out = einsum('b i j, b i j c -> b i c', coor_weights, rel_coors) + coors\n        else:\n            coors_out = coors\n\n        if exists(self.node_mlp):\n            m_ij = m_ij.masked_fill(~mask[..., None], 0.)\n\n            if self.m_pool_method == 'mean':\n                if exists(mask):\n                    # masked mean\n                    mask_sum = mask.sum(dim = -1)[..., None]\n                    m_i = safe_div(m_ij.sum(dim = -2), mask_sum)\n                    m_i = m_i.masked_fill(mask_sum == 0, 0.) # account for a row with no neighbors at all (just set to 0)\n","AFTER":"        if exists(mask):\n            num_nodes = mask.sum(dim = -1)\n\n        use_nearest = num_nearest > 0\n\n        rel_coors = rearrange(coors, 'b i d -> b i () d') - rearrange(coors, 'b j d -> b () j d')\n        rel_dist = (rel_coors ** 2).sum(dim = -1, keepdim = True)\n\n        i = j = n\n\n        if use_nearest:\n            ranking = rel_dist[..., 0]\n\n            if exists(mask):\n                rank_mask = mask[:, None, :] * mask[:, None, :]\n                ranking.masked_fill_(~rank_mask, 1e5)\n\n            if exists(adj_mat):\n                if len(adj_mat.shape) == 2:\n                    adj_mat = repeat(adj_mat, 'i j -> b i j', b = b)\n\n                if only_sparse_neighbors:\n                    num_nearest = int(adj_mat.float().sum(dim = -1).max().item())\n                    valid_radius = 0\n\n                self_mask = rearrange(torch.eye(n, device = device, dtype = torch.bool), 'i j -> () i j')\n\n                ranking.masked_fill_(self_mask, -1.)\n                adj_mat.masked_fill_(self_mask, False)\n                ranking.masked_fill_(adj_mat, 0.)\n\n            nbhd_ranking, nbhd_indices = ranking.topk(num_nearest, dim = -1, largest = False)\n\n            nbhd_mask = nbhd_ranking <= valid_radius\n\n            rel_coors = batched_index_select(rel_coors, nbhd_indices, dim = 2)\n            rel_dist = batched_index_select(rel_dist, nbhd_indices, dim = 2)\n\n            if exists(edges):\n                edges = batched_index_select(edges, nbhd_indices, dim = 2)\n\n            j = num_nearest\n\n        if fourier_features > 0:\n            rel_dist = fourier_encode_dist(rel_dist, num_encodings = fourier_features)\n            rel_dist = rearrange(rel_dist, 'b i j () d -> b i j d')\n\n        if use_nearest:\n            feats_j = batched_index_select(feats, nbhd_indices, dim = 1)\n        else:\n            feats_j = rearrange(feats, 'b j d -> b () j d')\n\n        feats_i = rearrange(feats, 'b i d -> b i () d')\n        feats_i, feats_j = broadcast_tensors(feats_i, feats_j)\n\n        edge_input = torch.cat((feats_i, feats_j, rel_dist), dim = -1)\n\n        if exists(edges):\n            edge_input = torch.cat((edge_input, edges), dim = -1)\n\n        m_ij = self.edge_mlp(edge_input)\n\n        if exists(mask):\n            mask_i = rearrange(mask, 'b i -> b i ()')\n\n            if use_nearest:\n                mask_j = batched_index_select(mask, nbhd_indices, dim = 1)\n                mask = (mask_i * mask_j) & nbhd_mask\n            else:\n                mask_j = rearrange(mask, 'b j -> b () j')\n                mask = mask_i * mask_j\n\n        if exists(self.coors_mlp):\n            coor_weights = self.coors_mlp(m_ij)\n            coor_weights = rearrange(coor_weights, 'b i j () -> b i j')\n\n            if self.norm_coor_weights:\n                coor_weights = coor_weights.tanh()\n\n            if self.norm_rel_coors:\n                rel_coors = F.normalize(rel_coors, dim = -1) * self.rel_coors_scale\n\n            if exists(mask):\n                coor_weights.masked_fill_(~mask, 0.)\n\n            coors_out = einsum('b i j, b i j c -> b i c', coor_weights, rel_coors) + coors\n        else:\n            coors_out = coors\n\n        if exists(self.node_mlp):\n            m_ij_mask = rearrange(mask, '... -> ... ()')\n            m_ij = m_ij.masked_fill(~m_ij_mask, 0.)\n\n            if self.m_pool_method == 'mean':\n                if exists(mask):\n                    # masked mean\n                    mask_sum = m_ij_mask.sum(dim = -2)\n"}