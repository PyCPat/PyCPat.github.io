{"BEFORE":"        if self.assert_shapes: tg.guard(x, \"B, C, W, H\")\n        if self.assert_shapes:\n            tg.guard(c, \"B, NUMCLASSES\")\n            assert c.mean().item() in [1\/c.shape[1], 0.0] # i.e. every row has only one el with value 1 or all 0\n        time_embedding = self.time_embed(timestep_embedding(t, self.time_embed_size))\n        if self.assert_shapes: tg.guard(time_embedding, \"B, TE\")\n        hs = []\n        h = x\n        for i, downsample_block in enumerate(self.downsample_blocks):\n            h = downsample_block(h, time_embedding, c)\n            if i == 2:\n                h = self.self_attn(h)\n            h = self.dropouts[i](h)\n            if i != (len(self.downsample_blocks) - 1): hs.append(h)\n            if self.use_downsample and i != (len(self.downsample_blocks) - 1):\n                h = self.downsample_op(h)\n        h = self.middle_block(h, time_embedding, c)\n        for i, upsample_block in enumerate(self.upsample_blocks):\n            if i != 0:\n                h = torch.cat([h, hs[-i]], dim=1)\n            h = upsample_block(h, time_embedding, c)\n","AFTER":"        class_embedding = self.linear_class_embedding(c).reshape(x.shape[0], self.class_embed_size, self.width, self.height)\n        x = torch.cat([x, class_embedding], dim=1)\n"}