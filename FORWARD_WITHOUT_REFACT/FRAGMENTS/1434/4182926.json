{"BEFORE":"            pass\n","AFTER":"    def forward(self, input, seg_pred, im_shape, ori_shape, targets, fg_nums):\n        \"\"\"\n        Get SOLOv2 head output\n\n        Args:\n            input (list): List of Tensors, output of backbone or neck stages\n        Returns:\n            cate_pred_list (list): Tensors of each category branch layer\n            kernel_pred_list (list): Tensors of each kernel branch layer\n        \"\"\"\n        feats = self._split_feats(input)\n        # 有5个张量，5个张量的strides=[8, 8, 16, 32, 32]\n        cate_pred_list = []\n        kernel_pred_list = []\n        for idx in range(len(self.seg_num_grids)):\n            seg_num_grid = self.seg_num_grids[idx]   # 格子数。特征图会被插值成 格子数*格子数 的分辨率。\n            cate_pred, kernel_pred = self._get_output_single(feats[idx], seg_num_grid)\n            cate_pred_list.append(cate_pred)\n            kernel_pred_list.append(kernel_pred)\n\n        # return cate_pred_list, kernel_pred_list\n        if self.training:\n            ins_labels = []\n            cate_labels = []\n            grid_order_list = []\n            i = 0\n            for lvl in range(len(self.seg_num_grids)):\n                ins_labels.append(targets[i]); i += 1\n            for lvl in range(len(self.seg_num_grids)):\n                cate_labels.append(targets[i].to(torch.int32)); i += 1\n            for lvl in range(len(self.seg_num_grids)):\n                grid_order_list.append(targets[i].to(torch.int32)); i += 1\n            return self.forward_train(cate_pred_list, kernel_pred_list, seg_pred, ins_labels, cate_labels, grid_order_list, fg_nums)\n"}