{"BEFORE":"        batch_size = positions.size(0)\n        n_vertices = positions.size(1)\n        # flatten the batch for torch-geometric batch format\n        pos_flat = positions.view(-1, positions.size(-1))\n        batch = torch.cat([\n            torch.full((elem.size(0),), fill_value=i, device=positions.device, dtype=torch.long) for i, elem in enumerate(positions)\n        ])\n\n        # Vertex features\n        out = self.conv1(pos_flat, batch)\n        # out = self.conv2(out, batch)\n        # out = self.conv3(out, batch)  # n_points x length_features\n        # reshape back into batch \n        out = out.contiguous().view(batch_size, n_vertices, -1)\n\n        # aggregate features from vertices\n        out = out.max(dim=-2, keepdim=False)[0]\n\n        # post-processing\n        out = self.lin(out)\n","AFTER":"        batch_size = positions.size(0)\n        n_vertices = positions.size(1)\n        # flatten the batch for torch-geometric batch format\n        pos_flat = positions.view(-1, positions.size(-1))\n        batch = torch.cat([\n            torch.full((elem.size(0),), fill_value=i, device=positions.device, dtype=torch.long) for i, elem in enumerate(positions)\n        ])\n\n        # Vertex features + track global features from each layer (if skip connections are used)\n        # In EdgeConv features from different layers are concatenated per node and then aggregated \n        # but since the pooling is element-wise on feature vectors, we can swap the operations to save memory\n        aggr_features = []\n        out = self.conv_layers[0](pos_flat, batch)\n        if self.config['skip_connections']:\n            aggr_features.append(self.global_pool(out, batch, batch_size))\n        \n        for conv_id in range(1, self.config['conv_depth']):\n            out = self.conv_layers[conv_id](out, batch)\n            if self.config['skip_connections']:\n                aggr_features.append(self.global_pool(out, batch, batch_size))\n        \n        feature = torch.cat(aggr_features, -1) if self.config['skip_connections'] else self.global_pool(out, batch, batch_size)\n\n        # post-processing\n        out = self.lin(feature)\n"}