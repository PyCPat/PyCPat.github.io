{"BEFORE":"        states = to_list(state)\n        noise = torch.randn_like(embed, requires_grad=True) * self.noise_var\n\n        for i in range(self.num_steps + 2):\n            # Compute perturbed states \n            embed_perturbed = embed + noise \n            states_perturbed = to_list(self.eval_fn(embed_perturbed))\n            loss = 0\n            # Compute perturbation loss over all states \n            for j in range(len(states)):\n                loss += self.loss_fn[j](states_perturbed[j], states[j].detach())\n            if i == self.num_steps + 1: \n                return loss \n            # Compute noise gradient     \n            noise_gradient = torch.autograd.grad(loss, noise)[0]\n","AFTER":"        noise = torch.randn_like(embed, requires_grad=True) * self.noise_var\n\n        # Indefinite loop with counter \n        for i in count():\n            # Compute perturbed embed and states \n            embed_perturbed = embed + noise \n            state_perturbed = self.eval_fn(embed_perturbed)\n            # Return final loss if last step (undetached state)\n            if i == self.num_steps: \n                return self.loss_last_fn(state_perturbed, state) \n            # Compute perturbation loss (detached state)\n            loss = self.loss_fn(state_perturbed, state.detach())\n            # Compute noise gradient ∂loss\/∂noise\n            noise_gradient, = torch.autograd.grad(loss, noise)\n"}