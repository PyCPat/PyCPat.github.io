{"BEFORE":"        self.conv1 = nn.Conv2d(3, 64, (3, 3), (1, 1), (1, 1))\n\n        # Feature extraction backbone network.\n        trunk = []\n        for _ in range(23):\n            trunk.append(ResidualResidualDenseBlock(64, 32))\n        self.trunk = nn.Sequential(*trunk)\n\n        # After the feature extraction network, reconnect a layer of convolutional blocks.\n        self.conv2 = nn.Conv2d(64, 64, (3, 3), (1, 1), (1, 1))\n\n        # Upsampling convolutional layer.\n        self.upsampling = nn.Sequential(\n            nn.Conv2d(64, 64, (3, 3), (1, 1), (1, 1)),\n            nn.LeakyReLU(0.2, True)\n        )\n\n        # Reconnect a layer of convolution block after upsampling.\n        self.conv3 = nn.Sequential(\n            nn.Conv2d(64, 64, (3, 3), (1, 1), (1, 1)),\n            nn.LeakyReLU(0.2, True)\n        )\n\n        # Output layer.\n        self.conv4 = nn.Conv2d(64, 3, (3, 3), (1, 1), (1, 1))\n","AFTER":"        self.conv_block1 = nn.Sequential(\n            nn.Conv2d(3, 64, (9, 9), (1, 1), (4, 4)),\n            nn.PReLU(),\n        )\n\n        # Features trunk blocks.\n        trunk = []\n        for _ in range(16):\n            trunk.append(ResidualConvBlock(64))\n        self.trunk = nn.Sequential(*trunk)\n\n        # Second conv layer.\n        self.conv_block2 = nn.Sequential(\n            nn.Conv2d(64, 64, (3, 3), (1, 1), (1, 1), bias=False),\n            nn.BatchNorm2d(64),\n        )\n\n        # Upscale block\n        upsampling = []\n        for _ in range(2):\n            upsampling.append(UpsampleBlock(64))\n        self.upsampling = nn.Sequential(*upsampling)\n\n        # Output layer.\n        self.conv_block3 = nn.Conv2d(64, 3, (9, 9), (1, 1), (4, 4))\n\n        # Initialize neural network weights\n        self._initialize_weights()\n"}