{"BEFORE":"        if not isinstance(imgs, list):\n            imgs = [imgs]\n        shape0, shape1 = [], []  # image and inference shapes\n        batch = range(len(imgs))  # batch size\n        for i in batch:\n            imgs[i] = np.array(imgs[i])  # to numpy\n            if imgs[i].shape[0] < 5:  # image in CHW\n                imgs[i] = imgs[i].transpose((1, 2, 0))  # reverse dataloader .transpose(2, 0, 1)\n            imgs[i] = imgs[i][:, :, :3] if imgs[i].ndim == 3 else np.tile(imgs[i][:, :, None], 3)  # enforce 3ch input\n            s = imgs[i].shape[:2]  # HWC\n            shape0.append(s)  # image shape\n            g = (size \/ max(s))  # gain\n            shape1.append([y * g for y in s])\n        shape1 = [make_divisible(x, int(self.stride.max())) for x in np.stack(shape1, 0).max(0)]  # inference shape\n        x = [letterbox(imgs[i], new_shape=shape1, auto=False)[0] for i in batch]  # pad\n        x = np.stack(x, 0) if batch[-1] else x[0][None]  # stack\n        x = np.ascontiguousarray(x.transpose((0, 3, 1, 2)))  # BHWC to BCHW\n        x = torch.from_numpy(x).to(p.device).type_as(p) \/ 255.  # uint8 to fp16\/32\n\n        # Inference\n        with torch.no_grad():\n            y = self.model(x, augment, profile)[0]  # forward\n        y = non_max_suppression(y, conf_thres=self.conf, iou_thres=self.iou, classes=self.classes)  # NMS\n\n        # Post-process\n        for i in batch:\n","AFTER":"        n, imgs = (len(imgs), imgs) if isinstance(imgs, list) else (1, [imgs])  # number of images, list of images\n        shape0, shape1 = [], []  # image and inference shapes\n        for i, im in enumerate(imgs):\n            if isinstance(im, str):  # filename or uri\n                im = Image.open(requests.get(im, stream=True).raw if im.startswith('http') else im)  # open\n            im = np.array(im)  # to numpy\n            if im.shape[0] < 5:  # image in CHW\n                im = im.transpose((1, 2, 0))  # reverse dataloader .transpose(2, 0, 1)\n            im = im[:, :, :3] if im.ndim == 3 else np.tile(im[:, :, None], 3)  # enforce 3ch input\n            s = im.shape[:2]  # HWC\n            shape0.append(s)  # image shape\n            g = (size \/ max(s))  # gain\n            shape1.append([y * g for y in s])\n            imgs[i] = im  # update\n        shape1 = [make_divisible(x, int(self.stride.max())) for x in np.stack(shape1, 0).max(0)]  # inference shape\n        x = [letterbox(im, new_shape=shape1, auto=False)[0] for im in imgs]  # pad\n        x = np.stack(x, 0) if n > 1 else x[0][None]  # stack\n        x = np.ascontiguousarray(x.transpose((0, 3, 1, 2)))  # BHWC to BCHW\n        x = torch.from_numpy(x).to(p.device).type_as(p) \/ 255.  # uint8 to fp16\/32\n\n        # Inference\n        with torch.no_grad():\n            y = self.model(x, augment, profile)[0]  # forward\n        y = non_max_suppression(y, conf_thres=self.conf, iou_thres=self.iou, classes=self.classes)  # NMS\n\n        # Post-process\n        for i in range(n):\n"}