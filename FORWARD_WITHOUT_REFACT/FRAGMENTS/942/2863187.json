{"BEFORE":"            needRegMask = (freqMap > (float(h * w) \/ k)).float()\n            sample = torch.distributions.Categorical(logits=torch.zeros_like(logit)).sample()\n            logit = logit.permute(0, 3, 1, 2)\n            ceReg = F.cross_entropy(logit, sample, reduction=\"none\") * needRegMask\n            cePush = F.cross_entropy(logit, code, reduction=\"none\") * (1 - needRegMask)\n            regs.append(ceReg.mean() + cePush.mean())\n","AFTER":"    def forward(self, images, restored, codes, logits, codeFreqMap, binCounts):\n        l2Loss = F.mse_loss(restored, images)\n        l1Loss = F.l1_loss(restored, images)\n        ssimLoss = 1 - self._msssim(restored + 1, images + 1)\n        # ssimLoss = (1 - self._msssim((restored + 1), (images + 1))).log10().mean()\n        # ssimLoss = -F.binary_cross_entropy(ssimLoss, torch.ones_like(ssimLoss))\n        regs = list()\n\n        n, h, w, k = logits[0].shape\n\n        # codes: [m, n, h, w]; logits: m * list(n, h, w, k); codeFreqMap: m * list([n, h, w]), binCounts: m * list([n, k])\n        for code, logit, freqMap, binCount in zip(codes.permute(1, 0, 2, 3), logits, codeFreqMap, binCounts):\n            maxFreq, _ = binCount.max(-1, keepdim=True)\n            needRegMask = (freqMap > (float(h * w) \/ k)).float()\n            # reverse frequencies\n            # max bin -> 4\n            # min bin -> 4 + maxbin - minbin\n            # [n, k]\n            reverseBin = maxFreq + (float(h * w) \/ k) - binCount\n            # frequency to prob\n            prob = reverseBin \/ (maxFreq + (float(h * w) \/ k))\n            # [n, h, w]\n            sample = torch.distributions.Categorical(probs=prob).sample((h, w)).permute(2, 0, 1)\n            logit = logit.permute(0, 3, 1, 2)\n            # [n, 1, 1]\n            weight = freqMap \/ maxFreq[:, None]\n            ceReg = F.cross_entropy(logit, sample, reduction=\"none\") * needRegMask * weight\n            cePush = F.cross_entropy(logit, code, reduction=\"none\") * (1 - needRegMask) * weight\n            regs.append((ceReg + cePush).mean())\n"}