{"BEFORE":"        rel_coors = rearrange(coors, 'b i d -> b i () d') - rearrange(coors, 'b j d -> b () j d')\n        rel_dist = rel_coors.norm(dim = -1, keepdim = True)\n\n        if fourier_features > 0:\n            rel_dist = fourier_encode_dist(rel_dist, num_encodings = fourier_features)\n            rel_dist = rearrange(rel_dist, 'b i j () d -> b i j d')\n\n        rel_dist = repeat(rel_dist, 'b i j d -> b h i j d', h = h)\n\n        # derive queries keys and values\n\n        q, k, v = self.to_qkv(feats).chunk(3, dim = -1)\n        q, k, v = map(lambda t: rearrange(t, 'b n (h d) -> b h n d', h = h), (q, k, v))\n\n        # expand queries and keys for concatting\n\n        q = repeat(q, 'b h i d -> b h i n d', n = n)\n        k = repeat(k, 'b h j d -> b h n j d', n = n)\n\n        edge_input = torch.cat((q, k, rel_dist), dim = -1)\n\n        if exists(edges):\n            edges = repeat(edges, 'b i j d -> b h i j d', h = h)\n            edge_input = torch.cat((edge_input, edges), dim = -1)\n\n        m_ij = self.edge_mlp(edge_input)\n\n        coor_weights = self.coors_mlp(m_ij)\n        mask_value = -torch.finfo(coor_weights.dtype).max\n\n        mask = rearrange(torch.eye(n).bool(), 'i j -> () () i j')\n        coor_weights.masked_fill_(mask, mask_value)\n        coors_attn = coor_weights.softmax(dim = -1)\n\n        coors_out = einsum('b h i j, b i j c -> b i c', coors_attn, rel_coors) + coors\n","AFTER":"        rel_coors = rearrange(coors, 'b i d -> b i () d') - rearrange(coors, 'b j d -> b () j d')\n        rel_dist = rel_coors.norm(dim = -1, keepdim = True)\n\n        if fourier_features > 0:\n            rel_dist = fourier_encode_dist(rel_dist, num_encodings = fourier_features)\n            rel_dist = rearrange(rel_dist, 'b i j () d -> b i j d')\n\n        rel_dist = repeat(rel_dist, 'b i j d -> b h i j d', h = h)\n\n        # derive queries keys and values\n\n        q, k, v = self.to_qkv(feats).chunk(3, dim = -1)\n        q, k, v = map(lambda t: rearrange(t, 'b n (h d) -> b h n d', h = h), (q, k, v))\n\n        # expand queries and keys for concatting\n\n        q = repeat(q, 'b h i d -> b h i n d', n = n)\n        k = repeat(k, 'b h j d -> b h n j d', n = n)\n\n        edge_input = torch.cat((q, k, rel_dist), dim = -1)\n\n        if exists(edges):\n            edges = repeat(edges, 'b i j d -> b h i j d', h = h)\n            edge_input = torch.cat((edge_input, edges), dim = -1)\n\n        m_ij = self.edge_mlp(edge_input)\n\n        coor_weights = self.coors_mlp(m_ij)\n        coors_out = einsum('b h i j, b i j c -> b i c', coor_weights, rel_coors) + coors\n"}