{"BEFORE":"    def __init__(self, inplanes, planes, stride=1, downsample=None, groups=1,\n                 base_width=64, dilation=1, norm_layer=None):\n        super(Bottleneck, self).__init__()\n        if norm_layer is None:\n            norm_layer = nn.BatchNorm2d\n        width = int(planes * (base_width \/ 64.)) * groups\n        # Both self.conv2 and self.downsample layers downsample the input when stride != 1\n        self.conv1 = conv1x1(inplanes, width)\n        self.bn1 = norm_layer(width)\n        self.conv2 = conv3x3(width, width, stride, groups, dilation)\n        self.bn2 = norm_layer(width)\n        self.conv3 = conv1x1(width, planes * self.expansion)\n        self.bn3 = norm_layer(planes * self.expansion)\n        self.relu = nn.ReLU(inplace=True)\n        self.downsample = downsample\n        self.stride = stride\n","AFTER":"    def __init__(self, pretrained=True):\n        super(ResNetBackbone, self).__init__()\n        self._norm_layer = nn.BatchNorm2d\n        self.inplanes = 64\n        self.dilation = 1\n        self.groups = 1\n        self.base_width = 64\n        self.conv1 = nn.Conv2d(3, self.inplanes, kernel_size=7, stride=2, padding=3, bias=False)\n        self.bn1 = self._norm_layer(self.inplanes)\n        self.relu = nn.ReLU(inplace=True)\n        self.layer1 = self._make_layer(BasicBlock, 64, 2)\n        self.layer2 = self._make_layer(BasicBlock, 128, 2, stride=2)\n        self.layer3 = self._make_layer(BasicBlock, 256, 2, stride=2)\n        self.layer4 = self._make_layer(BasicBlock, 512, 2, stride=2)\n\n        if pretrained:\n            self.load_pre_trained_weights()\n\n    def load_pre_trained_weights(self):\n"}