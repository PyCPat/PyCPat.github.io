{"BEFORE":"        if self.has_mean:\n            batch_size = x.data.size(0)\n            x = x - torch.autograd.Variable(self.mean_img.repeat(batch_size, 1, 1, 1))\n\n        ind = -2\n        self.loss = None\n        outputs = dict()\n        for block in self.blocks:\n            ind = ind + 1\n            # if ind > 14:\n            #    return x\n\n            if block['type'] == 'net':\n                continue\n            elif block['type'] == 'convolutional' or block['type'] == 'maxpool' or block['type'] == 'reorg' or block[\n                'type'] == 'avgpool' or block['type'] == 'softmax' or block['type'] == 'connected' or block[\n                'type'] == 'dropout':\n                x = self.models[ind](x)\n                outputs[ind] = x\n            elif block['type'] == 'route':\n                layers = block['layers'].split(',')\n                layers = [int(i) if int(i) > 0 else int(i) + ind for i in layers]\n                if len(layers) == 1:\n                    x = outputs[layers[0]]\n                    outputs[ind] = x\n                elif len(layers) == 2:\n                    x1 = outputs[layers[0]]\n                    x2 = outputs[layers[1]]\n                    x = torch.cat((x1, x2), 1)\n                    outputs[ind] = x\n            elif block['type'] == 'shortcut':\n                from_layer = int(block['from'])\n                activation = block['activation']\n                from_layer = from_layer if from_layer > 0 else from_layer + ind\n                x1 = outputs[from_layer]\n                x2 = outputs[ind - 1]\n                x = x1 + x2\n                if activation == 'leaky':\n                    x = F.leaky_relu(x, 0.1, inplace=True)\n                elif activation == 'relu':\n                    x = F.relu(x, inplace=True)\n                outputs[ind] = x\n            elif block['type'] == 'cost':\n                continue\n            elif block['type'] == 'region':\n                continue\n            else:\n                print('unknown type %s' % (block['type']))\n        return x\n","AFTER":"        self.loss = None\n        outputs = dict()\n        out_boxes = []\n        for block in self.blocks:\n            ind = ind + 1\n            # if ind > 0:\n            #    return x\n\n            if block['type'] == 'net':\n                continue\n            elif block['type'] in ['convolutional', 'maxpool', 'reorg', 'upsample', 'avgpool', 'softmax', 'connected']:\n                x = self.models[ind](x)\n                outputs[ind] = x\n            elif block['type'] == 'route':\n                layers = block['layers'].split(',')\n                layers = [int(i) if int(i) > 0 else int(i) + ind for i in layers]\n                if len(layers) == 1:\n                    x = outputs[layers[0]]\n                    outputs[ind] = x\n                elif len(layers) == 2:\n                    x1 = outputs[layers[0]]\n                    x2 = outputs[layers[1]]\n                    x = torch.cat((x1, x2), 1)\n                    outputs[ind] = x\n            elif block['type'] == 'shortcut':\n                from_layer = int(block['from'])\n                activation = block['activation']\n                from_layer = from_layer if from_layer > 0 else from_layer + ind\n                x1 = outputs[from_layer]\n                x2 = outputs[ind - 1]\n                x = x1 + x2\n                if activation == 'leaky':\n                    x = F.leaky_relu(x, 0.1, inplace=True)\n                elif activation == 'relu':\n                    x = F.relu(x, inplace=True)\n                outputs[ind] = x\n            elif block['type'] == 'region':\n                continue\n                if self.loss:\n                    self.loss = self.loss + self.models[ind](x)\n                else:\n                    self.loss = self.models[ind](x)\n                outputs[ind] = None\n            elif block['type'] == 'yolo':\n                if self.training:\n                    pass\n                else:\n                    boxes = self.models[ind](x)\n                    out_boxes.append(boxes)\n            elif block['type'] == 'cost':\n                continue\n            else:\n                print('unknown type %s' % (block['type']))\n        if self.training:\n            return loss\n        else:\n            return out_boxes\n\n    def print_network(self):\n"}