{"BEFORE":"        score_paired = (param[0]['score_paired']+1)\/5\n\n        pred_mat = torch.zeros_like(score_paired, dtype=torch.bool)\n        for i, j in enumerate(pred_bp[0]):\n            if i<j:\n                pred_mat[i, j] = True\n\n        ref_mat = torch.zeros_like(score_paired, dtype=torch.bool)\n        for i, j in enumerate(ref_bp[0]):\n            if i<j:\n                ref_mat[i, j] = True\n\n        loss = torch.tensor([0.], device=score_paired.device)\n        fp = score_paired[(pred_mat==True) & (ref_mat==False)]\n        if len(fp) > 0:\n            loss += self.fp_weight * self.loss_fn(fp, torch.zeros_like(fp))\n\n        fn = score_paired[(pred_mat==False) & (ref_mat==True)]\n        if len(fn) > 0:\n            loss += self.fn_weight * self.loss_fn(fn, torch.ones_like(fn))\n\n        if self.l1_weight > 0.0:\n            for p in self.model.parameters():\n                loss += self.l1_weight * torch.sum(torch.abs(p))\n\n        # if self.l2_weight > 0.0:\n        #     l2_reg = 0.0\n        #     for p in self.model.parameters():\n        #         l2_reg += torch.sum((self.l2_weight * p) ** 2)\n        #     loss += torch.sqrt(l2_reg)\n\n        return loss\n","AFTER":"        loss = torch.zeros((len(param),), device=param[0]['score_paired'].device)\n        for k in range(len(seq)):\n            score_paired = (param[k]['score_paired'] + 1) \/ self.model.gamma\n\n            pred_mat = torch.zeros_like(score_paired, dtype=torch.bool)\n            for i, j in enumerate(pred_bp[k]):\n                if i < j:\n                    pred_mat[i, j] = True\n\n            ref_mat = torch.zeros_like(score_paired, dtype=torch.bool)\n            for i, j in enumerate(ref_bp[k]):\n                if i < j:\n                    ref_mat[i, j] = True\n\n            fp = score_paired[(pred_mat==True) & (ref_mat==False)]\n            if len(fp) > 0:\n                loss[k] += self.fp_weight * self.loss_fn(fp, torch.zeros_like(fp))\n\n            fn = score_paired[(pred_mat==False) & (ref_mat==True)]\n            if len(fn) > 0:\n                loss[k] += self.fn_weight * self.loss_fn(fn, torch.ones_like(fn))\n\n            if self.l1_weight > 0.0:\n                for p in self.model.parameters():\n                    loss[k] += self.l1_weight * torch.sum(torch.abs(p))\n\n            # if self.l2_weight > 0.0:\n            #     l2_reg = 0.0\n            #     for p in self.model.parameters():\n            #         l2_reg += torch.sum((self.l2_weight * p) ** 2)\n            #     loss += torch.sqrt(l2_reg)\n\n        return loss\n"}