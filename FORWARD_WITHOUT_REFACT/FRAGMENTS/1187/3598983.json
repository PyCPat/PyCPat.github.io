{"BEFORE":"        seed_points = feat_dict['fp_xyz'][-1]\n        seed_features = feat_dict['fp_features'][-1]\n        seed_indices = feat_dict['fp_indices'][-1]\n\n        # 1. generate vote_points from seed_points\n        vote_points, vote_features = self.vote_module(seed_points,\n                                                      seed_features)\n        results = dict(\n            seed_points=seed_points,\n            seed_indices=seed_indices,\n            vote_points=vote_points,\n            vote_features=vote_features)\n\n        # 2. aggregate vote_points\n        if sample_mod == 'vote':\n            # use fps in vote_aggregation\n            sample_indices = None\n        elif sample_mod == 'seed':\n            # FPS on seed and choose the votes corresponding to the seeds\n            sample_indices = furthest_point_sample(seed_points,\n                                                   self.num_proposal)\n        elif sample_mod == 'random':\n            # Random sampling from the votes\n            batch_size, num_seed = seed_points.shape[:2]\n            sample_indices = seed_points.new_tensor(\n                torch.randint(0, num_seed, (batch_size, self.num_proposal)),\n                dtype=torch.int32)\n        else:\n            raise NotImplementedError(\n                f'Sample mode {sample_mod} is not supported!')\n\n        vote_aggregation_ret = self.vote_aggregation(vote_points,\n                                                     vote_features,\n                                                     sample_indices)\n        aggregated_points, features, aggregated_indices = vote_aggregation_ret\n        results['aggregated_points'] = aggregated_points\n        results['aggregated_features'] = features\n        results['aggregated_indices'] = aggregated_indices\n\n        # 3. predict bbox and score\n        predictions = self.conv_pred(features)\n","AFTER":"        seed_points, seed_features, seed_indices = self._extract_input(\n            feat_dict)\n\n        # 1. generate vote_points from seed_points\n        vote_points, vote_features, vote_offset = self.vote_module(\n            seed_points, seed_features)\n        results = dict(\n            seed_points=seed_points,\n            seed_indices=seed_indices,\n            vote_points=vote_points,\n            vote_features=vote_features,\n            vote_offset=vote_offset)\n\n        # 2. aggregate vote_points\n        if sample_mod == 'vote':\n            # use fps in vote_aggregation\n            aggregation_inputs = dict(\n                points_xyz=vote_points, features=vote_features)\n        elif sample_mod == 'seed':\n            # FPS on seed and choose the votes corresponding to the seeds\n            sample_indices = furthest_point_sample(seed_points,\n                                                   self.num_proposal)\n            aggregation_inputs = dict(\n                points_xyz=vote_points,\n                features=vote_features,\n                indices=sample_indices)\n        elif sample_mod == 'random':\n            # Random sampling from the votes\n            batch_size, num_seed = seed_points.shape[:2]\n            sample_indices = seed_points.new_tensor(\n                torch.randint(0, num_seed, (batch_size, self.num_proposal)),\n                dtype=torch.int32)\n            aggregation_inputs = dict(\n                points_xyz=vote_points,\n                features=vote_features,\n                indices=sample_indices)\n        elif sample_mod == 'spec':\n            # Specify the new center in vote_aggregation\n            aggregation_inputs = dict(\n                points_xyz=seed_points,\n                features=seed_features,\n                target_xyz=vote_points)\n        else:\n            raise NotImplementedError(\n                f'Sample mode {sample_mod} is not supported!')\n\n        vote_aggregation_ret = self.vote_aggregation(**aggregation_inputs)\n        aggregated_points, features, aggregated_indices = vote_aggregation_ret\n\n        results['aggregated_points'] = aggregated_points\n        results['aggregated_features'] = features\n        results['aggregated_indices'] = aggregated_indices\n\n        # 3. predict bbox and score\n        cls_predictions, reg_predictions = self.conv_pred(features)\n\n        # 4. decode predictions\n        decode_res = self.bbox_coder.split_pred(cls_predictions,\n                                                reg_predictions,\n"}