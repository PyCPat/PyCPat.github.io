{"BEFORE":"        assert predict.shape == target.shape, 'predict & target shape do not match'\n        dice = BinaryDiceLoss(**self.kwargs)\n        total_loss = 0\n        # predict = F.softmax(predict, dim=1)\n\n        for i in range(target.shape[1]):\n            if i != self.ignore_index:\n                dice_loss = dice(predict[:, i], target[:, i])\n                if self.weight is not None:\n                    assert self.weight.shape[0] == target.shape[1], \\\n                        'Expect weight shape [{}], get[{}]'.format(target.shape[1], self.weight.shape[0])\n                    dice_loss *= self.weight[i]\n                total_loss += dice_loss\n\n        return total_loss\/target.shape[1]\n","AFTER":"        smooth = 1\n\n        dice = 0.\n        # dice系数的定义\n        for i in range(pred.size(1)):\n            dice += 2 * (pred[:,i] * target[:,i]).sum(dim=1).sum(dim=1).sum(dim=1) \/ (pred[:,i].pow(2).sum(dim=1).sum(dim=1).sum(dim=1) +\n                                                target[:,i].pow(2).sum(dim=1).sum(dim=1).sum(dim=1) + smooth)\n        # 返回的是dice距离\n        dice = dice \/ pred.size(1)\n        return torch.clamp((1 - dice).mean(), 0, 1)\n"}