{"BEFORE":"        ss = []\n        preds = []\n        pairs = []\n        for i in range(len(seq)):\n            param_on_cpu = { k: v.to(\"cpu\") for k, v in param[i].items() }\n            with torch.no_grad():\n                v, pred, pair = interface.predict_nussinov(seq[i], self.clear_count(param_on_cpu),\n                            constraint=constraint[i] if constraint is not None else '', \n                            reference=reference[i] if reference is not None else '', \n                            loss_pos_paired=loss_pos_paired, loss_neg_paired=loss_neg_paired,\n                            loss_pos_unpaired=loss_pos_unpaired, loss_neg_unpaired=loss_neg_unpaired)\n            s = 0\n            for n, p in param[i].items():\n                if n.startswith(\"score_\"):\n                    s += torch.sum(p * param_on_cpu[\"count_\"+n[6:]].to(p.device))\n            s += v - s.item()\n            ss.append(s)\n            preds.append(pred)\n            pairs.append(pair)\n        if verbose:\n            return torch.sum(torch.stack(ss)), preds, pairs\n        else:\n            return torch.sum(torch.stack(ss))\n\n\n    def predict(self, seq, param, constraint=None, reference=None,\n","AFTER":"        ss = []\n        preds = []\n        pairs = []\n        for i in range(len(seq)):\n            param_on_cpu = { k: v.to(\"cpu\") for k, v in param[i].items() }\n            with torch.no_grad():\n                v, pred, pair = interface.predict_nussinov(seq[i], self.clear_count(param_on_cpu),\n                            constraint=constraint[i] if constraint is not None else '', \n                            reference=reference[i] if reference is not None else '', \n                            loss_pos_paired=loss_pos_paired, loss_neg_paired=loss_neg_paired,\n                            loss_pos_unpaired=loss_pos_unpaired, loss_neg_unpaired=loss_neg_unpaired)\n            if torch.is_grad_enabled():\n                s = 0\n                for n, p in param[i].items():\n                    if n.startswith(\"score_\"):\n                        s += torch.sum(p * param_on_cpu[\"count_\"+n[6:]].to(p.device))\n                s += v - s.item()\n                ss.append(s)\n            else:\n                ss.append(v)\n            if verbose:\n                preds.append(pred)\n                pairs.append(pair)\n\n        ss = torch.stack(ss) if torch.is_grad_enabled() else ss\n        if verbose:\n            return ss, preds, pairs\n        else:\n            return ss\n\n\nclass NussinovFold(nn.Module):\n"}