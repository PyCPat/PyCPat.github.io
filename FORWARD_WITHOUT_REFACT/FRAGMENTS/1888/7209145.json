{"BEFORE":"            with torch.no_grad():\n                x = self.conv1(x)\n                x = self.bn1(x)\n                x = self.activation(x)\n                x = self.bottlenecks(x)\n                x = self.conv_last(x)\n                x = self.bn_last(x)\n                x = self.activation(x)\n                # average pooling layer\n                x = self.avgpool(x)\n                x = self.dropout(x)\n                # flatten for input to fully-connected layer\n                e = x.view(x.size(0), -1)\n        else:\n            x = self.conv1(x)\n            x = self.bn1(x)\n            x = self.activation(x)\n            x = self.bottlenecks(x)\n            x = self.conv_last(x)\n            x = self.bn_last(x)\n            x = self.activation(x)\n            # average pooling layer\n            x = self.avgpool(x)\n            x = self.dropout(x)\n            # flatten for input to fully-connected layer\n            e = x.view(x.size(0), -1)\n","AFTER":"            with torch.no_grad():\n                # first conv layer\n                x = F.relu6(self.bn0(self.conv0(inputs)), inplace=True)\n                # assert x.shape[1:] == torch.Size([32, 32, 32])\n                # bottlenecks\n                x = self.bottlenecks(x)\n                # assert x.shape[1:] == torch.Size([320, 8, 8])\n                # last conv layer\n                x = F.relu6(self.bn1(self.conv1(x)), inplace=True)\n                # assert x.shape[1:] == torch.Size([1280,8,8])\n                # global pooling and fc (in place of conv 1x1 in paper)\n                x = F.adaptive_avg_pool2d(x, 1)\n                e = x.view(x.shape[0], -1)\n        else:\n            # first conv layer\n            x = F.relu6(self.bn0(self.conv0(inputs)), inplace=True)\n            # assert x.shape[1:] == torch.Size([32, 32, 32])\n            # bottlenecks\n            x = self.bottlenecks(x)\n            # assert x.shape[1:] == torch.Size([320, 8, 8])\n            # last conv layer\n            x = F.relu6(self.bn1(self.conv1(x)), inplace=True)\n            # assert x.shape[1:] == torch.Size([1280,8,8])\n            # global pooling and fc (in place of conv 1x1 in paper)\n            x = F.adaptive_avg_pool2d(x, 1)\n            e = x.view(x.shape[0], -1)\n"}