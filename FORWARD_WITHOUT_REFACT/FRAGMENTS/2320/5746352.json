{"BEFORE":"        conv = []\n        pool = []\n        for n_out, ksize, p in zip(num_filters, filter_size, pool_size):\n            conv.append(nn.Conv1d(n_in, n_out, kernel_size=ksize, dilation=2**dilation, padding=2**dilation*(ksize\/\/2)))\n            if p > 1:\n                pool.append(nn.MaxPool1d(p, stride=1, padding=p\/\/2))\n            else:\n                pool.append(nn.Identity())\n            n_in = n_out\n        self.conv = nn.ModuleList(conv)\n        self.pool = nn.ModuleList(pool)\n        self.dropout = nn.Dropout(p=dropout_rate)\n","AFTER":"        l = []\n        for n_out, ksize, p in zip(num_filters, filter_size, pool_size):\n            l += [ \n                nn.Conv1d(n_in, n_out, kernel_size=ksize, dilation=2**dilation, padding=2**dilation*(ksize\/\/2)),\n                nn.MaxPool1d(p, stride=1, padding=p\/\/2) if p > 1 else nn.Identity(),\n                nn.GroupNorm(1, n_out), # same as LayerNorm?\n                nn.ELU(), \n                nn.Dropout(p=dropout_rate) ]\n            n_in = n_out\n        self.net = nn.Sequential(*l)\n"}