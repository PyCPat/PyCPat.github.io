{"BEFORE":"        embbedings = l2_norm(embbedings, axis=1)\n        kernel_norm = l2_norm(self.kernel, axis=0)\n        cos_theta = torch.mm(embbedings, kernel_norm).clamp(\n            -1, 1\n        )  # for numerical stability\n        with torch.no_grad():\n            origin_cos = cos_theta.clone()\n        target_logit = cos_theta[torch.arange(0, embbedings.size(0)), label].view(-1, 1)\n\n        sin_theta = torch.sqrt(1.0 - torch.pow(target_logit, 2))\n        cos_theta_m = (\n            target_logit * self.cos_m - sin_theta * self.sin_m\n        )  # cos(target+margin)\n\n        if cfg[\"USE_AMP\"] == True and cfg[\"OPT_LEVEL\"] == \"O1\":\n            target_logit = target_logit.float()\n        final_target_logit = torch.where(\n            target_logit > self.th, cos_theta_m, target_logit - self.mm\n        )\n        if cfg[\"USE_AMP\"] == True and cfg[\"OPT_LEVEL\"] == \"O1\":\n            final_target_logit = final_target_logit.half()\n        cos_theta.scatter_(1, label.view(-1, 1).long(), final_target_logit)\n        output = cos_theta * self.s\n","AFTER":"        embbedings = F.normalize(embbedings, dim=1)\n        kernel_norm = F.normalize(self.weight, dim=0)\n        cos_theta = torch.mm(embbedings, kernel_norm).clamp(-1, 1)\n        sin_theta = torch.sqrt(1.0 - torch.pow(cos_theta, 2))\n        cos_theta_m = cos_theta * self.cos_margin - sin_theta * self.sin_margin\n\n        # torch.where doesn't support fp16 input\n        is_half = cos_theta.dtype == torch.float16\n\n        cos_theta_m = torch.where(\n            cos_theta > self.min_cos_theta, cos_theta_m, cos_theta.float() - self.m_am,\n        )\n        if is_half:\n            cos_theta_m = cos_theta_m.half()\n        index = torch.zeros_like(cos_theta)\n        index.scatter_(1, label.data.view(-1, 1), 1)\n        index = index.byte().bool()\n        output = cos_theta * 1.0\n        output[index] = cos_theta_m[index]\n        output *= self.s\n"}