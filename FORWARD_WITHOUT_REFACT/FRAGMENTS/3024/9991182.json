{"BEFORE":"        classes_queries_boxes = [torch.split(batch_boxes, 27 * 3, dim=0) for batch_boxes in torch.unbind(outputs[\"pred_boxes\"], dim=0)]\n        classes_queries_probs = [[logits.softmax(-1) for logits in torch.split(batch_logits, 27 * 3, dim=0)] for batch_logits in torch.unbind(outputs[\"pred_logits\"], dim=0)]\n        assert len(classes_queries_probs[0]) == 20 and len(classes_queries_boxes[0]) == 20\n\n        # Get targets\n        tgt_ids = [v[\"labels\"] for v in targets]\n        tgt_boxes = [v[\"boxes\"] for v in targets]\n\n        matches = []\n        for batch in range(bs):\n            batch_matches = []\n            batch_tgt_ids = tgt_ids[batch]\n            batch_tgt_boxes = tgt_boxes[batch]\n\n            batch_queries_probs = classes_queries_probs[batch]\n            batch_queries_boxes = classes_queries_boxes[batch]\n\n            for tgt_id, tgt_box in zip(batch_tgt_ids, batch_tgt_boxes):\n                class_queries_boxes = batch_queries_boxes[tgt_id]\n                class_queries_probs = batch_queries_probs[tgt_id]\n\n                # Determine individual costs\n                cost_class = -class_queries_probs[:, tgt_id]\n","AFTER":"    def forward(self, outputs, targets, anchors):\n        \"\"\" Performs the matching\n        Params:\n            outputs: This is a dict that contains at least these entries:\n                 \"pred_logits\": Tensor of dim [batch_size, num_queries, num_classes] with the classification logits\n                 \"pred_boxes\": Tensor of dim [batch_size, num_queries, 6] with the predicted box coordinates\n            targets: This is a list of targets (len(targets) = batch_size), where each target is a dict containing:\n                 \"labels\": Tensor of dim [num_target_boxes] (where num_target_boxes is the number of ground-truth\n                           objects in the target) containing the class labels\n                 \"boxes\": Tensor of dim [num_target_boxes, 4] containing the target box coordinates\n        Returns:\n            A list of size batch_size, containing tuples of (index_i, index_j) where:\n                - index_i is the indices of the selected predictions (in order)\n                - index_j is the indices of the corresponding selected targets (in order)\n            For each batch element, it holds:\n                len(index_i) = len(index_j) = min(num_queries, num_target_boxes)\n        \"\"\"\n        bs = outputs[\"pred_logits\"].shape[0]\n\n        # Split queries in individual classes   TODO: don't hardcode any information\n        if self.anchor_matching:\n            classes_queries_boxes = [torch.split(anchors, 27 * 3, dim=0) for _ in range(bs)]\n        else:\n            classes_queries_boxes = [torch.split(batch_boxes, 27 * 3, dim=0) for batch_boxes in torch.unbind(outputs[\"pred_boxes\"], dim=0)]\n\n        classes_queries_probs = [[logits.softmax(-1) for logits in torch.split(batch_logits, 27 * 3, dim=0)] for batch_logits in torch.unbind(outputs[\"pred_logits\"], dim=0)]\n        assert len(classes_queries_probs[0]) == 20 and len(classes_queries_boxes[0]) == 20\n\n        # Get targets\n        tgt_ids = [v[\"labels\"] for v in targets]\n        tgt_boxes = [v[\"boxes\"] for v in targets]\n\n        matches = []\n        for batch in range(bs):\n            batch_matches = []\n            batch_tgt_ids = tgt_ids[batch]\n            batch_tgt_boxes = tgt_boxes[batch]\n\n            batch_queries_probs = classes_queries_probs[batch]\n            batch_queries_boxes = classes_queries_boxes[batch]\n\n            for tgt_id, tgt_box in zip(batch_tgt_ids, batch_tgt_boxes):\n                tgt_id = tgt_id - 1  # Since class 0 has id 1\n                class_queries_boxes = batch_queries_boxes[tgt_id]\n                class_queries_probs = batch_queries_probs[tgt_id]\n\n                # Determine individual costs\n                cost_class = -class_queries_probs[:, -1]\n"}