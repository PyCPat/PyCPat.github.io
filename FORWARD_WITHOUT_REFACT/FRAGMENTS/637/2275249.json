{"BEFORE":"        if self.mean is not None and self.std is not None:\n            target = target * self.std + self.mean\n\n        # reshape target to patches\n        p = self.patch_size\n        target = rearrange(target,\n                           \"b c (h p1) (w p2) -> b (h w) c (p1 p2) \",\n                           p1=p,\n                           p2=p)\n\n        avg_target = target.mean(dim=3)\n\n        bin_size = self.max_pixel_val \/ self.output_channel_bits\n        channel_bins = torch.arange(bin_size, self.max_pixel_val, bin_size).to(avg_target.device)\n        discretized_target = torch.bucketize(avg_target, channel_bins)\n        discretized_target = F.one_hot(discretized_target,\n                                       self.output_channel_bits)\n        c, bi = self.channels, self.output_channel_bits\n        discretized_target = rearrange(discretized_target,\n                                       \"b n c bi -> b n (c bi)\",\n                                       c=c,\n                                       bi=bi)\n\n        bin_mask = 2**torch.arange(c * bi - 1, -1,\n                                   -1).to(discretized_target.device,\n                                          discretized_target.dtype)\n        target_label = torch.sum(bin_mask * discretized_target, -1)\n        predicted_patches = predicted_patches[mask]\n        target_label = target_label[mask]\n        loss = F.cross_entropy(predicted_patches, target_label)\n","AFTER":"        p, c, mpv, bits, device = self.patch_size, self.channels, self.max_pixel_val, self.output_channel_bits, target.device\n        bin_size = mpv \/ (2 ** bits)\n\n        # un-normalize input\n        if exists(self.mean) and exists(self.std):\n            target = target * self.std + self.mean\n\n        # reshape target to patches\n        target = target.clamp(max = mpv) # clamp just in case\n        avg_target = reduce(target, 'b c (h p1) (w p2) -> b (h w) c', 'mean', p1 = p, p2 = p).contiguous()\n\n        channel_bins = torch.arange(bin_size, mpv, bin_size, device = device)\n        discretized_target = torch.bucketize(avg_target, channel_bins)\n\n        bin_mask = (2 ** bits) ** torch.arange(0, c, device = device).long()\n        bin_mask = rearrange(bin_mask, 'c -> () () c')\n\n        target_label = torch.sum(bin_mask * discretized_target, dim = -1)\n\n        loss = F.cross_entropy(predicted_patches[mask], target_label[mask])\n"}