{"BEFORE":"        src_len = k.size(1)\n\n        # This is part of a workaround to get around fork\/join parallelism\n        # not supporting Optional types.\n        if key_padding_mask is not None and key_padding_mask.shape == torch.Size([]):\n            key_padding_mask = None\n\n        if key_padding_mask is not None:\n            assert key_padding_mask.size(0) == bsz\n            assert key_padding_mask.size(1) == src_len\n\n        if self.add_zero_attn:\n            src_len += 1\n            k = torch.cat([k, k.new_zeros((k.size(0), 1) + k.size()[2:])], dim=1)\n            v = torch.cat([v, v.new_zeros((v.size(0), 1) + v.size()[2:])], dim=1)\n            if attn_mask is not None:\n                attn_mask = torch.cat([attn_mask, attn_mask.new_zeros(attn_mask.size(0), 1)], dim=1)\n            if key_padding_mask is not None:\n                key_padding_mask = torch.cat(\n                    [key_padding_mask, torch.zeros(key_padding_mask.size(0), 1).type_as(key_padding_mask)], dim=1)\n\n        attn_weights = torch.bmm(q, k.transpose(1, 2))\n        attn_weights = self.apply_sparse_mask(attn_weights, tgt_len, src_len, bsz)\n\n        assert list(attn_weights.size()) == [bsz * self.num_heads, tgt_len, src_len]\n\n        if attn_mask is not None:\n            attn_mask = attn_mask.unsqueeze(0)\n            if self.onnx_trace:\n                attn_mask = attn_mask.repeat(attn_weights.size(0), 1, 1)\n            attn_weights += attn_mask\n\n        if key_padding_mask is not None:\n            # don't attend to padding symbols\n            attn_weights = attn_weights.view(bsz, self.num_heads, tgt_len, src_len)\n            if self.onnx_trace:\n                attn_weights = torch.where(\n                    key_padding_mask.unsqueeze(1).unsqueeze(2),\n                    torch.Tensor([float(\"-Inf\")]),\n                    attn_weights.float()\n                ).type_as(attn_weights)\n            else:\n                attn_weights = attn_weights.masked_fill(\n                    key_padding_mask.unsqueeze(1).unsqueeze(2),\n                    float('-inf'),\n                )\n            attn_weights = attn_weights.view(bsz * self.num_heads, tgt_len, src_len)\n\n        if before_softmax:\n            return attn_weights, v\n\n        attn_weights = utils.softmax(\n            attn_weights, dim=-1, onnx_trace=self.onnx_trace,\n        ).type_as(attn_weights)\n        attn_weights = F.dropout(attn_weights, p=self.dropout, training=self.training)\n\n        attn = torch.bmm(attn_weights, v)\n        assert list(attn.size()) == [bsz * self.num_heads, tgt_len, self.head_dim]\n        if (self.onnx_trace and attn.size(1) == 1):\n            # when ONNX tracing a single decoder step (sequence length == 1)\n            # the transpose is a no-op copy before view, thus unnecessary\n            attn = attn.contiguous().view(tgt_len, bsz, embed_dim)\n        else:\n            attn = attn.transpose(0, 1).contiguous().view(tgt_len, bsz, embed_dim)\n        attn = self.out_proj(attn)\n\n        if need_weights:\n            # average attention weights over heads\n            attn_weights = attn_weights.view(bsz, self.num_heads, tgt_len, src_len)\n            attn_weights = attn_weights.sum(dim=1) \/ self.num_heads\n","AFTER":"        need_head_weights=False,\n    ):\n        \"\"\"Input shape: Time x Batch x Channel\n\n        Args:\n            key_padding_mask (ByteTensor, optional): mask to exclude\n                keys that are pads, of shape `(batch, src_len)`, where\n                padding elements are indicated by 1s.\n            need_weights (bool, optional): return the attention weights,\n                averaged over heads (default: False).\n            attn_mask (ByteTensor, optional): typically used to\n                implement causal attention, where the mask prevents the\n                attention from looking forward in time (default: None).\n            before_softmax (bool, optional): return the raw attention\n                weights and values before the attention softmax.\n            need_head_weights (bool, optional): return the attention\n                weights for each head. Implies *need_weights*. Default:\n                return the average attention weights over all heads.\n        \"\"\"\n        if need_head_weights:\n            need_weights = True\n\n        tgt_len, bsz, embed_dim = query.size()\n        assert embed_dim == self.embed_dim\n        assert list(query.size()) == [tgt_len, bsz, embed_dim]\n\n        if self.enable_torch_version and not self.onnx_trace and incremental_state is None and not static_kv:\n            if self.qkv_same_dim:\n                return F.multi_head_attention_forward(query, key, value,\n                                                      self.embed_dim, self.num_heads,\n                                                      self.in_proj_weight,\n                                                      self.in_proj_bias, self.bias_k, self.bias_v,\n                                                      self.add_zero_attn, self.dropout,\n                                                      self.out_proj.weight, self.out_proj.bias,\n                                                      self.training, key_padding_mask, need_weights,\n                                                      attn_mask)\n            else:\n                return F.multi_head_attention_forward(query, key, value,\n                                                      self.embed_dim, self.num_heads,\n                                                      torch.empty([0]),\n                                                      self.in_proj_bias, self.bias_k, self.bias_v,\n                                                      self.add_zero_attn, self.dropout,\n                                                      self.out_proj.weight, self.out_proj.bias,\n                                                      self.training, key_padding_mask, need_weights,\n                                                      attn_mask, use_separate_proj_weight=True,\n                                                      q_proj_weight=self.q_proj_weight,\n                                                      k_proj_weight=self.k_proj_weight,\n                                                      v_proj_weight=self.v_proj_weight)\n\n        if incremental_state is not None:\n            saved_state = self._get_input_buffer(incremental_state)\n            if 'prev_key' in saved_state:\n                # previous time steps are cached - no need to recompute\n                # key and value if they are static\n                if static_kv:\n                    assert self.encoder_decoder_attention and not self.self_attention\n                    key = value = None\n        else:\n            saved_state = None\n\n        if self.self_attention:\n            # self-attention\n            q, k, v = self.in_proj_qkv(query)\n        elif self.encoder_decoder_attention:\n            # encoder-decoder attention\n            q = self.in_proj_q(query)\n            if key is None:\n                assert value is None\n                k = v = None\n            else:\n                k = self.in_proj_k(key)\n                v = self.in_proj_v(key)\n\n        else:\n            q = self.in_proj_q(query)\n            k = self.in_proj_k(key)\n            v = self.in_proj_v(value)\n        q *= self.scaling\n\n        if self.bias_k is not None:\n            assert self.bias_v is not None\n            k = torch.cat([k, self.bias_k.repeat(1, bsz, 1)])\n            v = torch.cat([v, self.bias_v.repeat(1, bsz, 1)])\n            if attn_mask is not None:\n                attn_mask = torch.cat([attn_mask, attn_mask.new_zeros(attn_mask.size(0), 1)], dim=1)\n            if key_padding_mask is not None:\n                key_padding_mask = torch.cat(\n                    [key_padding_mask, key_padding_mask.new_zeros(key_padding_mask.size(0), 1)], dim=1)\n\n        q = q.contiguous().view(tgt_len, bsz * self.num_heads, self.head_dim).transpose(0, 1)\n        if k is not None:\n            k = k.contiguous().view(-1, bsz * self.num_heads, self.head_dim).transpose(0, 1)\n        if v is not None:\n            v = v.contiguous().view(-1, bsz * self.num_heads, self.head_dim).transpose(0, 1)\n\n        if saved_state is not None:\n            # saved states are stored with shape (bsz, num_heads, seq_len, head_dim)\n            if 'prev_key' in saved_state:\n                prev_key = saved_state['prev_key'].view(bsz * self.num_heads, -1, self.head_dim)\n                if static_kv:\n                    k = prev_key\n                else:\n                    k = torch.cat((prev_key, k), dim=1)\n            if 'prev_value' in saved_state:\n                prev_value = saved_state['prev_value'].view(bsz * self.num_heads, -1, self.head_dim)\n                if static_kv:\n                    v = prev_value\n                else:\n                    v = torch.cat((prev_value, v), dim=1)\n            if 'prev_key_padding_mask' in saved_state and saved_state['prev_key_padding_mask'] is not None:\n                prev_key_padding_mask = saved_state['prev_key_padding_mask']\n                if static_kv:\n                    key_padding_mask = prev_key_padding_mask\n                else:\n                    key_padding_mask = torch.cat((prev_key_padding_mask, key_padding_mask), dim=1)\n            saved_state['prev_key'] = k.view(bsz, self.num_heads, -1, self.head_dim)\n            saved_state['prev_value'] = v.view(bsz, self.num_heads, -1, self.head_dim)\n            saved_state['prev_key_padding_mask'] = key_padding_mask\n\n            self._set_input_buffer(incremental_state, saved_state)\n\n        src_len = k.size(1)\n\n        # This is part of a workaround to get around fork\/join parallelism\n        # not supporting Optional types.\n        if key_padding_mask is not None and key_padding_mask.shape == torch.Size([]):\n            key_padding_mask = None\n\n        if key_padding_mask is not None:\n            assert key_padding_mask.size(0) == bsz\n            assert key_padding_mask.size(1) == src_len\n\n        if self.add_zero_attn:\n            src_len += 1\n            k = torch.cat([k, k.new_zeros((k.size(0), 1) + k.size()[2:])], dim=1)\n            v = torch.cat([v, v.new_zeros((v.size(0), 1) + v.size()[2:])], dim=1)\n            if attn_mask is not None:\n                attn_mask = torch.cat([attn_mask, attn_mask.new_zeros(attn_mask.size(0), 1)], dim=1)\n            if key_padding_mask is not None:\n                key_padding_mask = torch.cat(\n                    [key_padding_mask, torch.zeros(key_padding_mask.size(0), 1).type_as(key_padding_mask)], dim=1)\n\n        attn_weights = torch.bmm(q, k.transpose(1, 2))\n        attn_weights = self.apply_sparse_mask(attn_weights, tgt_len, src_len, bsz)\n\n        assert list(attn_weights.size()) == [bsz * self.num_heads, tgt_len, src_len]\n\n        if attn_mask is not None:\n            attn_mask = attn_mask.unsqueeze(0)\n            if self.onnx_trace:\n                attn_mask = attn_mask.repeat(attn_weights.size(0), 1, 1)\n            attn_weights += attn_mask\n\n        if key_padding_mask is not None:\n            # don't attend to padding symbols\n            attn_weights = attn_weights.view(bsz, self.num_heads, tgt_len, src_len)\n            if self.onnx_trace:\n                attn_weights = torch.where(\n                    key_padding_mask.unsqueeze(1).unsqueeze(2),\n                    torch.Tensor([float(\"-Inf\")]),\n                    attn_weights.float()\n                ).type_as(attn_weights)\n            else:\n                attn_weights = attn_weights.masked_fill(\n                    key_padding_mask.unsqueeze(1).unsqueeze(2),\n                    float('-inf'),\n                )\n            attn_weights = attn_weights.view(bsz * self.num_heads, tgt_len, src_len)\n\n        if before_softmax:\n            return attn_weights, v\n\n        attn_weights_float = utils.softmax(attn_weights, dim=-1, onnx_trace=self.onnx_trace)\n        attn_weights = attn_weights_float.type_as(attn_weights)\n        attn_probs = F.dropout(attn_weights_float.type_as(attn_weights), p=self.dropout, training=self.training)\n\n        attn = torch.bmm(attn_probs, v)\n        assert list(attn.size()) == [bsz * self.num_heads, tgt_len, self.head_dim]\n        if (self.onnx_trace and attn.size(1) == 1):\n            # when ONNX tracing a single decoder step (sequence length == 1)\n            # the transpose is a no-op copy before view, thus unnecessary\n            attn = attn.contiguous().view(tgt_len, bsz, embed_dim)\n        else:\n            attn = attn.transpose(0, 1).contiguous().view(tgt_len, bsz, embed_dim)\n        attn = self.out_proj(attn)\n\n        if need_weights:\n            attn_weights = attn_weights_float.view(bsz, self.num_heads, tgt_len, src_len).transpose(1, 0)\n            if not need_head_weights:\n                # average attention weights over heads\n                attn_weights = attn_weights.mean(dim=0)\n        else:\n"}