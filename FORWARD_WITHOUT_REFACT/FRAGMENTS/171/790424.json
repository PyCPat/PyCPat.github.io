{"BEFORE":"        feat_in_repeat = torch.cat([feat_in.repeat(1, n, 1), tar_candidate.float()], dim=2)\n        # print(\"feat_in_repeat size: \", feat_in_repeat.size())\n\n        # compute probability for each candidate\n        tar_candit_prob = F.softmax(self.prob_mlp(feat_in_repeat), dim=1).squeeze(-1)  # [batch_size, n_tar, 1]\n","AFTER":"    def forward(self, feat_in: torch.Tensor, tar_candidate: torch.Tensor, candidate_mask=None):\n        \"\"\"\n        predict the target end position of the target agent from the target candidates\n        :param feat_in: the encoded trajectory features, [batch_size, inchannels]\n        :param tar_candidate: the target position candidate (x, y), [batch_size, N, 2]\n        :return:\n        \"\"\"\n        # dimension must be [batch size, 1, in_channels]\n        assert feat_in.dim() == 2, \"[TNT-TargetPred]: Error input feature dimension\"\n\n        feat_in = feat_in.unsqueeze(1)\n        batch_size, n, _ = tar_candidate.size()\n        # print(\"tar_candidate size: {}\".format(tar_candidate.size()))\n\n        # stack the target candidates to the end of input feature\n        feat_in_repeat = torch.cat([feat_in.repeat(1, n, 1), tar_candidate.float()], dim=2)\n        # print(\"feat_in_repeat size: \", feat_in_repeat.size())\n\n        # compute probability for each candidate\n        prob_tensor = self.prob_mlp(feat_in_repeat)\n        if not isinstance(candidate_mask, torch.Tensor):\n            tar_candit_prob = F.softmax(prob_tensor, dim=1).squeeze(-1)                         # [batch_size, n_tar, 1]\n        else:\n            tar_candit_prob = masked_softmax(prob_tensor, candidate_mask, dim=1).squeeze(-1)    # [batch_size, n_tar, 1]\n        tar_offset_mean = self.mean_mlp(feat_in_repeat)                                         # [batch_size, n_tar, 2]\n"}