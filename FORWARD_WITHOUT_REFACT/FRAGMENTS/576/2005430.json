{"BEFORE":"        out_dim = default(out_dim, 3)\n","AFTER":"        self.channels = channels\n\n        dims = [channels, *map(lambda m: dim * m, dim_mults)]\n        in_out = list(zip(dims[:-1], dims[1:]))\n\n        self.time_pos_emb = SinusoidalPosEmb(dim)\n        self.mlp = nn.Sequential(\n            nn.Linear(dim, dim * 4),\n            Mish(),\n            nn.Linear(dim * 4, dim)\n        )\n\n        self.downs = nn.ModuleList([])\n        self.ups = nn.ModuleList([])\n        num_resolutions = len(in_out)\n\n        for ind, (dim_in, dim_out) in enumerate(in_out):\n            is_last = ind >= (num_resolutions - 1)\n\n            self.downs.append(nn.ModuleList([\n                ResnetBlock(dim_in, dim_out, time_emb_dim = dim),\n                ResnetBlock(dim_out, dim_out, time_emb_dim = dim),\n                Residual(Rezero(LinearAttention(dim_out))),\n                Downsample(dim_out) if not is_last else nn.Identity()\n            ]))\n\n        mid_dim = dims[-1]\n        self.mid_block1 = ResnetBlock(mid_dim, mid_dim, time_emb_dim = dim)\n        self.mid_attn = Residual(Rezero(LinearAttention(mid_dim)))\n        self.mid_block2 = ResnetBlock(mid_dim, mid_dim, time_emb_dim = dim)\n\n        for ind, (dim_in, dim_out) in enumerate(reversed(in_out[1:])):\n            is_last = ind >= (num_resolutions - 1)\n\n            self.ups.append(nn.ModuleList([\n                ResnetBlock(dim_out * 2, dim_in, time_emb_dim = dim),\n                ResnetBlock(dim_in, dim_in, time_emb_dim = dim),\n                Residual(Rezero(LinearAttention(dim_in))),\n                Upsample(dim_in) if not is_last else nn.Identity()\n            ]))\n\n        out_dim = default(out_dim, channels)\n"}