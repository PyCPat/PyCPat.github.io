{"BEFORE":"        dists = cdist(anchor, positive, metric='euclidean')\n        # build false negative \n        false_negative = dist_keypts < self.safe_radius\n\n        pos_mask = torch.eq(torch.unsqueeze(pids, dim=1), torch.unsqueeze(pids, dim=0))\n        neg_mask = torch.logical_not(pos_mask | false_negative)\n\n        # dists * pos_mask get the distance of each valid anchor-positive pair.\n        furthest_positive, _ = torch.max(dists * pos_mask.float(), dim=1)\n        # here we use \"dists +  10000*pos_mask\" to avoid the anchor-positive pair been selected.\n        closest_negative, _ = torch.min(dists + 1e5 * pos_mask.float(), dim=1)\n        # closest_negative_row, _ = torch.min(dists + 1e5 * pos_mask.float(), dim=0)\n        # closest_negative = torch.min(closest_negative_col, closest_negative_row)\n        average_negative = (torch.sum(dists, dim=-1) - furthest_positive) \/ (dists.shape[0] - 1)\n        diff = furthest_positive - closest_negative\n        accuracy = (diff < 0).sum() * 100.0 \/ diff.shape[0]\n\n        pos = dists - 1e5 * neg_mask.float()\n        pos_weight = (pos - self.pos_optimal).detach()\n        pos_weight = torch.max(torch.zeros_like(pos_weight), pos_weight)\n        lse_positive = torch.logsumexp(self.log_scale * (pos - self.pos_margin) * pos_weight, dim=-1)\n\n        \n        neg = dists + 1e5 * (~neg_mask).float()\n        neg_weight =  (self.neg_optimal - neg).detach()\n        neg_weight = torch.max(torch.zeros_like(neg_weight), neg_weight)\n        lse_negative_row = torch.logsumexp(self.log_scale * (self.neg_margin - neg) * neg_weight, dim=-1)\n        lse_negative_col = torch.logsumexp(self.log_scale * (self.neg_margin - neg) * neg_weight, dim=-2)\n\n        loss_col = F.softplus(lse_positive + lse_negative_row) \/ self.log_scale\n        loss_row = F.softplus(lse_positive + lse_negative_col) \/ self.log_scale\n","AFTER":"        dists = cdist(anchor, positive, metric=self.dist_type)\n\n        pids = torch.FloatTensor(np.arange(len(anchor))).to(anchor.device)\n        pos_mask = torch.eq(torch.unsqueeze(pids, dim=1), torch.unsqueeze(pids, dim=0))\n        neg_mask = dist_keypts > self.safe_radius\n\n\n        furthest_positive, _ = torch.max(dists * pos_mask.float(), dim=1)\n        closest_negative, _ = torch.min(dists + 1e5 * pos_mask.float(), dim=1)\n        average_negative = (torch.sum(dists, dim=-1) - furthest_positive) \/ (dists.shape[0] - 1)\n        diff = furthest_positive - closest_negative\n        accuracy = (diff < 0).sum() * 100.0 \/ diff.shape[0]\n\n        pos = dists - 1e5 * neg_mask.float()\n        pos_weight = (pos - self.pos_optimal).detach()\n        pos_weight = torch.max(torch.zeros_like(pos_weight), pos_weight)\n        lse_positive_row = torch.logsumexp(self.log_scale * (pos - self.pos_margin) * pos_weight, dim=-1)\n        lse_positive_col = torch.logsumexp(self.log_scale * (pos - self.pos_margin) * pos_weight, dim=-2)\n\n        neg = dists + 1e5 * (~neg_mask).float()\n        neg_weight =  (self.neg_optimal - neg).detach()\n        neg_weight = torch.max(torch.zeros_like(neg_weight), neg_weight)\n        lse_negative_row = torch.logsumexp(self.log_scale * (self.neg_margin - neg) * neg_weight, dim=-1)\n        lse_negative_col = torch.logsumexp(self.log_scale * (self.neg_margin - neg) * neg_weight, dim=-2)\n\n        loss_col = F.softplus(lse_positive_row + lse_negative_row) \/ self.log_scale\n        loss_row = F.softplus(lse_positive_col + lse_negative_col) \/ self.log_scale\n"}