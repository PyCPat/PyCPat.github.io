{"BEFORE":"        t = t.unsqueeze(0).unsqueeze(1) #[1, 1, T]\n        c = c.unsqueeze(2)\n\n        # print(range_param, 0.1*(range_param ** 2))\n\n        # w_1 = torch.exp(-0.1*(range_param.unsqueeze(-1) ** -2) * (t - c) ** 2)  # [B, L, T]\n        # w_2 = torch.sum(torch.exp(-0.1*(range_param.unsqueeze(-1) ** -2) * (t - c) ** 2), dim=1, keepdim=True)  # [B, 1, T]\n        w_1 = torch.exp(-0.1 * (t - c) ** 2)  # [B, L, T]\n        w_2 = torch.sum(torch.exp(-0.1 * (t - c) ** 2), dim=1, keepdim=True)  # [B, 1, T]\n        w_2[w_2==0.] = 1.\n\n        # w_1 = self.normpdf(t, c, range_param.unsqueeze(-1))  # [B, L, T]\n        # w_1 = torch.distributions.normal.Normal(c, 0.1).log_prob(t)  # [B, L, T]\n        # w_2 = torch.sum(w_1, dim=1, keepdim=True)  # [B, 1, T]\n        # w_2[w_2==0.] = 1.\n\n        w = w_1 \/ w_2\n\n        out = torch.matmul(w.transpose(1, 2), encoder_outputs)\n\n        return out, w\n","AFTER":"        t = t.unsqueeze(0).unsqueeze(1) #[1, 1, T]\n        c = c.unsqueeze(2)\n        s = self.range_param_predictor(encoder_outputs, duration, mask).unsqueeze(-1)\n\n        g = torch.distributions.normal.Normal(loc=c, scale=s)\n\n        w = self.get_alignment_energies(g, t)  # [B, L, T]\n\n        if mask is not None:\n            w = w.masked_fill(mask.unsqueeze(-1), 0.0)\n\n        attn = w \/ (torch.sum(w, dim=1).unsqueeze(1) + 1e-8)  # [B, L, T]\n        out = torch.bmm(attn.transpose(1, 2), encoder_outputs)\n\n        return out, attn\n"}