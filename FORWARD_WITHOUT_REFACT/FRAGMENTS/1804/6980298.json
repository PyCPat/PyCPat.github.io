{"BEFORE":"        trans_loss_s, domain_acc_s = self._single_domain_forward(g_s, f_s, domain=1)\n        trans_loss_t, domain_acc_t = self._single_domain_forward(g_t, f_t, domain=0)\n        self.grl.step()\n        self.domain_discriminator_accuracy = 0.5 * (domain_acc_s + domain_acc_t)\n        return 0.5 * (trans_loss_s + trans_loss_t)\n","AFTER":"        f = torch.cat((f_s, f_t), dim=0)\n        g = torch.cat((g_s, g_t), dim=0)\n        g = F.softmax(g,dim=1).detach()\n        h = self.grl(self.map(f, g))\n        d = self.domain_discriminator(h)\n        d_label = torch.cat((\n            torch.ones((g_s.size(0), 1)).to(g_s.device),\n            torch.zeros((g_t.size(0), 1)).to(g_t.device),\n        ))\n        weight = 1.0 + torch.exp(-entropy(g))\n        batch_size = f.size(0)\n        weight = weight \/ torch.sum(weight) * batch_size\n        self.domain_discriminator_accuracy = binary_accuracy(d, d_label)\n        return self.bce(d, d_label, weight.view_as(d))\n"}