{"BEFORE":"    batch_size = anchor_output.shape[0]\n    targets_sketch = torch.zeros(batch_size)\n    targets_photos = torch.zeros(batch_size)\n\n    if epoch < 5:\n      lmbda = 0\n    elif epoch < 25:\n      lmbda = (epoch-5)\/20.0\n    else:\n      lmbda = 1.0\n\n\n    loss_domain = self.domain_loss(grad_reverse(anchor_output, lmbda), targets_sketch) + self.domain_loss(grad_reverse(positive_output, lmbda), targets_photos) + self.domain_loss(grad_reverse(negative_output, lmbda), targets_photos)\n    loss_domain \/= 3.0\n\n\n    total_loss = self.w_dom * loss_domain + self.w_sem * loss_semantic + self.w_triplet * loss_triplet # Our network minimizes this loss\n\n    return total_loss\n","AFTER":"    loss_semantic = loss_semantic.mean()\n\n    loss_triplet = self.triplet_loss(anchor_output, positive_output, negative_output)\n\n    # Create targets for the domain loss(adversarial for the main model - as imposed by the GRL after every output)\n    device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')\n    batch_size = anchor_output.shape[0]\n    targets_sketch = torch.zeros(batch_size)\n    targets_photos = torch.ones(batch_size)\n\n    if epoch < 5:\n      lmbda = 0\n    elif epoch < 25:\n      lmbda = (epoch-5)\/20.0\n    else:\n      lmbda = 1.0\n\n\n    loss_domain = self.domain_loss(grad_reverse(anchor_output, lmbda), targets_sketch) + self.domain_loss(grad_reverse(positive_output, lmbda), targets_photos) + self.domain_loss(grad_reverse(negative_output, lmbda), targets_photos)\n    loss_domain \/= 3.0\n\n\n    total_loss = self.w_dom * loss_domain + self.w_sem * loss_semantic + self.w_triplet * loss_triplet # Our network minimizes this loss\n\n    return total_loss, loss_domain, loss_triplet, loss_semantic\n"}