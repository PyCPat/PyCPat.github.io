{"BEFORE":"        latents = repeat(self.latents, 'n d -> b n d', b = batch)\n\n        # the warm starting of latents as in the paper\n\n        if exists(latent_self_cond):\n            latents = latents + self.init_self_cond_latents(latent_self_cond)\n\n        # to patches\n\n        patches = self.to_patches(x)\n\n        pos_emb_h, pos_emb_w = self.axial_pos_emb\n        pos_emb = rearrange(pos_emb_h, 'i d -> i 1 d') + rearrange(pos_emb_w, 'j d -> 1 j d')\n        patches = patches + rearrange(pos_emb, 'i j d -> (i j) d')\n\n        # the recurrent interface network body\n\n        for _ in range(self.depth):\n            patches = self.patches_peg(patches) + patches\n\n            # latents extract or cluster information from the patches\n\n            latents = self.latents_attend_to_patches(latents, patches, time = t) + latents\n\n            # latent self attention\n\n            for attn, ff in self.latent_self_attns:\n                latents = attn(latents, time = t) + latents\n                latents = ff(latents, time = t) + latents\n\n            # additional patches self attention with linear attention\n\n            patches = self.patches_self_attn(patches, time = t) + patches\n            patches = self.patches_self_attn_ff(patches) + patches\n\n            # patches attend to the latents\n\n            patches = self.latents_attend_to_patches(patches, latents, time = t) + patches\n\n            patches = self.patches_cross_attn_ff(patches, time = t) + patches\n","AFTER":"        t = self.time_mlp(time)\n\n        # prepare latents\n\n        latents = repeat(self.latents, 'n d -> b n d', b = batch)\n\n        # the warm starting of latents as in the paper\n\n        if exists(latent_self_cond):\n            latents = latents + self.init_self_cond_latents(latent_self_cond)\n\n        # to patches\n\n        patches = self.to_patches(x)\n\n        pos_emb_h, pos_emb_w = self.axial_pos_emb\n        pos_emb = rearrange(pos_emb_h, 'i d -> i 1 d') + rearrange(pos_emb_w, 'j d -> 1 j d')\n        patches = patches + rearrange(pos_emb, 'i j d -> (i j) d')\n\n        # the recurrent interface network body\n\n        for block in self.blocks:\n            patches, latents = block(patches, latents, t)\n"}