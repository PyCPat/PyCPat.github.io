{"BEFORE":"            node_encodings = box_features[counter: counter+n]\n            # Duplicate human nodes\n            h_node_encodings = node_encodings[:n_h]\n            # Get the pairwise index between every human and object instance\n            x, y = torch.meshgrid(\n                torch.arange(n_h, device=device),\n                torch.arange(n, device=device)\n            )\n            # Remove pairs consisting of the same human instance\n            x_keep, y_keep = torch.nonzero(x != y).unbind(1)\n            if len(x_keep) == 0:\n                # Should never happen, just to be safe\n                continue\n            # Human nodes have been duplicated and will be treated independently\n            # of the humans included amongst object nodes\n            x = x.flatten(); y = y.flatten()\n\n            # Compute spatial features\n            box_pair_spatial = compute_spatial_encodings(\n                [coords[x]], [coords[y]], [image_shapes[b_idx]]\n            )\n            box_pair_spatial = self.spatial_head(box_pair_spatial)\n            # Reshape the spatial features\n            box_pair_spatial_reshaped = box_pair_spatial.reshape(n_h, n, -1)\n\n            adjacency_matrix = torch.ones(n_h, n, device=device)\n            for i in range(self.num_iter):\n                # Compute weights of each edge\n                weights = self.attention_head(\n                    torch.cat([\n                        h_node_encodings[x],\n                        node_encodings[y]\n                    ], 1),\n                    box_pair_spatial\n                )\n                adjacency_matrix = self.adjacency(weights).reshape(n_h, n)\n\n                # Update human nodes\n                messages_to_h = F.relu(torch.mm(\n                    adjacency_matrix.softmax(dim=1),\n                    self.obj_to_sub(node_encodings)\n                ))\n                h_node_encodings = self.norm_h(\n                    h_node_encodings + messages_to_h\n                )\n\n                # Update object nodes (including human nodes)\n                messages_to_o = F.relu(torch.mm(\n                    adjacency_matrix.t().softmax(dim=1),\n                    self.sub_to_obj(h_node_encodings)\n","AFTER":"            node_encodings = box_features[counter: counter+n]\n            # Duplicate human nodes\n            h_node_encodings = node_encodings[:n_h]\n            # Get the pairwise index between every human and object instance\n            x, y = torch.meshgrid(\n                torch.arange(n_h, device=device),\n                torch.arange(n, device=device)\n            )\n            # Remove pairs consisting of the same human instance\n            x_keep, y_keep = torch.nonzero(x != y).unbind(1)\n            if len(x_keep) == 0:\n                # Should never happen, just to be safe\n                continue\n            # Human nodes have been duplicated and will be treated independently\n            # of the humans included amongst object nodes\n            x = x.flatten(); y = y.flatten()\n\n            # Compute spatial features\n            box_pair_spatial = compute_spatial_encodings(\n                [coords[x]], [coords[y]], [image_shapes[b_idx]]\n            )\n            box_pair_spatial = self.spatial_head(box_pair_spatial)\n            # Reshape the spatial features\n            box_pair_spatial_reshaped = box_pair_spatial.reshape(n_h, n, -1)\n\n            adjacency_matrix = torch.ones(n_h, n, device=device)\n            for i in range(self.num_iter):\n                # Compute weights of each edge\n                weights = self.attention_head(\n                    torch.cat([\n                        h_node_encodings[x],\n                        node_encodings[y]\n                    ], 1),\n                    box_pair_spatial\n                )\n                adjacency_matrix = self.adjacency(weights).reshape(n_h, n)\n\n                # Update human nodes\n                messages_to_h = F.relu(torch.sum(\n                    adjacency_matrix.softmax(dim=1) *\n                    self.obj_to_sub(\n                        node_encodings,\n                        box_pair_spatial_reshaped\n                    ), dim=1)\n                )\n                h_node_encodings = self.norm_h(\n                    h_node_encodings + messages_to_h\n                )\n\n                # Update object nodes (including human nodes)\n                messages_to_o = F.relu(torch.sum(\n                    adjacency_matrix.t().softmax(dim=1) *\n                    self.sub_to_obj(\n                        h_node_encodings,\n                        box_pair_spatial_reshaped\n                    ), dim=1)\n"}