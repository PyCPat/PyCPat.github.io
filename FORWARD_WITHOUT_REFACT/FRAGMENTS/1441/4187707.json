{"BEFORE":"        recon_x = self.decoder(x)\n\n        # stft discr loss\n\n        if return_stft_discr_loss:\n            assert self.single_channel\n            real, fake = orig_x, recon_x.detach()\n            stft_real_logits, stft_fake_logits = map(self.stft_discriminator, (real, fake))\n            stft_discr_loss = (hinge_discr_loss(stft_fake_logits.real, stft_real_logits.real) + hinge_discr_loss(stft_fake_logits.imag, stft_real_logits.imag)) \/ 2\n            return stft_discr_loss\n\n        # multi-scale discriminator loss\n\n        if return_discr_loss:\n            real, fake = orig_x, recon_x.detach()\n            discr_losses = []\n\n            for discr, scale in zip(self.discriminators, self.discr_multi_scales):\n                scaled_real, scaled_fake = map(lambda t: F.interpolate(t, scale_factor = scale), (real, fake))\n\n                real_logits, fake_logits = map(discr, (scaled_real, scaled_fake))\n                one_discr_loss = hinge_discr_loss(fake_logits, real_logits)\n                discr_losses.append(one_discr_loss)\n\n            return torch.stack(discr_losses).mean()\n\n        # recon loss\n\n        recon_loss = F.mse_loss(orig_x, recon_x)\n\n        # adversarial loss\n\n        adversarial_losses = []\n\n        # adversarial loss for multi-scale discriminators\n\n        for discr, scale in zip(self.discriminators, self.discr_multi_scales):\n            scaled_fake = F.interpolate(recon_x, scale_factor = scale)\n            fake_logits = discr(scaled_fake)\n            one_adversarial_loss = hinge_gen_loss(fake_logits)\n            adversarial_losses.append(one_adversarial_loss)\n\n        # adversarial loss for stft discriminator\n\n        stft_fake_logits = self.stft_discriminator(recon_x)\n\n        adversarial_losses.append(hinge_gen_loss(stft_fake_logits.real))\n        adversarial_losses.append(hinge_gen_loss(stft_fake_logits.imag))\n\n        adversarial_loss = torch.stack(adversarial_losses).mean()\n\n        return recon_loss * self.recon_loss_weight + adversarial_loss * self.adversarial_loss_weight\n","AFTER":"        orig_x = x.clone()\n\n        x = self.encoder(x)\n\n        x = rearrange(x, 'b c n -> b n c')\n        x, indices, commit_loss = self.rq(x)\n        x = rearrange(x, 'b n c -> b c n')\n\n        recon_x = self.decoder(x)\n\n        # stft discr loss\n\n        if return_stft_discr_loss:\n            assert self.single_channel\n            real, fake = orig_x, recon_x.detach()\n            stft_real_logits, stft_fake_logits = map(self.stft_discriminator, (real, fake))\n            stft_discr_loss = (hinge_discr_loss(stft_fake_logits.real, stft_real_logits.real) + hinge_discr_loss(stft_fake_logits.imag, stft_real_logits.imag)) \/ 2\n            return stft_discr_loss\n\n        # multi-scale discriminator loss\n\n        if return_discr_loss:\n            real, fake = orig_x, recon_x.detach()\n            discr_losses = []\n\n            for discr, scale in zip(self.discriminators, self.discr_multi_scales):\n                scaled_real, scaled_fake = map(lambda t: F.interpolate(t, scale_factor = scale), (real, fake))\n\n                real_logits, fake_logits = map(discr, (scaled_real, scaled_fake))\n                one_discr_loss = hinge_discr_loss(fake_logits, real_logits)\n                discr_losses.append(one_discr_loss)\n\n            return torch.stack(discr_losses).mean()\n\n        # recon loss\n\n        recon_loss = F.mse_loss(orig_x, recon_x)\n\n        # adversarial loss\n\n        adversarial_losses = []\n\n        discr_intermediates = []\n\n        # adversarial loss for multi-scale discriminators\n\n        real, fake = orig_x, recon_x\n\n        for discr, scale in zip(self.discriminators, self.discr_multi_scales):\n            scaled_real, scaled_fake = map(lambda t: F.interpolate(t, scale_factor = scale), (real, fake))\n            (real_logits, real_intermediates), (fake_logits, fake_intermediates) = map(partial(discr, return_intermediates = True), (scaled_real, scaled_fake))\n\n            discr_intermediates.append((real_intermediates, fake_intermediates))\n\n            one_adversarial_loss = hinge_gen_loss(fake_logits)\n            adversarial_losses.append(one_adversarial_loss)\n\n        feature_losses = []\n\n        for real_intermediates, fake_intermediates in discr_intermediates:\n            losses = [F.mse_loss(real_intermediate, fake_intermediate) for real_intermediate, fake_intermediate in zip(real_intermediates, fake_intermediates)]\n            feature_losses.extend(losses)\n\n        feature_loss = torch.stack(feature_losses).mean()\n\n        # adversarial loss for stft discriminator\n\n        stft_fake_logits = self.stft_discriminator(recon_x)\n\n        adversarial_losses.append(hinge_gen_loss(stft_fake_logits.real))\n        adversarial_losses.append(hinge_gen_loss(stft_fake_logits.imag))\n\n        adversarial_loss = torch.stack(adversarial_losses).mean()\n\n        return recon_loss * self.recon_loss_weight + adversarial_loss * self.adversarial_loss_weight + feature_loss * self.feature_loss_weight\n"}