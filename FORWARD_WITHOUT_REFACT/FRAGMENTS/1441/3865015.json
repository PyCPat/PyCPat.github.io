{"BEFORE":"        self.cheb_polynomials = cheb_polynomials\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.DEVICE = cheb_polynomials[0].device\n","AFTER":"    def __init__(self, K, edge_index, in_channels, out_channels, DEVICE):\n        '''\n        :param K: int\n        :param edge_index: array of edge indices\n        :param in_channles: int, num of channels in the input sequence\n        :param out_channels: int, num of channels in the output sequence\n        :param DEVICE: device\n        '''\n        super(cheb_conv_withSAt, self).__init__()\n        self.K = K\n        # now calculate Chebyshev polynomials\n        W = to_scipy_sparse_matrix(edge_index)\n        assert W.shape[0] == W.shape[1]\n        D = np.diag(np.sum(W, axis=1))\n        L = np.array(D - W.toarray())\n        lambda_max = eigs(L, k=1, which='LR')[0].real\n        L_tilde = (2 * L) \/ lambda_max - np.identity(W.shape[0])\n        cheb_polynomials = [np.identity(L_tilde.shape[0]), L_tilde.copy()]\n        for i in range(2, K):\n            cheb_polynomials.append(2 * L_tilde * cheb_polynomials[i - 1] - cheb_polynomials[i - 2])\n        self.cheb_polynomials = [torch.from_numpy(i).type(torch.FloatTensor).to(DEVICE) for i in cheb_polynomials]\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.DEVICE = DEVICE\n"}