{"BEFORE":"    def forward(self, x: torch.Tensor):\n        \"\"\"Forward pass through SimSiam.\n\n        Extracts features with the backbone and apply the projection\n        head to the output space.\n\n        Args:\n            x:\n                Tensor of shape bsz x channels x W x H\n\n        Returns:\n            Tensor of shape bsz x out_dim\n\n        \"\"\"\n        # device = output.device\n        batch_size = len(x)\n        batch_size = batch_size \/\/ 2\n\n        x1, x2 = x[:batch_size], x[batch_size:]\n\n        emb1, emb2 = self.backbone(x1), self.backbone(x2)\n        emb1, emb2 = emb1.squeeze(), emb2.squeeze()\n        z1, z2 = self.projection_mlp(emb1), self.projection_mlp(emb2)\n        p1, p2 = self.prediction_mlp(z1), self.prediction_mlp(z2)\n\n        output = torch.cat((z1, z2, p1, p2), 0)\n        return output\n","AFTER":"    def forward(self, \n                x0: torch.Tensor, \n                x1: torch.Tensor,\n                return_features: bool = False):\n        \"\"\"Forward pass through SimSiam.\n\n        Extracts features with the backbone and applies the projection\n        head to the output space. \n\n        Args:\n            x0:\n                Tensor of shape bsz x channels x W x H.\n            x1:\n                Tensor of shape bsz x channels x W x H.\n            return_features:\n                Whether or not to return the intermediate features backbone(x).\n\n        Returns:\n            The output projection of x0 and the output projection of x1. If \n            return_features is True, the output for each x is a tuple (out, f) \n            where f are the features before the projection head.\n\n        Args:\n            x:\n                Tensor of shape bsz x channels x W x H\n\n        Returns:\n            Tensor of shape bsz x out_dim\n\n        \"\"\"\n        f0, f1 = self.backbone(x0).squeeze(), self.backbone(x1).squeeze()\n\n        z0, z1 = self.projection_mlp(f0), self.projection_mlp(f1)\n        p0, p1 = self.prediction_mlp(z0), self.prediction_mlp(z1)\n\n        out0, out1 = (z0, p0), (z1, p1)\n\n        # append features if requested\n        if return_features:\n            out0, out1 = (out0, f0), (out1, f1)\n\n        return out0, out1\n"}