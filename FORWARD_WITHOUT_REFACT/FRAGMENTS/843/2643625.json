{"BEFORE":"        conf = torch.sigmoid(prediction[..., 4])\n        #-----------------------------------------------#\n        #   种类置信度\n        #-----------------------------------------------#\n        pred_cls = torch.sigmoid(prediction[..., 5:])\n        #-----------------------------------------------#\n        #   获得网络应该有的预测结果\n        #-----------------------------------------------#\n        y_true, noobj_mask = self.get_target(l, targets, scaled_anchors, in_h, in_w)\n\n        #---------------------------------------------------------------#\n        #   将预测结果进行解码，判断预测结果和真实值的重合程度\n        #   如果重合程度过大则忽略，因为这些特征点属于预测比较准确的特征点\n        #   作为负样本不合适\n        #----------------------------------------------------------------#\n        pred_boxes = self.get_pred_boxes(l, x, y, h, w, targets, scaled_anchors, in_h, in_w)\n\n        if self.cuda:\n            y_true          = y_true.cuda()\n            noobj_mask      = noobj_mask.cuda()\n        \n        loss    = 0\n        n       = torch.sum(y_true[..., 4] == 1)\n        if n != 0:\n            #---------------------------------------------------------------#\n            #   计算预测结果和真实结果的giou\n            #----------------------------------------------------------------#\n            giou        = self.box_giou(pred_boxes, y_true[..., :4])\n            loss_loc    = torch.mean((1 - giou)[y_true[..., 4] == 1])\n            loss_cls    = torch.mean(self.BCELoss(pred_cls[y_true[..., 4] == 1], self.smooth_labels(y_true[..., 5:][y_true[..., 4] == 1], self.label_smoothing, self.num_classes)))\n            loss        += loss_loc * self.box_ratio + loss_cls * self.cls_ratio\n            #-----------------------------------------------------------#\n            #   计算置信度的loss\n            #-----------------------------------------------------------#\n            tobj        = torch.where(y_true[..., 4] == 1, giou.detach().clamp(0), torch.zeros_like(y_true[..., 4]))\n        else:\n            tobj        = torch.zeros_like(y_true[..., 4])\n        loss_conf   = torch.mean(self.BCELoss(conf, tobj))\n\n        loss        += loss_conf * self.balance[l] * self.obj_ratio\n        return loss\n","AFTER":"        conf = torch.sigmoid(prediction[..., 4])\n        #-----------------------------------------------#\n        #   种类置信度\n        #-----------------------------------------------#\n        pred_cls = torch.sigmoid(prediction[..., 5:])\n        #-----------------------------------------------#\n        #   获得网络应该有的预测结果\n        #-----------------------------------------------#\n        y_true, noobj_mask, box_loss_scale = self.get_target(l, targets, scaled_anchors, in_h, in_w)\n\n        #---------------------------------------------------------------#\n        #   将预测结果进行解码，判断预测结果和真实值的重合程度\n        #   如果重合程度过大则忽略，因为这些特征点属于预测比较准确的特征点\n        #   作为负样本不合适\n        #----------------------------------------------------------------#\n        pred_boxes = self.get_pred_boxes(l, x, y, h, w, targets, scaled_anchors, in_h, in_w)\n\n        if self.cuda:\n            y_true          = y_true.cuda()\n            noobj_mask      = noobj_mask.cuda()\n            box_loss_scale  = box_loss_scale.cuda()\n        #-----------------------------------------------------------#\n        #   reshape_y_true[...,2:3]和reshape_y_true[...,3:4]\n        #   表示真实框的宽高，二者均在0-1之间\n        #   真实框越大，比重越小，小框的比重更大。\n        #-----------------------------------------------------------#\n        box_loss_scale = 2 - box_loss_scale\n\n        #---------------------------------------------------------------#\n        #   计算预测结果和真实结果的giou\n        #----------------------------------------------------------------#\n        giou        = self.box_giou(pred_boxes[y_true[..., 4] == 1], y_true[..., :4][y_true[..., 4] == 1])\n\n        loss_loc    = torch.sum((1 - giou) * box_loss_scale[y_true[..., 4] == 1])\n        #-----------------------------------------------------------#\n        #   计算置信度的loss\n        #-----------------------------------------------------------#\n        loss_conf   = torch.sum(self.BCELoss(conf[y_true[..., 4] == 1], giou.detach().clamp(0))) + \\\n                      torch.sum(self.BCELoss(conf, y_true[..., 4]) * noobj_mask)\n        loss_cls    = torch.sum(self.BCELoss(pred_cls[y_true[..., 4] == 1], self.smooth_labels(y_true[..., 5:][y_true[..., 4] == 1], self.label_smoothing, self.num_classes)))\n\n        loss        = loss_loc * self.box_ratio + loss_conf * self.balance[l] * self.obj_ratio + loss_cls * self.cls_ratio\n        num_pos = torch.sum(y_true[..., 4])\n        num_pos = torch.max(num_pos, torch.ones_like(num_pos))\n        return loss, num_pos\n"}