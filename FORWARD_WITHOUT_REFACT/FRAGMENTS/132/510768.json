{"BEFORE":"        w = width\n        self.architecture_definition = NETWORK_ARCHITECTURE_DEFINITIONS[arch_str]\n        conv_layers = []\n        in_dim = observation_space.shape[0]\n\n        block = magical_conv_block\n        if 'resnet' in arch_str:\n            block = BasicResidualBlock\n        for layer_definition in self.architecture_definition:\n            if layer_definition.get('residual', False):\n                block_kwargs = {\n                    'stride': layer_definition['stride'],\n                    'downsample': nn.Sequential(nn.Conv2d(in_dim,\n                                                          layer_definition['out_dim'],\n                                                          kernel_size=1,\n                                                          stride=layer_definition['stride']),\n                                                nn.BatchNorm2d(layer_definition['out_dim']))\n                }\n                conv_layers += [block(in_dim,\n                                      layer_definition['out_dim'] * w,\n                                      **block_kwargs)]\n            else:\n                block_kwargs = {\n                    'stride': layer_definition['stride'],\n                    'kernel_size': layer_definition['kernel_size'],\n                    'padding': layer_definition['padding'],\n                    'use_bn': use_bn,\n                    'use_sn': use_sn,\n                    'dropout': dropout,\n                    'activation_cls': ActivationCls\n                }\n                conv_layers += block(in_dim,\n                                     layer_definition['out_dim'] * w,\n                                     **block_kwargs)\n\n            in_dim = layer_definition['out_dim']*w\n","AFTER":"        w = width\n        self.architecture_definition = NETWORK_ARCHITECTURE_DEFINITIONS[arch_str]\n        conv_layers = []\n        in_dim = observation_space.shape[0]\n\n        block = magical_conv_block\n        if 'resnet' in arch_str:\n            block = BasicResidualBlock\n        for layer_definition in self.architecture_definition:\n            layer_stride = layer_definition['stride']\n            layer_out_dim = layer_definition['out_dim']\n            if layer_definition.get('residual', False):\n                block_kwargs = {\n                    'stride': layer_stride,\n                    'downsample': nn.Sequential(nn.Conv2d(in_dim,\n                                                          layer_out_dim,\n                                                          kernel_size=1,\n                                                          stride=layer_stride),\n                                                nn.BatchNorm2d(layer_out_dim))\n                }\n                conv_layers += [block(in_dim,\n                                      layer_out_dim * w,\n                                      **block_kwargs)]\n            else:\n                # these asserts are to satisfy PyType, since not all\n                # NETWORK_ARCHITECTURE_DEFINITIONS have these two keys\n                assert 'padding' in layer_definition\n                assert 'kernel_size' in layer_definition\n                layer_padding = layer_definition['padding']\n                layer_kernel_size = layer_definition['kernel_size']\n                block_kwargs = {\n                    'stride': layer_stride,\n                    'kernel_size': layer_kernel_size,\n                    'padding': layer_padding,\n                    'use_bn': use_bn,\n                    'use_sn': use_sn,\n                    'dropout': dropout,\n                    'activation_cls': ActivationCls\n                }\n                conv_layers += block(in_dim,\n                                     layer_out_dim * w,\n                                     **block_kwargs)\n\n            in_dim = layer_out_dim*w\n"}