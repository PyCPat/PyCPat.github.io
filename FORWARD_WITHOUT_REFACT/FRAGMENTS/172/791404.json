{"BEFORE":"        pose_list, decision_list, logit_list = [], [], []\n        hidden = torch.zeros(batch_size, self.opt.rnn_hidden_size).to(fv.device) if hc is None else hc[0].contiguous()[:, -1, :]\n        fv_alter = torch.zeros_like(fv)\n\n        for i in range(seq_len):\n            if i == 0 and is_first:\n                # The first relative pose is estimated by both images and imu by default\n                pose, hc = self.Pose_net(fv[:, i, :].unsqueeze(1), None, fi[:, i, :].unsqueeze(1), None, hc)\n            else:\n                # Otherwise, sample the decision from the policy network\n                p_in = torch.cat((fi[:, i, :], hidden), -1)\n                logits, decision = self.Policy_net(p_in.detach(), temp)\n\n                decision = decision.unsqueeze(1)                   \n                pose, hc = self.Pose_net(fv[:, i, :].unsqueeze(1), fv_alter[:, i, :].unsqueeze(1), fi[:, i, :].unsqueeze(1), decision, hc)\n                decision_list.append(decision) \n                logit_list.append(logits) \n            \n            pose_list.append(pose)\n            hidden = hc[0].contiguous()[:, -1, :]\n\n        poses = torch.cat(pose_list, dim=1)\n        decision = torch.cat(decision_list, dim=1)\n        logit = torch.cat(logit_list, dim=0)\n        probs = torch.nn.functional.softmax(logits, dim=-1)\n        return poses, decision, probs, hc\n","AFTER":"        poses, decisions, logits= [], [], []\n        hidden = torch.zeros(batch_size, self.opt.rnn_hidden_size).to(fv.device) if hc is None else hc[0].contiguous()[:, -1, :]\n        fv_alter = torch.zeros_like(fv) # zero padding in the paper \n\n        for i in range(seq_len):\n            if i == 0 and is_first:\n                # The first relative pose is estimated by both images and imu by default\n                pose, hc = self.Pose_net(fv[:, i:i+1, :], None, fi[:, i:i+1, :], None, hc)\n            else:\n                # Otherwise, sample the decision from the policy network\n                p_in = torch.cat((fi[:, i, :], hidden), -1)\n                logit, decision = self.Policy_net(p_in.detach(), temp)\n\n                decision = decision.unsqueeze(1)\n                pose, hc = self.Pose_net(fv[:, i:i+1, :], fv_alter[:, i:i+1, :], fi[:, i:i+1, :], decision, hc)\n                decisions.append(decision)\n                logits.append(logit)\n\n            poses.append(pose)\n            hidden = hc[0].contiguous()[:, -1, :]\n\n        poses = torch.cat(poses, dim=1)\n        decisions = torch.cat(decisions, dim=1)\n        logits = torch.cat(logits, dim=0)\n        probs = torch.nn.functional.softmax(logits, dim=-1)\n\n        return poses, decisions, probs, hc\n"}