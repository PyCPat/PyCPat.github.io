{"BEFORE":"        B = characters.size(0)\n        mask = sequence_mask(text_lengths).to(characters.device)\n        inputs = self.embedding(characters)\n        self._init_states()\n        self.compute_speaker_embedding(speaker_ids)\n        if self.num_speakers > 1:\n            inputs = self._concat_speaker_embedding(inputs,\n                                                    self.speaker_embeddings)\n        encoder_outputs = self.encoder(inputs)\n        if self.gst:\n            encoder_outputs = self.compute_gst(encoder_outputs, mel_specs)\n        if self.num_speakers > 1:\n            encoder_outputs = self._concat_speaker_embedding(\n                encoder_outputs, self.speaker_embeddings)\n        mel_outputs, alignments, stop_tokens = self.decoder(\n            encoder_outputs, mel_specs, mask,\n            self.speaker_embeddings_projected)\n        mel_outputs = mel_outputs.view(B, -1, self.mel_dim)\n        linear_outputs = self.postnet(mel_outputs)\n        linear_outputs = self.last_linear(linear_outputs)\n        return mel_outputs, linear_outputs, alignments, stop_tokens\n","AFTER":"        self._init_states()\n        B = characters.size(0)\n        mask = sequence_mask(text_lengths).to(characters.device)\n        # B x T_in x embed_dim\n        inputs = self.embedding(characters)\n        # B x speaker_embed_dim\n        self.compute_speaker_embedding(speaker_ids)\n        if self.num_speakers > 1:\n            # B x T_in x embed_dim + speaker_embed_dim\n            inputs = self._concat_speaker_embedding(inputs,\n                                                    self.speaker_embeddings)\n        # B x T_in x encoder_dim\n        encoder_outputs = self.encoder(inputs)\n        if self.gst:\n            # B x gst_dim\n            encoder_outputs = self.compute_gst(encoder_outputs, mel_specs)\n        if self.num_speakers > 1:\n            encoder_outputs = self._concat_speaker_embedding(\n                encoder_outputs, self.speaker_embeddings)\n        # decoder_outputs: B x decoder_dim x T_out\n        # alignments: B x T_in x encoder_dim\n        # stop_tokens: B x T_in\n        decoder_outputs, alignments, stop_tokens = self.decoder(\n            encoder_outputs, mel_specs, mask,\n            self.speaker_embeddings_projected)\n        # B x T_out x decoder_dim\n        postnet_outputs = self.postnet(decoder_outputs)\n        # B x T_out x posnet_dim\n        postnet_outputs = self.last_linear(postnet_outputs)\n        # B x T_out x decoder_dim\n        decoder_outputs = decoder_outputs.transpose(1, 2)\n        if self.bidirectional_decoder:\n            decoder_outputs_backward, alignments_backward = self._backward_inference(mel_specs, encoder_outputs, mask)\n            return decoder_outputs, postnet_outputs, alignments, stop_tokens, decoder_outputs_backward, alignments_backward\n        return decoder_outputs, postnet_outputs, alignments, stop_tokens\n"}