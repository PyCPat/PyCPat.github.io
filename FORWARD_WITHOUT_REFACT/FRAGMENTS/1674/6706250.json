{"BEFORE":"        threshold = self.threshold\n        threshold_low = self.threshold_low\n        neg_spikes = self.negative_spikes\n\n        state = self.state\n        activations = self.activations\n        spikes = []\n        for iCurrentTimeStep in range(time_steps):\n            # update neuron states\n            state = syn_out[iCurrentTimeStep] + state - activations * threshold\n            if threshold_low is not None and not neg_spikes:\n                # This is equivalent to functional.threshold. non zero threshold is not supported for onnx\n                state = torch.nn.functional.relu(state-threshold_low) + threshold_low\n            # generate spikes\n            if neg_spikes:\n                activations = (\n                    threshold_subtract(state.abs(), threshold, threshold * window)\n                    * state.sign().int()\n                )\n","AFTER":"        syn_out: torch.Tensor = self.synaptic_output(binary_input)\n\n        # Reshape data to appropriate dimensions\n        if self.batch_size:\n            syn_out = syn_out.reshape((-1, self.batch_size, *syn_out.shape[1:]))\n        # Ensure the neuron state are initialized\n        try:\n            assert self.state.shape == syn_out.shape[1:]\n        except AssertionError:\n            self.reset_states(shape=syn_out.shape[1:], randomize=False)\n\n        # Determine no. of time steps from input\n        time_steps = len(syn_out)\n\n        # Local variables\n        threshold = self.threshold\n        threshold_low = self.threshold_low\n\n        state = self.state\n        activations = self.activations\n        spikes = []\n        for iCurrentTimeStep in range(time_steps):\n\n            # update neuron states (membrane potentials)\n            if self.membrane_reset:\n                # sum the previous state only where there were no spikes\n                state = syn_out[iCurrentTimeStep] + state * (activations == 0.)\n            else:\n                # subtract a number of membrane_subtract's as there are spikes\n                state = syn_out[iCurrentTimeStep] + state - activations * self.membrane_subtract\n            if threshold_low is not None:\n                # This is equivalent to functional.threshold. non zero threshold is not supported for onnx\n                state = torch.nn.functional.relu(state - threshold_low) + threshold_low\n\n            # generate spikes\n            if self.membrane_reset:\n                activations = threshold_reset(state, threshold, threshold * window)\n"}