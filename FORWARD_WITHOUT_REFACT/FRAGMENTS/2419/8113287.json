{"BEFORE":"        num_frames, fmap_size, _ = self.video_shape\n\n        # pad for last token in video\n\n        x = F.pad(x, (0, 0, 0, 1), value = 0.)\n\n        # derive queries \/ keys \/ values\n\n        qkv = self.to_qkv(x).chunk(3, dim = -1)\n        q, k, v = map(lambda t: rearrange(t, 'b n (h d) -> (b h) n d', h = h), qkv)\n\n        # scale queries\n\n        q = q * self.scale\n\n        # take care of bos\n\n        q = q[:, 1:]\n        bos_value = v[:, :1]\n\n        # prepare precomputed causal mask\n\n        causal_mask = self.causal_mask[:n]\n        causal_mask = repeat(causal_mask, 'i j -> b i j', b = b * h)\n","AFTER":"        fmap_size = self.video_shape[1]\n\n        bos_only = n == 1\n        tokens_per_frame = fmap_size ** 2\n\n        padding = 0 if bos_only else (tokens_per_frame - (n - 1) % tokens_per_frame)\n        num_frames = (n + padding) \/\/ tokens_per_frame\n\n        # pad for last token in video\n\n        if padding > 0:\n            x = F.pad(x, (0, 0, 0, padding), value = 0.)\n\n        # derive queries \/ keys \/ values\n\n        q, k, v = self.to_qkv(x).chunk(3, dim = -1)\n\n        # early return if <bos>\n\n        if bos_only:\n            return self.to_out(v)\n\n        # split out heads\n\n        q, k, v = map(lambda t: rearrange(t, 'b n (h d) -> (b h) n d', h = h), (q, k, v))\n\n        # scale queries\n\n        q = q * self.scale\n\n        # take care of bos\n\n        q = q[:, 1:]\n        bos_value = v[:, :1]\n\n        # compute keys and values\n\n        (k_bos, k), (v_bos, v) = map(lambda t: (t[:, :1], t[:, 1:]), (k, v))\n        k, v = map(lambda t: rearrange(t, 'b (f h w) d -> b d f h w', f  = num_frames, h = fmap_size), (k, v))\n        k, v = map(lambda t: unfoldNd(t, kernel_size = kernel_size, padding = kernel_size \/\/ 2), (k, v))\n        k, v = map(lambda t: rearrange(t, 'b (d j) i -> b i j d', j = kernel_size ** 3), (k, v))\n\n        # append bos keys and values\n\n        k_bos, v_bos = map(lambda t: repeat(t, 'b 1 d -> b n 1 d', n = k.shape[1]), (k_bos, v_bos))\n        k = torch.cat((k_bos, k), dim = 2)\n        v = torch.cat((v_bos, v), dim = 2)\n\n        # calculate sim\n\n        sim = einsum('b i d, b i j d -> b i j', q, k)\n\n        # causal mask\n\n        i, j = sim.shape[-2:]\n        causal_mask = self.causal_mask[:i, :j]\n        causal_mask = repeat(causal_mask, 'i j -> b i j', b = b * h)\n"}