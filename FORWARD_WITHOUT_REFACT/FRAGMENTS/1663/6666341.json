{"BEFORE":"            if self.collection_mode:\n                self.collection(instance_means=x_mean, instnace_stds=x_std, y_anchors=y_anchor, x_anchors=x_anchor)\n\n            else:\n                assert x.shape[0] == 1 # currently, could support batch size = 1 for kernelized instance normalization\n                top, down, left, right = self.query_neighbors(y_anchor=y_anchor, x_anchor=x_anchor, padding=padding)\n                mean_matrix = self.mean_table[top:down + 1, left:right + 1, :]\n                std_matrix = self.std_table[top:down + 1, left:right + 1, :]\n                x_mean = mean_matrix.mean(dim=0).mean(dim=0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1) #self.kernel *  # should deal with the boundary\n                x_std = std_matrix.mean(dim=0).mean(dim=0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1) #self.kernel * \n                #x_mean = x_mean.unsqueeze(-1).unsqueeze(-1)\n                #x_std = x_std.unsqueeze(-1).unsqueeze(-1)\n\n            x = (x - x_mean) \/ x_std * self.weight + self.bias\n","AFTER":"            if self.collection_mode:\n                self.collection(instance_means=x_mean, instnace_stds=x_std, y_anchors=y_anchor, x_anchors=x_anchor)\n\n            else:\n                assert x.shape[0] == 1 # currently, could support batch size = 1 for kernelized instance normalization\n                top = y_anchor\n                down = y_anchor + 2 * padding + 1\n                left = x_anchor\n                right = x_anchor + 2 *padding + 1\n                x_mean = self.padded_mean_table[:,:,top:down + 1, left:right + 1] # 1, C, H, W\n                x_std = self.padded_std_table[:,:,top:down + 1, left:right + 1] # 1, C, H, W\n                assert self.kernel.shape == x.mean.shape\n                x_mean = x_mean * self.kernel # 1, C, H, W\n                x_std = x_std * self.kernel # 1, C, H, W\n                x_mean = x_mean.flatten(start_dim=2).sum(dim=2) # [1, C, H, W] -> [1, C, H * W] -> [1, C]\n                x_std = x_std.flatten(start_dim=2).sum(dim=2) # [1, C, H, W] -> [1, C, H * W] -> [1, C]\n                x_mean = x_mean.unsqueeze(-1).unsqueeze(-1) # [1, C] -> [1, C, 1, 1]\n                x_std = x_std.unsqueeze(-1).unsqueeze(-1) # [1, C] -> [1, C, 1, 1]\n\n                #top, down, left, right = self.query_neighbors(y_anchor=y_anchor, x_anchor=x_anchor, padding=padding)\n                #mean_matrix = self.mean_table[top:down + 1, left:right + 1, :]\n                #std_matrix = self.std_table[top:down + 1, left:right + 1, :]\n                # H, W, C -> C -> 1, C -> 1, C, 1, 1\n                #x_mean = mean_matrix.mean(dim=0).mean(dim=0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1) #self.kernel *  # should deal with the boundary\n                #x_std = std_matrix.mean(dim=0).mean(dim=0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1) #self.kernel * \n\n            x = (x - x_mean) \/ x_std * self.weight + self.bias\n"}