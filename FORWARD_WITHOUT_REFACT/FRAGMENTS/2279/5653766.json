{"BEFORE":"                inp, inp * t, bn_momentum=bn_momentum, norm_layer=norm_layer,\n                activation_layer=activation_layer))\n\n        layers.append(DepthwiseBlock(inp * t, inp * t, kernel_size, stride=self.stride, padding=self.padding,\n                                     bn_momentum=bn_momentum, norm_layer=norm_layer, activation_layer=activation_layer))\n\n        if (se_ratio is not None) and (se_ratio > 0) and (se_ratio <= 1):\n            layers.append(SEBlock(inp * t, se_ratio \/ t))\n\n        layers.append(Conv2d1x1BN(\n            inp * t, oup, bn_momentum=bn_momentum, norm_layer=norm_layer))\n","AFTER":"        se_ind: bool = False,\n        survival_prob: float = None,\n        bn_momentum: float = 0.1,\n        norm_layer: nn.Module = nn.BatchNorm2d,\n        activation_layer: nn.Module = nn.ReLU\n    ):\n        super().__init__()\n\n        self.inp = inp\n        self.planes = int(self.inp * t)\n        self.oup = oup\n        self.stride = stride\n        self.padding = padding if padding is not None else (kernel_size \/\/ 2)\n        self.apply_residual = (self.stride == 1) and (self.inp == self.oup)\n        self.se_ratio = se_ratio if se_ind or se_ratio is None else (se_ratio \/ t)\n        self.has_se = (self.se_ratio is not None) and (self.se_ratio > 0) and (self.se_ratio <= 1)\n\n        layers = []\n        if t != 1:\n            layers.append(Conv2d1x1Block(\n                inp, self.planes, bn_momentum=bn_momentum, norm_layer=norm_layer,\n                activation_layer=activation_layer))\n\n        layers.append(DepthwiseBlock(self.planes, self.planes, kernel_size, stride=self.stride, padding=self.padding,\n                                     bn_momentum=bn_momentum, norm_layer=norm_layer, activation_layer=activation_layer))\n\n        if self.has_se:\n            layers.append(SEBlock(self.planes, self.se_ratio))\n\n        layers.append(Conv2d1x1BN(\n            self.planes, oup, bn_momentum=bn_momentum, norm_layer=norm_layer))\n"}