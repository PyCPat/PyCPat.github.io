{"BEFORE":"    def forward(self, x, timespans=None):\n        device = x.device\n        batch_size = x.size(0)\n        seq_len = x.size(1)\n        hidden_state = [\n            torch.zeros((batch_size, self.d_hidden), device=device),\n            torch.zeros((batch_size, self.d_hidden), device=device),\n        ]\n        outputs = []\n        last_output = torch.zeros((batch_size, self.d_output), device=device)\n\n        if timespans is None:\n            timespans = x.new_ones(x.shape[:-1]+(1,)) \/ x.shape[1]\n\n        for t in range(seq_len):\n            inputs = x[:, t]\n            ts = timespans[:, t].squeeze()\n            hidden_state = self.rnn_cell.forward(inputs, hidden_state, ts)\n            current_output = self.fc(hidden_state[0])\n            outputs.append(current_output)\n            last_output = current_output\n        if self.return_sequences:\n            outputs = torch.stack(outputs, dim=1)  # return entire sequence\n        else:\n            outputs = last_output  # only last item\n        return outputs, hidden_state\n","AFTER":"    def forward(self, u, state=None, rate=1.0, lengths=None, **kwargs):\n        if state is not None:\n            print(\"state is not None -> breakpoint\")\n            breakpoint()\n        # if lengths is not None:\n        #     print(\"lengths is not None -> breakpoint\")\n        #     breakpoint()\n        #\n        L = u.size(-1)\n        if lengths is not None:\n            assert isinstance(lengths, torch.Tensor) and lengths.ndim == 1 and lengths.size(0) in [1, u.size(0)]\n            mask = torch.where(torch.arange(L, device=lengths.device) < lengths[:, None, None], 1., 0.)\n            u = u * mask\n\n        device = u.device\n        batch_size = u.size(0)\n        seq_len = u.size(1)\n        hidden_state = [\n            torch.zeros((batch_size, self.d_hidden), device=device),\n            torch.zeros((batch_size, self.d_hidden), device=device),\n        ]\n        outputs = []\n        last_output = torch.zeros((batch_size, self.d_output), device=device)\n\n        for t in range(seq_len):\n            inputs = u[:, t]\n            hidden_state = self.rnn_cell.forward(inputs, hidden_state, rate)\n            current_output = self.fc(hidden_state[0])\n            outputs.append(current_output)\n            last_output = current_output\n        # if self.return_sequences:\n        #     outputs = torch.stack(outputs, dim=1)  # return entire sequence\n        # else:\n        #     outputs = last_output  # only last item\n        outputs = torch.stack(outputs, dim=1)  # return entire sequence\n"}