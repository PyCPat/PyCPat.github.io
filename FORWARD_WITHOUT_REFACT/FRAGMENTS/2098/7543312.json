{"BEFORE":"            encoded = self.encoder(image)\n            z = self.to_out(encoded.flatten(1))\n            hx, cx = self.rnn(kx, (hx, cx))\n            yt, gt, kwt = self.to_output(hx), self.to_gate(hx), self.to_key(hx)\n\n            if is_first:\n                kx = self.k0\n            else:\n                sim = einsum('b n d, b d -> b n', Mv, z)\n                wkt = sim.softmax(dim = -1)\n                ck = self.to_confidence(sim.unsqueeze(dim = -1)).sigmoid()\n                kr = gt * (wkt.unsqueeze(-1) * torch.cat((Mk, ck), dim = -1)).sum(dim = 1)\n","AFTER":"            z = self.encoder(image)\n            hx, cx = self.rnn(kx, (hx, cx))\n            yt, gt, kwt = self.to_output(hx), self.to_gate(hx), self.to_key(hx)\n\n            if is_first:\n                kx = self.k0\n            else:\n                # attention\n                sim = einsum('b n d, b d -> b n', Mv, z)\n                wkt = sim.softmax(dim = -1)\n\n                # calculate confidence\n                sim, wkt = map(lambda t: rearrange(t, 'b n -> b n ()'), (sim, wkt))\n                ck = self.to_confidence(sim).sigmoid()\n\n                # concat confidence to memory keys\n                # then weighted sum of all memory keys by attention of memory values\n                kr = gt * (wkt * torch.cat((Mk, ck), dim = -1)).sum(dim = 1)\n"}