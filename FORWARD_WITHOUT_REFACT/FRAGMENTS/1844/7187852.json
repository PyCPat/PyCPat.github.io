{"BEFORE":"        x_ft = torch.stack([x_ft.real, x_ft.imag], dim=4)\n        # x_ft.shape == [batch_size, in_dim, grid_size, grid_size \/\/ 2 + 1, 2]\n\n        out_ft = torch.zeros(B, I, N, M \/\/ 2 + 1, 2, device=x.device)\n        # out_ft.shape == [batch_size, in_dim, grid_size, grid_size \/\/ 2 + 1, 2]\n\n        out_ft[:, :, :self.n_modes, :self.n_modes] = self.complex_matmul_2d(\n            x_ft[:, :, :self.n_modes, :self.n_modes], self.fourier_weight[0], self.fourier_weight[1])\n\n        out_ft[:, :, -self.n_modes:, :self.n_modes] = self.complex_matmul_2d(\n            x_ft[:, :, -self.n_modes:, :self.n_modes], self.fourier_weight[2], self.fourier_weight[3])\n\n        out_ft = torch.complex(out_ft[..., 0], out_ft[..., 1])\n\n        x = torch.fft.irfft2(out_ft, s=(N, M), norm='ortho')\n","AFTER":"        M = N = int(math.sqrt(x.shape[1] \/\/ self.in_dim))\n        # x.shape == [batch_size, grid_size, grid_size, in_dim]\n        # res.shape == [batch_size, grid_size, grid_size, out_dim]\n\n        x = rearrange(x, 'b (m n i) 1 -> b m n i', m=M, n=N, i=self.in_dim)\n        B, M, N, I = x.shape\n        # x.shape == [batch_size, grid_size, grid_size, in_dim]\n\n        z = rearrange(z, 'b (k m n i) 1 -> k b m n i', k=2, m=M, n=N, i=I)\n        # z.shape == [2, batch_size, grid_size, grid_size, in_dim]\n\n        backcast, forecast = z[0], z[1]\n\n        # Subtract away things that we've already used for previous predictions\n        x = x - backcast\n        # x.shape == [batch_size, grid_size, grid_size, in_dim]\n\n        x = rearrange(x, 'b m n i -> b i m n')\n        # x.shape == [batch_size, in_dim, grid_size, grid_size]\n\n        # # # Dimesion Y # # #\n        x_fty = torch.fft.rfft(x, dim=-1, norm='ortho')\n        # x_ft.shape == [batch_size, in_dim, grid_size, grid_size \/\/ 2 + 1]\n\n        x_fty = torch.stack([x_fty.real, x_fty.imag], dim=4)\n        # x_ft.shape == [batch_size, in_dim, grid_size, grid_size \/\/ 2 + 1, 2]\n\n        out_ft = torch.zeros(B, I, N, M \/\/ 2 + 1, 2, device=x.device)\n        # out_ft.shape == [batch_size, in_dim, grid_size, grid_size \/\/ 2 + 1, 2]\n\n        out_ft[:, :, :, :self.n_modes] = self.complex_matmul_y_2d(\n            x_fty[:, :, :, :self.n_modes], self.fourier_weight[0])\n\n        out_ft = torch.complex(out_ft[..., 0], out_ft[..., 1])\n\n        xy = torch.fft.irfft(out_ft, dim=-1, norm='ortho')\n        # x.shape == [batch_size, in_dim, grid_size, grid_size]\n\n        # # # Dimesion X # # #\n        x_ftx = torch.fft.rfft(x, dim=-2, norm='ortho')\n        # x_ft.shape == [batch_size, in_dim, grid_size \/\/ 2 + 1, grid_size]\n\n        x_ftx = torch.stack([x_ftx.real, x_ftx.imag], dim=4)\n        # x_ft.shape == [batch_size, in_dim, grid_size \/\/ 2 + 1, grid_size, 2]\n\n        out_ft = torch.zeros(B, I, N \/\/ 2 + 1, M, 2, device=x.device)\n        # out_ft.shape == [batch_size, in_dim, grid_size \/\/ 2 + 1, grid_size, 2]\n\n        out_ft[:, :, :self.n_modes, :] = self.complex_matmul_x_2d(\n            x_ftx[:, :, :self.n_modes, :], self.fourier_weight[1])\n\n        out_ft = torch.complex(out_ft[..., 0], out_ft[..., 1])\n\n        xx = torch.fft.irfft(out_ft, dim=-2, norm='ortho')\n        # x.shape == [batch_size, in_dim, grid_size, grid_size]\n\n        # # Combining Dimensions # #\n        x = xx + xy\n"}