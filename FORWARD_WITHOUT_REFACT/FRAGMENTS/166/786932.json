{"BEFORE":"        loss_cl_seg = self.CE(sc_cl_se, labels)\n\n        total_loss = loss_cl_seg\n        # classification loss: positive regions\n        loss_pos = self.CE(scores_pos, labels)\n\n        total_loss = total_loss + loss_pos\n\n        # regularization: loss over negative regions.\n        loss_neg = torch.tensor([0.])\n        if self.reg_loss is not None:\n            assert scores_neg is not None, \"ERROR\"\n            loss_neg = self.reg_loss(scores_neg)\n            total_loss = total_loss + self.lambda_neg * loss_neg\n\n        # constraint on background size.\n        loss_sz_con = torch.tensor([0.])\n        bsz = float(scores_pos.shape[0])\n        if self.use_size_const:\n            loss_sz_con = self.size_const(masks_pred=masks_pred) \/ bsz\n            total_loss = total_loss + loss_sz_con\n\n\n        return total_loss, loss_pos, loss_neg, loss_cl_seg\n","AFTER":"                cams=None\n                ):\n\n        if self.dataset_name == constants.GLAS:\n            return self.forward_glas(\n                scores_pos=scores_pos,\n                sc_cl_se=sc_cl_se,\n                labels=labels,\n                masks_pred=masks_pred,\n                scores_neg=scores_neg\n            )\n\n        if self.dataset_name == constants.CAMELYON16P512:\n            return self.f_camelyon16(\n                scores_pos=scores_pos,\n                sc_cl_se=sc_cl_se,\n                labels=labels,\n                masks_pred=masks_pred,\n                scores_neg=scores_neg,\n                cams=cams\n            )\n\n        raise NotImplementedError\n"}