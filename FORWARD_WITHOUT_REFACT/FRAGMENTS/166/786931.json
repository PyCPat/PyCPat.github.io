{"BEFORE":"            feat = (feat, )\n        if len(feat) >= 2:\n            assert self.with_temporal_pool\n        if self.with_temporal_pool:\n            feat = [torch.mean(x, 2, keepdim=True) for x in feat]\n        feat = torch.cat(feat, axis=1)\n\n        roi_feats = []\n        for t in range(feat.size(2)):\n            frame_feat = feat[:, :, t].contiguous()\n            roi_feat = self.roi_layer(frame_feat, rois)\n            if self.with_global:\n                global_feat = self.global_pool(frame_feat.contiguous())\n                inds = rois[:, 0].type(torch.int64)\n                global_feat = global_feat[inds]\n                roi_feat = torch.cat([roi_feat, global_feat], dim=1)\n                roi_feat = roi_feat.contiguous()\n            roi_feats.append(roi_feat)\n\n        return torch.stack(roi_feats, dim=2)\n","AFTER":"            feat = (feat, )\n\n        if len(feat) >= 2:\n            maxT = max([x.shape[2] for x in feat])\n            max_shape = (maxT, ) + feat[0].shape[3:]\n            # resize each feat to the largest shape (w. nearest)\n            feat = [F.interpolate(x, max_shape).contiguous() for x in feat]\n\n        if self.with_temporal_pool:\n            if self.temporal_pool_mode == 'avg':\n                feat = [torch.mean(x, 2, keepdim=True) for x in feat]\n            elif self.temporal_pool_mode == 'max':\n                feat = [torch.max(x, 2, keepdim=True)[0] for x in feat]\n            else:\n                raise NotImplementedError\n\n        feat = torch.cat(feat, axis=1).contiguous()\n\n        roi_feats = []\n        for t in range(feat.size(2)):\n            frame_feat = feat[:, :, t].contiguous()\n            roi_feat = self.roi_layer(frame_feat, rois)\n            if self.with_global:\n                global_feat = self.global_pool(frame_feat.contiguous())\n                inds = rois[:, 0].type(torch.int64)\n                global_feat = global_feat[inds]\n                roi_feat = torch.cat([roi_feat, global_feat], dim=1)\n                roi_feat = roi_feat.contiguous()\n            roi_feats.append(roi_feat)\n\n        return torch.stack(roi_feats, dim=2), feat\n"}