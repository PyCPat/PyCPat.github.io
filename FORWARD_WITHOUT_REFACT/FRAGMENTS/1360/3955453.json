{"BEFORE":"            for mss in multi_stage_specs:\n                mss = as_complex(mss.squeeze(1)).unsqueeze(1)\n                sl += self.sl(input=mss, target=clean[..., : mss.shape[-1]])\n            else:\n                sl = self.sl(input=enhanced, target=clean)\n        if self.mrsl_f > 0 and self.mrsl is not None:\n            mrsl = self.mrsl(enhanced_td, clean_td)\n","AFTER":"        clean_td = None\n        multi_stage = None\n        multi_stage_td = None\n        if multi_stage_specs:\n            # Stack spectrograms in a channel dimension\n            multi_stage = as_complex(torch.stack(multi_stage_specs, dim=1))\n        lsnr_gt = self.lsnr(clean, noise=noisy - clean)\n        if self.istft is not None:\n            if self.store_losses or self.mrsl is not None:\n                enhanced_td = self.istft(enhanced)\n                clean_td = self.istft(clean)\n                if multi_stage is not None:\n                    # leave out erb enhanced\n                    multi_stage_td = self.istft(multi_stage[:, 1:])\n\n        ml, sl, mrsl, cal = [torch.zeros((), device=clean.device)] * 4\n        if self.ml_f != 0 and self.ml is not None:\n            ml = self.ml(input=mask, clean=clean, noisy=noisy, max_bin=max_bin)\n        if self.sl_f != 0 and self.sl is not None:\n            sl = torch.zeros((), device=clean.device)\n            if multi_stage is not None:\n                sl += self.sl(input=multi_stage, target=clean.expand_as(multi_stage))\n            else:\n                sl = self.sl(input=enhanced, target=clean)\n        if self.mrsl_f > 0 and self.mrsl is not None:\n            if multi_stage_td is not None:\n                mrsl = self.mrsl(multi_stage_td, clean_td.expand_as(multi_stage_td))\n            else:\n                mrsl = self.mrsl(enhanced_td, clean_td)\n        lsnrl = self.lsnrl(input=lsnr, target_lsnr=lsnr_gt)\n"}