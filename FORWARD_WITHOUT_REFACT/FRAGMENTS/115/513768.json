{"BEFORE":"    def forward(self, tgt, reference_points, src, src_spatial_shapes, src_level_start_index, src_valid_ratios,\n                query_pos=None, src_padding_mask=None):\n        output = tgt\n\n        intermediate = []\n        intermediate_reference_points = []\n        for layer in self.layers:\n            if reference_points.shape[-1] == 3:\n                reference_points_input = reference_points[:, :, None] * src_valid_ratios[:, None]   # Only have refererence points in valid areas\n            else:\n                raise ValueError(\"Currently iterative bbox refinement is not implemented.\")\n\n            output = layer(output, query_pos, reference_points_input, src, src_spatial_shapes, src_level_start_index, src_padding_mask)\n\n            if self.return_intermediate:\n                intermediate.append(output)\n                intermediate_reference_points.append(reference_points)\n\n        if self.return_intermediate:\n            return torch.stack(intermediate), torch.stack(intermediate_reference_points)\n\n        return output, reference_points\n","AFTER":"    def forward(self, tgt, src, src_spatial_shapes, src_level_start_index, lvl_pos, query_pos=None):\n        output = tgt\n\n        intermediate = []\n        for layer in self.layers:\n            output = layer(output, query_pos, lvl_pos, src, src_spatial_shapes, src_level_start_index)\n\n            if self.return_intermediate:\n                intermediate.append(output)\n\n        if self.return_intermediate:\n            return torch.stack(intermediate)\n\n        return output\n"}