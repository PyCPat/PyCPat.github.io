{"BEFORE":"        self.stride = stride\n        self.padding = padding\n        self.dilation = dilation\n        if in_channels % groups != 0:\n            raise ValueError(\"in_channels must be divisible by groups.\")\n        self.groups = groups\n\n        filter_shape = [out_channels, in_channels \/\/ groups, kernel_size, kernel_size]\n\n        self.weight = torch.nn.Parameter(torch.randn(filter_shape))\n        self.bias = None\n        if bias:\n            self.bias = torch.nn.Parameter(torch.randn(out_channels, ))\n\n    def forward(self, x, offset, mask):\n","AFTER":"        assert groups == 1\n        if in_channels % groups != 0:\n            raise ValueError(\"in_channels must be divisible by groups.\")\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = _pair(kernel_size)\n        self.stride = _pair(stride)\n        self.padding = _pair(padding)\n        self.dilation = _pair(dilation)\n        self.groups = groups\n\n        self.weight = torch.nn.Parameter(torch.randn(out_channels, in_channels \/\/ groups, self.kernel_size[0], self.kernel_size[1]))\n        torch.nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        self.bias = None\n        if bias:\n            self.bias = torch.nn.Parameter(torch.randn(out_channels, ))\n            fan_in, _ = torch.nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 \/ math.sqrt(fan_in)\n            torch.nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x, offset, mask):\n"}