{"BEFORE":"        self.disc = nn.Sequential(OrderedDict([\n            # input: N x channels_img x 64 x 64\n            ('conv_in', nn.Conv2d(\n                channels_img, features_d, kernel_size=4,\n                stride=2, padding=1, bias=False\n            )),\n            ('leaky_relu', nn.LeakyReLU(0.2)),\n            # _block(in_channels, out_channels, kernel_size, stride, padding)\n            ('block1', self._block(features_d, features_d * 2, 4, 2, 1)),\n            ('block2', self._block(features_d * 2, features_d * 4, 4, 2, 1)),\n            ('block3', self._block(features_d * 4, features_d * 8, 4, 2, 1)),\n            # After all _block img output is 4x4 (Conv2d below makes into 1x1)\n            ('conv_out', nn.Conv2d(features_d * 8, 1, kernel_size=4,\n                stride=2, padding=0, bias=False)),\n            ('sigmoid', nn.Sigmoid()) if final_sigmoid\\\n                    else ('identity', nn.Identity())\n            ]))\n","AFTER":"            norm=\"batch_norm\", img_size=64, final_sigmoid=True):\n        super(Discriminator, self).__init__()\n        self.norm = norm\n        n_blocks = int(math.log2(img_size\/\/8))\n        block_list = [\n            (f'block{i}', self._block(features_d*(2**(i-1)), features_d*(2**i),\n                4, 2, 1))\n            for i in range(1,n_blocks+1)]\n        full_list = [\n            ('conv_in', nn.Conv2d(\n                channels_img, features_d, kernel_size=4,\n                stride=2, padding=1, bias=False\n            )),\n            ('leaky_relu', nn.LeakyReLU(0.2)),\n            *block_list,\n            # After all _block img output is 4x4 (Conv2d below makes into 1x1)\n            ('conv_out', nn.Conv2d(features_d * 8, 1, kernel_size=4,\n                stride=2, padding=0, bias=False)),\n            ('sigmoid', nn.Sigmoid()) if final_sigmoid\\\n                    else ('identity', nn.Identity())\n            ]\n        self.disc = nn.Sequential(OrderedDict(full_list))\n"}