{"BEFORE":"        trees = []\n\n        # when we're reading trees off the chart, don't use incomplete edges\n        if complete and edge.is_incomplete():\n            return trees\n\n        # Until we're done computing the trees for edge, set\n        # memo[edge] to be empty.  This has the effect of filtering\n        # out any cyclic trees (i.e., trees that contain themselves as\n        # descendants), because if we reach this edge via a cycle,\n        # then it will appear that the edge doesn't generate any\n        # trees.\n        memo[edge] = []\n\n        # Leaf edges.\n        if isinstance(edge, LeafEdge):\n            leaf = self._tokens[edge.start()]\n            memo[edge] = leaf\n            return [leaf]\n\n        # Each child pointer list can be used to form trees.\n        for cpl in self.child_pointer_lists(edge):\n            # Get the set of child choices for each child pointer.\n            # child_choices[i] is the set of choices for the tree's\n            # ith child.\n            child_choices = [self._trees(cp, complete, memo, tree_class)\n                             for cp in cpl]\n\n            # For each combination of children, add a tree.\n            for children in self._choose_children(child_choices):\n                lhs = edge.lhs().symbol()\n                trees.append(tree_class(lhs, children))\n\n        # If the edge is incomplete, then extend it with \"partial trees\":\n        if edge.is_incomplete():\n            unexpanded = [tree_class(elt,[])\n                          for elt in edge.rhs()[edge.dot():]]\n            for tree in trees:\n                tree.extend(unexpanded)\n\n        # Update the memoization dictionary.\n        memo[edge] = trees\n\n        # Return the list of trees.\n        return trees\n","AFTER":"            return []\n\n        # Leaf edges.\n        if isinstance(edge, LeafEdge):\n            leaf = self._tokens[edge.start()]\n            memo[edge] = [leaf]\n            return [leaf]\n\n        # Until we're done computing the trees for edge, set\n        # memo[edge] to be empty.  This has the effect of filtering\n        # out any cyclic trees (i.e., trees that contain themselves as\n        # descendants), because if we reach this edge via a cycle,\n        # then it will appear that the edge doesn't generate any trees.\n        memo[edge] = []\n        trees = []\n        lhs = edge.lhs().symbol()\n"}