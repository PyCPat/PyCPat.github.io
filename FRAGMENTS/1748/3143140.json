{"BEFORE":"        sections = []\n        conv1d = []\n\n        if type(in_channels) is int:\n            assert groups is not None, \"Specify groups\"\n            assert in_channels % groups == 0, \"`in_channels` must be divisible by `groups`\"\n\n            self.groups = groups\n            _in_channels = in_channels \/\/ groups\n\n            for idx in range(groups):\n                dilation = 2**idx\n                self.dilations.append(dilation)\n                sections.append(_in_channels)\n                conv1d.append(nn.Conv1d(_in_channels, out_channels, kernel_size=kernel_size, stride=1, dilation=dilation))\n        elif type(in_channels) is list:\n            self.groups = len(in_channels)\n            for idx, _in_channels in enumerate(in_channels):\n                dilation = 2**idx\n                self.dilations.append(dilation)\n                sections.append(_in_channels)\n                conv1d.append(nn.Conv1d(_in_channels, out_channels, kernel_size=kernel_size, stride=1, dilation=dilation))\n        else:\n            raise ValueError(\"Not support `in_channels`={}\".format(in_channels))\n        \n        self.sections = sections\n        self.conv1d = nn.ModuleList(conv1d)\n","AFTER":"        self.sections = []\n        weights = []\n        biases = []\n\n        if type(in_channels) is int:\n            assert groups is not None, \"Specify groups\"\n            assert in_channels % groups == 0, \"`in_channels` must be divisible by `groups`\"\n\n            self.groups = groups\n            _in_channels = in_channels \/\/ groups\n\n            for idx in range(groups):\n                dilation = 2**idx\n                self.dilations.append(dilation)\n                self.sections.append(_in_channels)\n                weights.append(torch.Tensor(out_channels, _in_channels, kernel_size))\n                biases.append(torch.Tensor(out_channels,))\n        elif type(in_channels) is list:\n            self.groups = len(in_channels)\n            for idx, _in_channels in enumerate(in_channels):\n                dilation = 2**idx\n                self.dilations.append(dilation)\n                self.sections.append(_in_channels)\n                weights.append(torch.Tensor(out_channels, _in_channels, kernel_size))\n                biases.append(torch.Tensor(out_channels,))\n        else:\n            raise ValueError(\"Not support `in_channels`={}\".format(in_channels))\n        \n        weights = torch.cat(weights, dim=1)\n        biases = torch.cat(biases, dim=0)\n        self.weights = nn.Parameter(weights)\n        self.biases = nn.Parameter(biases)\n"}