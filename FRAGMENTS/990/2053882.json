{"BEFORE":"    def __init__(self):\n\n        super(QuartzNet, self).__init__()\n\n        self.in_channels = 80\n        self.channels = [256, 256, 256, 512, 512, 512, 512, 1024, 29]\n        self.k = [33, 39, 51, 63, 75, 87, 1, 1]\n        self.n_blocks = 5\n\n        self.conv1 = nn.Sequential(nn.Conv1d(self.in_channels, self.channels[0], kernel_size=self.k[0], stride=[1], padding=self.k[0]\/\/2),\n                                   nn.BatchNorm1d(self.channels[0], eps=0.001, momentum=0.1, affine=True, track_running_stats=True),\n                                   nn.ReLU(),\n                                   nn.Dropout(p=0.2, inplace=False))\n\n        self.blocks = nn.ModuleList([])\n        for i in range(self.n_blocks):\n            pad = self.k[i] \/\/ 2\n            self.blocks.append(JasperBlock(self.channels[i], self.channels[i+1], self.k[i], pad))\n\n        self.conv2 = nn.Sequential(nn.Conv1d(self.channels[5], self.channels[6], kernel_size=87, padding=86, dilation=2),\n                                   nn.BatchNorm1d(self.channels[6], eps=0.001, momentum=0.1, affine=True, track_running_stats=True),\n                                   nn.ReLU(),\n                                   nn.Dropout(p=0.2, inplace=False))\n        self.conv3 = nn.Sequential(nn.Conv1d(self.channels[6], self.channels[7], kernel_size=1),\n                                   nn.BatchNorm1d(self.channels[7], eps=0.001, momentum=0.1, affine=True, track_running_stats=True),\n                                   nn.ReLU(),\n                                   nn.Dropout(p=0.2, inplace=False))\n        self.conv4 = nn.Conv1d(self.channels[7], self.channels[8], kernel_size=1)\n","AFTER":"    def __init__(self, repeat, in_channels, out_channels):\n\n        super(QuartzNet, self).__init__()\n\n        block_channels = [256, 256, 512, 512, 512, 512]\n        block_k = [33, 39, 51, 63, 75]\n\n        self.C1 = nn.Sequential(nn.Conv1d(in_channels, 256, kernel_size=33, padding=16, bias=False),\n                                nn.BatchNorm1d(256, eps=0.001, momentum=0.1, affine=True, track_running_stats=True),\n                                nn.ReLU(),\n                                nn.Dropout(p=0.2, inplace=False))\n\n        self.B = nn.ModuleList([])\n\n        for i in range(5):\n            pad = block_k[i] \/\/ 2\n            for rep in range(repeat):\n                self.B.append(JasperBlock(block_channels[i], block_channels[i+1], block_k[i], pad))\n\n        self.C2 = nn.Sequential(nn.Conv1d(512, 512, kernel_size=87, padding=86, dilation=2),\n                                nn.BatchNorm1d(512, eps=0.001, momentum=0.1, affine=True, track_running_stats=True),\n                                nn.ReLU(),\n                                nn.Dropout(p=0.2, inplace=False))\n\n        self.C3 = nn.Sequential(nn.Conv1d(512, 1024, kernel_size=1),\n                                nn.BatchNorm1d(1024, eps=0.001, momentum=0.1, affine=True, track_running_stats=True),\n                                nn.ReLU(),\n                                nn.Dropout(p=0.2, inplace=False))\n\n        self.C4 = nn.Conv1d(1024, out_channels, kernel_size=1)\n"}