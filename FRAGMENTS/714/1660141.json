{"BEFORE":"        bn_epsilon: float = None,\n        bn_momentum: float = None,\n        normalizer_fn: nn.Module = nn.BatchNorm2d,\n        activation_fn: nn.Module = None\n    ):\n        super().__init__()\n\n        bn_epsilon = bn_epsilon if bn_epsilon else _BN_EPSILON\n        bn_momentum = bn_momentum if bn_momentum else _BN_MOMENTUM\n        activation_fn = activation_fn if activation_fn else _NONLINEAR\n\n        width = int(oup * (width_per_group \/ 64)) * groups\n\n        self.has_se = se_ratio is not None and se_ratio > 0 and se_ratio <= 1\n        self.use_shortcut = stride != 1 or inp != oup * self.expansion\n\n        self.branch1 = nn.Sequential(OrderedDict([\n            ('norm1', normalizer_fn(inp, eps=bn_epsilon, momentum=bn_momentum)),\n            ('relu1', activation_fn(inplace=True)),\n            ('conv1', Conv2d1x1(inp, width)),\n            ('norm2', normalizer_fn(width, eps=bn_epsilon, momentum=bn_momentum)),\n            ('relu2', activation_fn(inplace=True)),\n            ('conv2', Conv2d3x3(width, width, stride=stride, groups=groups)),\n            ('norm3', normalizer_fn(width, eps=bn_epsilon, momentum=bn_momentum)),\n            ('relu3', activation_fn(inplace=True)),\n            ('conv3', Conv2d1x1(width, oup * self.expansion))\n        ]))\n\n        if self.has_se:\n            self.branch1.add_module('se', SEBlock(\n                oup * self.expansion, se_ratio))\n\n        if drop_connect_rate:\n            self.branch1.add_module('drop', DropPath(drop_connect_rate))\n","AFTER":"        normalizer_fn = normalizer_fn or _NORMALIZER\n        activation_fn = activation_fn or _NONLINEAR\n\n        width = int(oup * (width_per_group \/ 64)) * groups\n\n        self.has_se = se_ratio is not None and se_ratio > 0 and se_ratio <= 1\n        self.use_shortcut = stride != 1 or inp != oup * self.expansion\n\n        self.branch1 = nn.Sequential(OrderedDict([\n            ('norm1', normalizer_fn(inp)),\n            ('relu1', activation_fn()),\n            ('conv1', Conv2d1x1(inp, width)),\n            ('norm2', normalizer_fn(width)),\n            ('relu2', activation_fn()),\n            ('conv2', Conv2d3x3(width, width, stride=stride, groups=groups)),\n            ('norm3', normalizer_fn(width)),\n            ('relu3', activation_fn()),\n            ('conv3', Conv2d1x1(width, oup * self.expansion))\n        ]))\n\n        if self.has_se:\n            self.branch1.add_module('se', SEBlock(\n                oup * self.expansion, se_ratio))\n\n        if drop_path_rate:\n            self.branch1.add_module('drop', DropPath(1. - drop_path_rate))\n"}