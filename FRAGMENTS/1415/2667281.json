{"BEFORE":"        conv_next = partial(ConvNextBlock, time_emb_dim = time_dim)\n","AFTER":"        cond_dim = None,\n        out_dim = None,\n        dim_mults=(1, 2, 4, 8),\n        channels = 3\n    ):\n        super().__init__()\n        self.channels = channels\n\n        dims = [channels, *map(lambda m: dim * m, dim_mults)]\n        in_out = list(zip(dims[:-1], dims[1:]))\n\n        time_dim = dim\n        self.time_mlp = nn.Sequential(\n            SinusoidalPosEmb(dim),\n            nn.Linear(dim, dim * 4),\n            nn.GELU(),\n            nn.Linear(dim * 4, dim)\n        )\n\n        self.has_cond = exists(cond_dim)\n        self.null_cond_emb = nn.Parameter(torch.randn(1, cond_dim)) if self.has_cond else None\n\n        cond_dim = time_dim + int(cond_dim)\n\n        self.downs = nn.ModuleList([])\n        self.ups = nn.ModuleList([])\n\n        num_resolutions = len(in_out)\n        conv_next = partial(ConvNextBlock, time_emb_dim = cond_dim)\n"}