{"BEFORE":"        self.pre_layers = nn.ModuleList([\n            PreNorm(dim, Attention(dim = dim, dim_head = dim_head, heads = heads, causal = causal)),\n            PreNorm(dim, FeedForward(dim = dim, mult = ff_mult))\n        ])\n\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                PreNorm(dim, Attention(dim = dim, dim_head = dim_head, heads = heads, causal = causal, groups = num_streams), groups = num_streams),\n                PreNorm(dim, FeedForward(dim = dim, mult = ff_mult, groups = num_streams), groups = num_streams)\n            ]))\n\n        self.query = nn.Parameter(torch.randn(dim))\n        self.attn_pool = Attention(dim = dim, dim_head = dim_head, heads = heads)\n\n        self.post_layers = nn.ModuleList([\n            PreNorm(dim, Attention(dim = dim, dim_head = dim_head, heads = heads, causal = causal)),\n            PreNorm(dim, FeedForward(dim = dim, mult = ff_mult))\n        ])\n","AFTER":"        self.dim = dim\n        self.max_seq_len = max_seq_len\n        self.num_streams = num_streams\n        self.token_emb = nn.Embedding(num_tokens, dim)\n        self.pos_emb = nn.Embedding(max_seq_len, dim)\n\n        self.layers = nn.ModuleList([])\n\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                PreNorm(dim, Attention(dim = dim, dim_head = dim_head, heads = heads, causal = causal, groups = num_streams), groups = num_streams),\n                PreNorm(dim, FeedForward(dim = dim, mult = ff_mult, groups = num_streams), groups = num_streams)\n            ]))\n\n        if num_streams > 1:\n            self.query = nn.Parameter(torch.randn(dim))\n            self.attn_pool = Attention(dim = dim, dim_head = dim_head, heads = heads)\n\n        self.to_logits = nn.Sequential(\n"}