{"BEFORE":"        backend = kwargs.pop('backend', 'numpy')\n        out = kwargs.pop('out', None)\n        if kwargs:\n            raise ValueError(\"The only valid keyword arguments to a `ContractExpression` \"\n                             \"call are `out=` or `backend=`. Got: %s.\" % kwargs)\n\n        try:\n            # Check if the backend requires special preparation \/ calling\n            #   but also ignore non-numpy arrays -> assume user wants same type back\n            if backend in backends.CONVERT_BACKENDS and isinstance(arrays[0], np.ndarray):\n                return self._convert_contract(arrays, out, backend)\n\n            return self._normal_contract(arrays, out, backend)\n\n        except ValueError as err:\n            original_msg = str(err.args) if err.args else \"\"\n            msg = (\"Internal error while evaluating `ContractExpression`. Note that few checks are performed\"\n                   \" - the number and rank of the array arguments must match the original expression. \"\n                   \"The internal error was: '%s'\" % original_msg, )\n            err.args = msg\n            raise\n\n    def __repr__(self):\n","AFTER":"        out = kwargs.pop('out', None)\n        backend = kwargs.pop('backend', 'numpy')\n        parse_constants = kwargs.pop('parse_constants', False)\n        if kwargs:\n            raise ValueError(\"The only valid keyword arguments to a `ContractExpression` \"\n                             \"call are `out=` or `backend=`. Got: %s.\" % kwargs)\n\n        if self.constants:\n            # fill in the missing non-constant terms with newly supplied arrays\n            arrays = iter(arrays)\n            arrays = [next(arrays) if op is None else op for op in self.constants]\n\n        try:\n"}