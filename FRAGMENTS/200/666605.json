{"BEFORE":"        assert (n_blocks >= 0)\n        super(Generator, self).__init__()\n        self.ngf = ngf\n        self.n_blocks = n_blocks\n\n        DownBlock = []\n        DownBlock += [nn.ReflectionPad2d(3),\n                      nn.Conv2d(3, ngf, kernel_size=7, stride=1, padding=0, bias=False),\n                      nn.InstanceNorm2d(ngf),\n                      nn.ReLU(True)]\n\n        # Down-Sampling\n        n_downsampling = 2\n        for i in range(n_downsampling):\n            mult = 2 ** i\n            DownBlock += [nn.ReflectionPad2d(1),\n                          nn.Conv2d(ngf * mult, ngf * mult * 2, kernel_size=3, stride=2, padding=0, bias=False),\n                          nn.InstanceNorm2d(ngf * mult * 2),\n                          nn.ReLU(True)]\n\n        # Down-Sampling Bottleneck\n        mult = 2 ** n_downsampling\n        for i in range(n_blocks):\n            DownBlock += [ResnetBlock(ngf * mult, use_bias=False)]\n\n        # Class Activation Map\n        self.gap_fc = nn.Linear(ngf * mult, 1, bias=False)\n        self.gmp_fc = nn.Linear(ngf * mult, 1, bias=False)\n        self.conv1x1 = nn.Conv2d(ngf * mult * 2, ngf * mult, kernel_size=1, stride=1, bias=True)\n        self.relu = nn.ReLU(True)\n\n        # Gamma, Beta block\n        FC = [nn.Linear(ngf * mult, ngf * mult, bias=False),\n              nn.ReLU(True),\n              nn.Linear(ngf * mult, ngf * mult, bias=False),\n              nn.ReLU(True)]\n\n        self.gamma = nn.Linear(ngf * mult, ngf * mult, bias=False)\n        self.beta = nn.Linear(ngf * mult, ngf * mult, bias=False)\n\n        # Up-Sampling Bottleneck\n        for i in range(n_blocks):\n            setattr(self, 'UpBlock1_' + str(i + 1), ResnetAdaILNBlock(ngf * mult, use_bias=False))\n\n        # Up-Sampling\n        UpBlock2 = []\n        for i in range(n_downsampling):\n            mult = 2 ** (n_downsampling - i)\n            UpBlock2 += [nn.Upsample(scale_factor=2, mode='nearest'),\n                         nn.ReflectionPad2d(1),\n                         nn.Conv2d(ngf * mult, int(ngf * mult \/ 2), kernel_size=3, stride=1, padding=0, bias=False),\n                         ILN(int(ngf * mult \/ 2)),\n","AFTER":"        super(FastGenerator, self).__init__()\n        self.ngf = ngf\n        self.n_blocks = n_blocks\n        DownBlock = []\n        DownBlock += [nn.ReflectionPad2d(3),\n                      nn.Conv2d(3, ngf, kernel_size=7, stride=1, padding=0, bias=False),\n                      nn.InstanceNorm2d(ngf),\n                      nn.ReLU(True)]\n\n        n_downsampling = 2\n        for i in range(n_downsampling):\n            DownBlock += [nn.ReflectionPad2d(1),\n                          nn.Conv2d(ngf, ngf, kernel_size=3, stride=2, padding=0, bias=False),\n                          nn.InstanceNorm2d(ngf),\n                          nn.ReLU(True)]\n\n        # Bottleneck\n        for i in range(n_blocks):\n            DownBlock += [InvertedResidual(ngf, ngf, 1, 6)]\n\n        # Class Activation Map\n        self.gap_fc = nn.Linear(ngf, 1, bias=False)\n        self.gmp_fc = nn.Linear(ngf, 1, bias=False)\n        self.conv1x1 = nn.Conv2d(ngf * 2, ngf, kernel_size=1, stride=1, bias=True)\n        self.relu = nn.ReLU(True)\n\n        # Gamma, Beta block\n        FC = [nn.Linear(ngf, ngf, bias=False),\n              nn.ReLU(True),\n              nn.Linear(ngf, ngf, bias=False),\n              nn.ReLU(True)]\n\n        self.gamma = nn.Linear(ngf, ngf, bias=False)\n        self.beta = nn.Linear(ngf, ngf, bias=False)\n\n        # Up-Sampling Bottleneck\n        for i in range(n_blocks):\n            setattr(self, 'UpBlock1_' + str(i + 1), AdaLINInvertedResidual(ngf, ngf, 1, 1))\n\n        # Up-Sampling\n        UpBlock2 = []\n        for i in range(n_downsampling):\n            UpBlock2 += [nn.Upsample(scale_factor=2, mode='nearest'),\n                         nn.ReflectionPad2d(1),\n                         nn.Conv2d(ngf, int(ngf \/ 2), kernel_size=3, stride=1, padding=0, bias=False),\n                         ILN(int(ngf \/ 2)),\n                         nn.ReLU(True)]\n            ngf = int(ngf \/ 2)\n"}