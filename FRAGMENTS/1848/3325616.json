{"BEFORE":"        assert mix_mode in [\n            \"mixup\", \"manifoldmix\", \"cutmix\", \"saliencymix\", \"resizemix\", \"fmix\"]\n        if mix_mode in [\"manifoldmix\"]:\n            assert 0 == min(mix_args[mix_mode][\"layer\"]) and max(mix_args[mix_mode][\"layer\"]) < 4\n        if mix_mode == \"resizemix\":\n            assert 0 <= min(mix_args[mix_mode][\"scope\"]) and max(mix_args[mix_mode][\"scope\"]) <= 1\n        self.mix_mode = mix_mode\n        self.alpha = alpha\n","AFTER":"                 mix_prob=None,\n                 p_mix_cutoff=0.95,\n                 label_rescale='labeled',\n                 lam_bias='labeled',\n                 loss_weights=dict(\n                    decent_weight=[],\n                    accent_weight=['weight_mix_lu'],\n                    weight_one=1, weight_mix_ll=1, weight_mix_lu=1),\n                 deduplicate=False,\n                 pretrained=None):\n        super(DMixMatch, self).__init__()\n        # network settings\n        self.encoder = nn.Sequential(\n            builder.build_backbone(backbone), builder.build_head(head))\n        self.encoder_k = nn.Sequential(  # EMA\n            builder.build_backbone(backbone), builder.build_head(head))\n        for param in self.encoder_k.parameters():\n            param.requires_grad = False\n        self.head_mix = None\n        if head_mix is not None:\n            self.head_mix = builder.build_head(head_mix)\n            self.head_mix_k = builder.build_head(head_mix)\n            for param in self.head_mix_k.parameters():\n                param.requires_grad = False\n        self.init_weights(pretrained=pretrained)\n\n        # FixMatch args\n        self.momentum = float(momentum)\n        self.base_momentum = float(momentum)\n        self.temperature = float(temperature)\n        self.p_cutoff = float(p_cutoff)\n        self.weight_ul = float(weight_ul)\n        self.hard_label = bool(hard_label)\n        self.ratio_ul = int(ratio_ul)\n        self.ema_pseudo = float(ema_pseudo)\n        self.deduplicate = bool(deduplicate)\n        assert 1 <= ratio_ul and 0 < p_cutoff <= 1\n\n        # mixup args\n        self.mix_mode = mix_mode if isinstance(mix_mode, list) else [str(mix_mode)]\n        for _mode in self.mix_mode:\n            assert _mode in [\"vanilla\", \"mixup\", \"manifoldmix\", \"cutmix\", \"saliencymix\", \"resizemix\", \"fmix\"]\n            if _mode == \"manifoldmix\":\n                assert 0 <= min(mix_args[_mode][\"layer\"]) and max(mix_args[_mode][\"layer\"]) < 4\n            if _mode == \"resizemix\":\n                assert 0 <= min(mix_args[_mode][\"scope\"]) and max(mix_args[_mode][\"scope\"]) <= 1\n        self.alpha = alpha if isinstance(alpha, list) else [float(alpha)]\n        assert len(self.alpha) == len(self.mix_mode) and len(self.mix_mode) < 6\n        self.idx_list = [i for i in range(len(self.mix_mode))]\n        self.mix_args = mix_args\n        self.mix_prob = mix_prob if isinstance(mix_prob, list) else None\n        if self.mix_prob is not None:\n            assert len(self.mix_prob) == len(self.alpha) and abs(sum(self.mix_prob)-1e-10) <= 1, \\\n                \"mix_prob={}, sum={}, alpha={}\".format(self.mix_prob, sum(self.mix_prob), self.alpha)\n            for i in range(1, len(self.mix_prob)):\n                self.mix_prob[i] = self.mix_prob[i] + self.mix_prob[i-1]\n        assert label_rescale in ['labeled', 'unlabeled', 'both', 'none']\n"}