{"BEFORE":"        self.output_layers = output_layers\n\n        # we need to multiply by this to be able to fit the signal\n        if len(input_scales) != n_layers+1:\n            raise ValueError('require n+1 scales for n hidden_layers')\n        input_scales = [[round((np.pi*freq*s)\/quantization_interval) * \\\n                         quantization_interval\n                         for freq in frequency] for s in input_scales]\n\n        self.filters = nn.ModuleList([\n                        GaborLayer_Bacon(in_size, hidden_size,\n                                         input_scales[i]\/np.sqrt(n_layers+1),\n                                         alpha\/(n_layers+1),\n                                         quantization_interval)\n                        for i in range(n_layers+1)])\n        self.linear = nn.ModuleList(\n            [nn.Linear(hidden_size, hidden_size) for _ in range(n_layers)])\n        # linear layers to extract intermediate outputs\n        self.output_linear = nn.ModuleList(\n            [nn.Sequential(nn.Linear(hidden_size, out_size),\n                           nn.Sigmoid()) \n             for _ in range(len(self.output_layers))])\n        self.linear.apply(mfn_weights_init)\n        self.output_linear.apply(mfn_weights_init)\n","AFTER":"        self.n_layers = n_layers\n        self.output_layers = output_layers\n\n        # we need to multiply by this to be able to fit the signal\n        input_scales = [[round((np.pi*freq*s)\/quantization_interval) * \\\n                         quantization_interval\n                         for freq in frequency] for s in input_scales]\n\n        self.filters = nn.ModuleList([\n                        GaborLayer_Bacon(in_size, hidden_size,\n                                         input_scales[i]\/np.sqrt(n_layers+1),\n                                         alpha\/(n_layers+1),\n                                         quantization_interval)\n                        for i in range(n_layers+1)])\n        self.linear = nn.ModuleList(\n            [nn.Linear(hidden_size, hidden_size) for _ in range(n_layers)])\n        self.linear.apply(mfn_weights_init)\n\n        self.out = \\\n            nn.Sequential(nn.Linear(hidden_size, out_size), nn.Sigmoid()) \n            \n        # make the final layer (after sigmoid) \"almost\" uniform in [0, 1]\n        # TODO: find the math formula...\n        nn.init.uniform_(self.out[0].weight,\n                         -6\/hidden_size**0.5, 6\/hidden_size**0.5)\n"}