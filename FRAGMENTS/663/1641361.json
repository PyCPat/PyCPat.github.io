{"BEFORE":"        self, input_dims: Tuple, num_blocks=3, num_block_features=16, num_block_convs=4\n    ):\n\n        super().__init__()\n\n        self.input_dims = input_dims\n\n        features: OrderedDict[str, nn.Module] = OrderedDict(\n            [\n                (\"data_enc_init_pool\", nn.MaxPool3d(kernel_size=2, stride=2)),\n                (\n                    \"data_enc_init_conv\",\n                    nn.Conv3d(\n                        in_channels=input_dims[0],\n                        out_channels=32,\n                        kernel_size=3,\n                        stride=1,\n                        padding=1,\n                    ),\n                ),\n                (\"data_enc_init_conv_relu\", nn.ReLU()),\n            ]\n        )\n\n        out_features = 32\n        for idx in range(num_blocks - 1):\n            in_features = out_features\n\n            # Dense block\n            features[f\"dense_block_{idx}\"] = DenseBlock(\n                in_features,\n                num_block_features=num_block_features,\n                num_block_convs=num_block_convs,\n                tag=idx,\n            )\n\n            # Number of output features from dense block\n            print(type(features[f\"dense_block_{idx}\"]))\n","AFTER":"        num_blocks: int = 3,\n        num_block_features: int = 16,\n        num_block_convs: int = 4,\n    ) -> None:\n\n        super().__init__()\n\n        self.input_dims = input_dims\n\n        features: OrderedDict[str, nn.Module] = OrderedDict(\n            [\n                (\"data_enc_init_pool\", nn.MaxPool3d(kernel_size=2, stride=2)),\n                (\n                    \"data_enc_init_conv\",\n                    nn.Conv3d(\n                        in_channels=input_dims[0],\n                        out_channels=32,\n                        kernel_size=3,\n                        stride=1,\n                        padding=1,\n                    ),\n                ),\n                (\"data_enc_init_conv_relu\", nn.ReLU()),\n            ]\n        )\n\n        out_features = 32\n        for idx in range(num_blocks - 1):\n            in_features = out_features\n\n            # Dense block\n            features[f\"dense_block_{idx}\"] = DenseBlock(\n                in_features,\n                num_block_features=num_block_features,\n                num_block_convs=num_block_convs,\n                tag=idx,\n            )\n\n            # Number of output features from dense block\n            out_features = features[f\"dense_block_{idx}\"].out_features()\n\n            features[f\"data_enc_level{idx}_bottleneck\"] = nn.Conv3d(\n                in_channels=out_features,\n                out_channels=out_features,\n                kernel_size=1,\n                padding=0,\n            )\n            features[f\"data_enc_level{idx}_bottleneck_relu\"] = nn.ReLU()\n            features[f\"data_enc_level{idx+1}_pool\"] = nn.MaxPool3d(\n                kernel_size=2, stride=2\n            )\n\n        in_features = out_features\n        features[f\"dense_block_{num_blocks-1}\"] = DenseBlock(\n            in_features,\n            num_block_features=num_block_features,\n            num_block_convs=num_block_convs,\n            tag=num_blocks - 1,\n        )\n\n        # Final number of channels\n        self.features_out_size = features[f\"dense_block_{num_blocks-1}\"].out_features()\n\n        # Final spatial dimensions (pre-global pooling)\n        D = input_dims[1] \/\/ 2 ** num_blocks\n        H = input_dims[2] \/\/ 2 ** num_blocks\n        W = input_dims[3] \/\/ 2 ** num_blocks\n\n        # Global MAX pooling\n        # Redices spatial dimension to a single number per channel\n        features[f\"data_enc_level{num_blocks-1}_global_pool\"] = nn.MaxPool3d(\n            kernel_size=((D, H, W))\n        )\n"}