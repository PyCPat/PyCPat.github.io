{"BEFORE":"        gru_dim: Union[int, List[int]],\n        widths: List[int],\n        fstrides: Optional[List[int]] = None,\n        initial_kernel: Tuple[int, int] = (3, 3),\n        kernel: Tuple[int, int] = (1, 3),\n        decoder_out_layer: Optional[Callable[[int, int], torch.nn.Module]] = None\n        # squeeze_exitation_factors: Optional[List[float]] = None,\n        # groups: int = 1,\n    ):\n        super().__init__()\n        self.fe = num_freqs  # Number of frequency bins in embedding\n        self.in_ch = in_ch\n        self.out_ch = out_ch\n        self.depth = len(widths) - 1\n        if fstrides is not None:\n            assert len(fstrides) >= self.depth\n            overall_stride = reduce(lambda x, y: x * y, fstrides)\n        else:\n            fstrides = [2] * self.depth\n            overall_stride = 2 ** (len(widths) - 1)\n        # if squeeze_exitation_factors is not None:\n        #     assert len(squeeze_exitation_factors) == self.depth\n        assert num_freqs % overall_stride == 0, f\"num_freqs ({num_freqs}) must correspond to depth\"\n        self.hd = gru_dim\n        norm_layer = nn.BatchNorm2d\n\n        self.enc0 = Conv2dNormAct(\n            in_ch, widths[0], initial_kernel, fstride=1, norm_layer=norm_layer\n        )\n        self.enc = nn.ModuleList()\n\n        if isinstance(gru_dim, int):\n            gru_dim = [gru_dim] * self.depth\n        fstrides = fstrides or [2] * self.depth\n        freqs = num_freqs\n        for i in range(self.depth):\n            in_ch = widths[i]\n            out_ch = widths[i + 1]\n            fstride = fstrides[i]\n            reduce_ = \"channels\" if i == 0 else \"frequencies\"\n            freqs = freqs \/\/ fstride\n            self.enc.append(\n                EncLayer(\n                    in_ch,\n                    out_ch,\n                    kernel,\n                    fstride,\n","AFTER":"        gru_dim: int,\n        widths: List[int],\n        fstrides: Optional[List[int]] = None,\n        initial_kernel: Tuple[int, int] = (3, 3),\n        kernel: Tuple[int, int] = (1, 3),\n        decoder_out_layer: Optional[Callable[[int, int], torch.nn.Module]] = None\n        # squeeze_exitation_factors: Optional[List[float]] = None,\n        # groups: int = 1,\n    ):\n        super().__init__()\n        self.fe = num_freqs  # Number of frequency bins in embedding\n        self.in_ch = in_ch\n        self.out_ch = out_ch\n        self.depth = len(widths) - 1\n        if fstrides is not None:\n            assert len(fstrides) >= self.depth\n            overall_stride = reduce(lambda x, y: x * y, fstrides)\n        else:\n            fstrides = [2] * self.depth\n            overall_stride = 2 ** (len(widths) - 1)\n        # if squeeze_exitation_factors is not None:\n        #     assert len(squeeze_exitation_factors) == self.depth\n        assert num_freqs % overall_stride == 0, f\"num_freqs ({num_freqs}) must correspond to depth\"\n        self.hd = gru_dim\n        norm_layer = nn.BatchNorm2d\n\n        self.enc0 = Conv2dNormAct(\n            in_ch, widths[0], initial_kernel, fstride=1, norm_layer=norm_layer\n        )\n        self.enc = nn.ModuleList()\n\n        # if isinstance(gru_dim, int):\n        #     gru_dim = [gru_dim] * self.depth\n        fstrides = fstrides or [2] * self.depth\n        freqs = num_freqs\n        for i in range(self.depth):\n            in_ch = widths[i]\n            out_ch = widths[i + 1]\n            fstride = fstrides[i]\n            freqs = freqs \/\/ fstride\n            self.enc.append(Conv2dNormAct(in_ch, out_ch, kernel_size=kernel, fstride=fstride))\n            # reduce_ = \"channels\" if i == 0 else \"frequencies\"\n            # self.enc.append(\n            #     EncLayer(\n            #         in_ch,\n            #         out_ch,\n            #         kernel,\n            #         fstride,\n            #         gru_dim=gru_dim[i],\n            #         gru_reduce=reduce_,\n            #         in_freqs=freqs,\n            #     )\n            # )\n        self.inner_ch = out_ch\n        self.gru = nn.GRU(freqs * out_ch, gru_dim, num_layers=3)\n        self.gru_fc = nn.Linear(gru_dim, freqs * out_ch)\n        self.gru_skip = nn.Conv2d(out_ch, out_ch, 1)\n"}