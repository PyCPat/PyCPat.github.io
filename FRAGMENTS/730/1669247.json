{"BEFORE":"        self.norm_layer = norm_layer\n        self.act = act_layer\n\n        self.in_channel = layer_infos[0].in_ch\n        self.final_stage_channel = layer_infos[-1].out_ch\n        self.out_channels = out_channels\n\n        self.cur_block = 0\n        self.num_block = sum(stage.num_layers for stage in layer_infos)\n        self.stochastic_depth = stochastic_depth\n\n        self.stem = ConvBNAct(3, self.in_channel, 3, 2, 1, self.norm_layer, self.act)\n        self.blocks = nn.Sequential(*self.make_stages(layer_infos, block))\n        self.head = ConvBNAct(self.final_stage_channel, out_channels, 1, 1, 1, self.norm_layer, self.act)\n        self.avg_pool = nn.AdaptiveAvgPool2d((1, 1))\n        self.dropout = nn.Dropout(p=dropout)\n","AFTER":"    def __init__(self, layer_infos, out_channels=1280, nclass=0, dropout=0.2, stochastic_depth=0.0, block=MBConv, act_layer=nn.SiLU, norm_layer=nn.BatchNorm2d):\n        super(EfficientNetV2, self).__init__()\n        self.layer_infos = layer_infos\n        self.norm_layer = norm_layer\n        self.act = act_layer\n\n        self.in_channel = layer_infos[0].in_ch\n        self.final_stage_channel = layer_infos[-1].out_ch\n        self.out_channels = out_channels\n\n        self.cur_block = 0\n        self.num_block = sum(stage.num_layers for stage in layer_infos)\n        self.stochastic_depth = stochastic_depth\n\n        self.stem = ConvBNAct(3, self.in_channel, 3, 2, 1, self.norm_layer, self.act)\n        self.blocks = nn.Sequential(*self.make_stages(layer_infos, block))\n        self.head = nn.Sequential(OrderedDict([\n            ('bottleneck', ConvBNAct(self.final_stage_channel, out_channels, 1, 1, 1, self.norm_layer, self.act)),\n            ('avgpool', nn.AdaptiveAvgPool2d((1, 1))),\n            ('flatten', nn.Flatten()),\n            ('dropout', nn.Dropout(p=dropout)),\n            ('classifier', nn.Linear(out_channels, nclass) if nclass else nn.Identity())\n        ]))\n"}