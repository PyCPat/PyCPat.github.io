{"BEFORE":"        super(Detect, self).__init__()\r\n        self.nc = nc  # number of classes\r\n        self.no = nc + 5  # number of outputs per anchor\r\n        self.nl = len(anchors)  # number of detection layers\r\n        self.na = len(anchors[0]) \/\/ 2  # number of anchors\r\n        self.grid = [torch.zeros(1)] * self.nl  # init grid\r\n        a = torch.tensor(anchors).float().view(self.nl, -1, 2)\r\n        self.register_buffer('anchors', a)  # shape(nl,na,2)\r\n        self.register_buffer('anchor_grid', a.clone().view(self.nl, 1, -1, 1, 1, 2))  # shape(nl,1,na,1,1,2)\r\n","AFTER":"    def __init__(self, nc=80, anchors=(), ch=(), inplace=True):  # detection layer\r\n        super().__init__()\r\n        self.nc = nc  # number of classes\r\n        self.no = nc + 5  # number of outputs per anchor\r\n        self.nl = len(anchors)  # number of detection layers\r\n        self.na = len(anchors[0]) \/\/ 2  # number of anchors\r\n        self.grid = [torch.zeros(1)] * self.nl  # init grid\r\n        self.anchor_grid = [torch.zeros(1)] * self.nl  # init anchor grid\r\n        self.register_buffer('anchors', torch.tensor(anchors).float().view(self.nl, -1, 2))  # shape(nl,na,2)\r\n        self.m = nn.ModuleList(nn.Conv2d(x, self.no * self.na, 1) for x in ch)  # output conv\r\n        self.inplace = inplace  # use in-place ops (e.g. slice assignment)\r\n"}