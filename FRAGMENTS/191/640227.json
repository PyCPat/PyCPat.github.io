{"BEFORE":"    def __init__(self,\n                 id: str,\n                 state_elements: Sequence[str],\n                 measure: Optional[str] = None,\n                 h_module: Optional[nn.Module] = None,\n                 h_tensor: Optional[Tensor] = None,\n                 h_kwarg: str = '',\n                 f_modules: Optional[nn.ModuleDict] = None,\n                 f_tensors: Optional[Dict[str, Tensor]] = None,\n                 f_kwarg: str = '',\n                 fixed_state_elements: Optional[List[str]] = None):\n\n        super(Process, self).__init__()\n        self.id = id\n\n        self._info: Tensor\n        self.register_buffer('_info', torch.empty(0), persistent=False)  # for dtype\/device info\n\n        # state elements:\n        self.state_elements = state_elements\n        self.se_to_idx = {se: i for i, se in enumerate(self.state_elements)}\n        assert len(state_elements) == len(self.se_to_idx), f\"state-elements are not unique:{state_elements}\"\n\n        # observation matrix:\n        if (int(h_module is None) + int(h_tensor is None)) != 1:\n            raise TypeError(\"Exactly one of `h_module`, `h_tensor` must be passed.\")\n        self.h_module = h_module\n        self.h_tensor: Tensor\n        self.register_buffer('h_tensor', h_tensor, persistent=False)  # so that `.to()` works\n        self.h_kwarg = h_kwarg\n\n        # transition matrix:\n        self.f_tensors = f_tensors\n        if isinstance(f_modules, dict):\n            f_modules = nn.ModuleDict(f_modules)\n        self.f_modules = f_modules\n        self.f_kwarg = f_kwarg\n","AFTER":"    def __init__(self,\n                 id: str,\n                 state_elements: Sequence[str],\n                 measure: Optional[str] = None,\n                 fixed_state_elements: Optional[List[str]] = None):\n\n        super(Process, self).__init__()\n        self.id = id\n\n        self._info: Tensor\n        self.register_buffer('_info', torch.empty(0), persistent=False)  # for dtype\/device info\n\n        # state elements:\n        self.state_elements = state_elements\n        self.se_to_idx = {se: i for i, se in enumerate(self.state_elements)}\n        assert len(state_elements) == len(self.se_to_idx), f\"state-elements are not unique:{state_elements}\"\n\n        # can be populated later, as long as it's before torch.jit.script\n        self.measure: str = '' if measure is None else measure\n\n        # elements without process covariance, defaults to none\n        self.fixed_state_elements: Optional[List[str]] = fixed_state_elements\n\n        # can\/should be overridden by subclasses:\n        self.expected_kwargs: Optional[List[str]] = None\n        self.f_modules: nn.ModuleDict = nn.ModuleDict()\n        self.f_tensors: Dict[str, torch.Tensor] = {}\n"}