{"BEFORE":"                x = pad(x)\n            return self.net(x, **kwargs)\n\n        if isinstance(x, torch.Tensor):\n            xi = x[:, :-1]\n            xo = x[:, 1:]\n\n            # help auto-solve an area of confusion around input masks in auto-regressive\n            # if user supplies a mask that is only off by one from the source sequence, resolve it for them\n            mask = kwargs.pop('mask', None)\n            if mask is not None and mask.shape[1] == x.shape[1]:\n                mask = mask[:, :-1]\n            kwargs.update(mask = mask)\n        else:\n            xi = pad(list(map(lambda t: t[:-1], x)))\n            xo = pad(list(map(lambda t: t[1:], x)))\n\n        out = self.net(xi, **kwargs)\n","AFTER":"        xi = x[:, :-1]\n        xo = x[:, 1:]\n\n        # help auto-solve an area of confusion around input masks in auto-regressive\n        # if user supplies a mask that is only off by one from the source sequence, resolve it for them\n        mask = kwargs.pop('mask', None)\n        if mask is not None and mask.shape[1] == x.shape[1]:\n            mask = mask[:, :-1]\n        kwargs.update(mask = mask)\n"}