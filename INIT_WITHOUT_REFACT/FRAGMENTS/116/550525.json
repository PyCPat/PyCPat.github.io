{"BEFORE":"        last_pad = 0\n        last_pad = self.model_cfg.get('last_pad', last_pad)\n\n        self.conv_out = spconv.SparseSequential(\n            # [200, 150, 5] -> [200, 150, 2]\n            spconv.SparseConv3d(64, 128, (3, 1, 1), stride=(2, 1, 1), padding=last_pad,\n                                bias=False, indice_key='spconv_down2'),\n            norm_fn(128),\n            nn.ReLU(),\n        )\n","AFTER":"        self.model_cfg = model_cfg\n        self.sparse_shape = grid_size[::-1] + [1, 0, 0]\n        self.voxel_size = voxel_size\n        self.point_cloud_range = point_cloud_range\n\n        norm_fn = partial(nn.BatchNorm1d, eps=1e-3, momentum=0.01)\n\n        self.conv_input = spconv.SparseSequential(\n            spconv.SubMConv3d(input_channels, 16, 3, padding=1, bias=False, indice_key='subm1'),\n            norm_fn(16),\n            nn.ReLU(),\n        )\n        block = post_act_block\n\n        self.conv1 = spconv.SparseSequential(\n            block(16, 16, 3, norm_fn=norm_fn, padding=1, indice_key='subm1'),\n        )\n\n        self.conv2 = spconv.SparseSequential(\n            # [1600, 1408, 41] <- [800, 704, 21]\n            block(16, 32, 3, norm_fn=norm_fn, stride=2, padding=1, indice_key='spconv2', conv_type='spconv'),\n            block(32, 32, 3, norm_fn=norm_fn, padding=1, indice_key='subm2'),\n            block(32, 32, 3, norm_fn=norm_fn, padding=1, indice_key='subm2'),\n        )\n\n        self.conv3 = spconv.SparseSequential(\n            # [800, 704, 21] <- [400, 352, 11]\n            block(32, 64, 3, norm_fn=norm_fn, stride=2, padding=1, indice_key='spconv3', conv_type='spconv'),\n            block(64, 64, 3, norm_fn=norm_fn, padding=1, indice_key='subm3'),\n            block(64, 64, 3, norm_fn=norm_fn, padding=1, indice_key='subm3'),\n        )\n\n        self.conv4 = spconv.SparseSequential(\n            # [400, 352, 11] <- [200, 176, 5]\n            block(64, 64, 3, norm_fn=norm_fn, stride=2, padding=(0, 1, 1), indice_key='spconv4', conv_type='spconv'),\n            block(64, 64, 3, norm_fn=norm_fn, padding=1, indice_key='subm4'),\n            block(64, 64, 3, norm_fn=norm_fn, padding=1, indice_key='subm4'),\n        )\n\n        if self.model_cfg.get('RETURN_ENCODED_TENSOR', True):\n            last_pad = self.model_cfg.get('last_pad', 0)\n\n            self.conv_out = spconv.SparseSequential(\n                # [200, 150, 5] -> [200, 150, 2]\n                spconv.SparseConv3d(64, 128, (3, 1, 1), stride=(2, 1, 1), padding=last_pad,\n                                    bias=False, indice_key='spconv_down2'),\n                norm_fn(128),\n                nn.ReLU(),\n            )\n        else:\n            self.conv_out = None\n\n        # decoder\n        # [400, 352, 11] <- [200, 176, 5]\n        self.conv_up_t4 = SparseBasicBlock(64, 64, indice_key='subm4', norm_fn=norm_fn)\n"}