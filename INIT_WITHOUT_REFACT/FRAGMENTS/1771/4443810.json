{"BEFORE":"        if backbone == 'vgg16':\n            from models.backbone.vgg_backbone import VGGBackbone\n            self.backbone = VGGBackbone(pretrained=True)\n            channels = (512, 512)\n            fea_channel = 256\n        elif backbone == 'repvgg':\n            from models.backbone.repvgg_backbone import REPVGGBackbone\n            self.backbone = REPVGGBackbone(pretrained=True)\n            channels = (384, 1408)\n            fea_channel = 256\n        elif backbone == 'resnet18':\n            from models.backbone.resnet_backbone import ResNetBackbone\n            self.backbone = ResNetBackbone(pretrained=True)\n            channels = (256, 512)\n            fea_channel = 256\n        elif backbone == 'shufflenet':\n            from models.backbone.shufflenet_backbone import ShuffleNetBackbone\n            self.backbone = ShuffleNetBackbone(pretrained=True)\n            channels = (232, 464)\n            fea_channel = 128\n        else:\n            raise ValueError('Error: Sorry backbone {} is not supported!'.format(backbone))\n\n        # Neck network\n        if neck == 'ssd':\n            from models.neck.ssd_neck import SSDNeck\n            self.neck = SSDNeck(self.fpn_level, channels, fea_channel)\n        elif neck == 'fpn':\n            from models.neck.fpn_neck import FPNNeck\n            self.neck = FPNNeck(self.fpn_level, channels, fea_channel)\n        elif neck == 'pafpn':\n            from models.neck.pafpn_neck import PAFPNNeck\n            self.neck = PAFPNNeck(self.fpn_level, channels, fea_channel)\n        else:\n            raise ValueError('Error: Sorry neck {} is not supported!'.format(neck))\n\n        # Detection Head\n\n        (self.loc, self.conf) = multibox(self.fpn_level, self.num_anchors, self.num_classes, fea_channel)\n\n        bias_value = 0\n        for modules in self.loc:\n            for l in modules.modules():\n                if isinstance(l, nn.Conv2d):\n                    torch.nn.init.normal_(l.weight, std=0.01)\n                    torch.nn.init.constant_(l.bias, bias_value)\n        import math\n        prior_prob = 0.01\n        bias_value = -math.log((1 - prior_prob) \/ prior_prob)\n        for modules in self.conf:\n            for l in modules.modules():\n                if isinstance(l, nn.Conv2d):\n                    torch.nn.init.normal_(l.weight, std=0.01)\n                    torch.nn.init.constant_(l.bias, bias_value)\n\n    def forward(self, x):\n","AFTER":"        if backbone == 'resnet18':\n            from models.backbone.resnet_backbone import ResNetBackbone\n            self.backbone = ResNetBackbone(depth=18, pretrained=True)\n            channels = (256, 512)\n            self.fea_channel = 256\n        elif backbone == 'resnet34':\n            from models.backbone.resnet_backbone import ResNetBackbone\n            self.backbone = ResNetBackbone(depth=34, pretrained=True)\n            channels = (256, 512)\n            self.fea_channel = 256\n        elif backbone == 'repvgg-A0':\n            from models.backbone.repvgg_backbone import REPVGGBackbone\n            self.backbone = REPVGGBackbone(version='A0', pretrained=True)\n            channels = (192, 1280)\n            self.fea_channel = 256\n        elif backbone == 'repvgg-A2':\n            from models.backbone.repvgg_backbone import REPVGGBackbone\n            self.backbone = REPVGGBackbone(version='A2', pretrained=True)\n            channels = (384, 1408)\n            self.fea_channel = 256\n        elif backbone == 'vgg16':\n            from models.backbone.vgg_backbone import VGGBackbone\n            self.backbone = VGGBackbone(pretrained=True)\n            channels = (512, 512)\n            self.fea_channel = 256\n        elif backbone == 'shufflenet':\n            from models.backbone.shufflenet_backbone import ShuffleNetBackbone\n            self.backbone = ShuffleNetBackbone(pretrained=True)\n            channels = (232, 464)\n            self.fea_channel = 128\n        else:\n            raise ValueError('Error: Sorry backbone {} is not supported!'.format(backbone))\n\n        # Neck network\n        if neck == 'ssd':\n            from models.neck.ssd_neck import SSDNeck\n            self.neck = SSDNeck(self.fpn_level, channels, self.fea_channel)\n        elif neck == 'fpn':\n            from models.neck.fpn_neck import FPNNeck\n            self.neck = FPNNeck(self.fpn_level, channels, self.fea_channel)\n        elif neck == 'pafpn':\n            from models.neck.pafpn_neck import PAFPNNeck\n            self.neck = PAFPNNeck(self.fpn_level, channels, self.fea_channel)\n        else:\n            raise ValueError('Error: Sorry neck {} is not supported!'.format(neck))\n\n        # Detection Head\n\n        (self.loc, self.conf, self.dist) = multibox(self.fpn_level, self.num_anchors, self.num_classes, self.fea_channel)\n\n        bias_value = 0\n        for modules in self.loc:\n            torch.nn.init.normal_(modules[-1].weight, std=0.01)\n            torch.nn.init.constant_(modules[-1].bias, bias_value)\n        import math\n        prior_prob = 0.01\n        bias_value = -math.log((1 - prior_prob) \/ prior_prob)\n        for modules in self.conf:\n            torch.nn.init.normal_(modules[-1].weight, std=0.01)\n            torch.nn.init.constant_(modules[-1].bias, bias_value)\n"}