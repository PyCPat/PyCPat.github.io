{"BEFORE":"        embbedings = l2_norm(embbedings, axis = 1)\n        kernel_norm = l2_norm(self.kernel, axis = 0)\n        cos_theta = torch.mm(embbedings, kernel_norm)\n        cos_theta = cos_theta.clamp(-1, 1)  # for numerical stability\n        with torch.no_grad():\n            origin_cos = cos_theta.clone()\n        target_logit = cos_theta[torch.arange(0, embbedings.size(0)), label].view(-1, 1)\n\n        sin_theta = torch.sqrt(1.0 - torch.pow(target_logit, 2))\n        cos_theta_m = target_logit * self.cos_m - sin_theta * self.sin_m #cos(target+margin)\n        if self.easy_margin:\n            final_target_logit = torch.where(target_logit > 0, cos_theta_m, target_loit)\n        else:\n            final_target_logit = torch.where(target_logit > self.th, cos_theta_m, target_logit - self.mm)\n\n        cos_theta.scatter_(1, label.view(-1, 1).long(), final_target_logit)\n","AFTER":"        embbedings = l2_norm(embbedings, axis = 1)\n        kernel_norm = l2_norm(self.kernel, axis = 0)\n        cos_theta = torch.mm(embbedings, kernel_norm).clamp(-1, 1)  # for numerical stability\n        with torch.no_grad():\n            origin_cos = cos_theta.clone()\n        target_logit = cos_theta[torch.arange(0, embbedings.size(0)), label].view(-1, 1)\n\n        sin_theta = torch.sqrt(1.0 - torch.pow(target_logit, 2))\n        cos_theta_m = target_logit * self.cos_m - sin_theta * self.sin_m #cos(target+margin)\n        \n        if cfg['USE_APEX'] == True and cfg['OPT_LEVEL'] == 'O1':\n            target_logit = target_logit.float()\n        final_target_logit = torch.where(target_logit > self.th, cos_theta_m, target_logit - self.mm)\n        if cfg['USE_APEX'] == True and cfg['OPT_LEVEL'] == 'O1':\n            final_target_logit = final_target_logit.half()\n        cos_theta.scatter_(1, label.view(-1, 1).long(), final_target_logit)\n"}