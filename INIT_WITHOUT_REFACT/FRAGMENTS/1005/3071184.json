{"BEFORE":"        output = []\n\n        for i, (module_def, module) in enumerate(zip(self.module_defs, self.module_list)):\n            mtype = module_def['type']\n            if mtype in ['convolutional', 'upsample', 'maxpool']:\n                x = module(x)\n            elif mtype == 'route':\n                layer_i = [int(x) for x in module_def['layers'].split(',')]\n                if len(layer_i) == 1:\n                    x = layer_outputs[layer_i[0]]\n                else:\n                    x = torch.cat([layer_outputs[i] for i in layer_i], 1)\n            elif mtype == 'shortcut':\n                layer_i = int(module_def['from'])\n                x = layer_outputs[-1] + layer_outputs[layer_i]\n            elif mtype == 'yolo':\n                x = module[0](x, img_size)\n                output.append(x)\n            layer_outputs.append(x)\n\n        if ONNX_EXPORT:\n            output = torch.cat(output, 1)  # cat 3 layers 85 x (507, 2028, 8112) to 85 x 10647\n            return output[5:85].t(), output[:4].t()  # ONNX scores, boxes\n        else:\n            return output if self.training else torch.cat(output, 1)\n\n\ndef get_yolo_layers(model):\n","AFTER":"        output = []\n\n        for i, (module_def, module) in enumerate(zip(self.module_defs, self.module_list)):\n            mtype = module_def['type']\n            if mtype in ['convolutional', 'upsample', 'maxpool']:\n                x = module(x)\n            elif mtype == 'route':\n                layer_i = [int(x) for x in module_def['layers'].split(',')]\n                if len(layer_i) == 1:\n                    x = layer_outputs[layer_i[0]]\n                else:\n                    x = torch.cat([layer_outputs[i] for i in layer_i], 1)\n            elif mtype == 'shortcut':\n                layer_i = int(module_def['from'])\n                x = layer_outputs[-1] + layer_outputs[layer_i]\n            elif mtype == 'yolo':\n                x = module[0](x, img_size)\n                output.append(x)\n            layer_outputs.append(x)\n\n        if self.training:\n            return output\n        elif ONNX_EXPORT:\n            output = torch.cat(output, 1)  # cat 3 layers 85 x (507, 2028, 8112) to 85 x 10647\n            return output[5:85].t(), output[:4].t()  # ONNX scores, boxes\n        else:\n            io, p = list(zip(*output))  # inference output, training output\n            return torch.cat(io, 1), p\n\n\ndef get_yolo_layers(model):\n"}