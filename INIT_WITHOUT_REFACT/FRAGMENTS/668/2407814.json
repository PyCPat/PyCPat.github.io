{"BEFORE":"        self.num_classes = num_classes\n        self.strides = strides\n        self.reid_dim = reid_dim\n\n        self.use_l1 = False\n        self.l1_loss = nn.L1Loss(reduction=\"none\")\n        self.bcewithlog_loss = nn.BCEWithLogitsLoss(reduction=\"none\")\n        self.iou_loss = IOUloss(reduction=\"none\")\n        self.grids = [torch.zeros(1)] * len(in_channels)\n        self.expanded_strides = [None] * len(in_channels)\n\n        if self.reid_dim > 0:\n            assert id_num is not None\n            self.nID = id_num\n            self.classifier = nn.Linear(self.reid_dim, self.nID)\n            self.IDLoss = nn.CrossEntropyLoss(ignore_index=-1)\n            self.emb_scale = np.math.sqrt(2) * np.math.log(self.nID - 1)\n            self.s_det = nn.Parameter(-1.85 * torch.ones(1), requires_grad=False)\n            self.s_id = nn.Parameter(-1.05 * torch.ones(1), requires_grad=False)\n","AFTER":"        self.label_name = label_name\n        self.num_classes = len(self.label_name)\n        self.strides = strides\n        self.reid_dim = reid_dim\n\n        self.use_l1 = False\n        self.l1_loss = nn.L1Loss(reduction=\"none\")\n        self.bcewithlog_loss = nn.BCEWithLogitsLoss(reduction=\"none\")\n        self.iou_loss = IOUloss(reduction=\"none\")\n        self.grids = [torch.zeros(1)] * len(in_channels)\n        self.expanded_strides = [None] * len(in_channels)\n\n        if self.reid_dim > 0:\n            assert id_nums is not None, \"opt.tracking_id_nums shouldn't be None when reid_dim > 0\"\n            assert len(id_nums) == self.num_classes, \"num_classes={}, which is not the same as id_nums's length {}\" \\\n                                                     \"\".format(self.num_classes, len(id_nums))\n            # scale_trainable = True\n            # self.s_det = nn.Parameter(-1.85 * torch.ones(1), requires_grad=scale_trainable)\n            # self.s_id = nn.Parameter(-1.05 * torch.ones(1), requires_grad=scale_trainable)\n\n            self.reid_loss = nn.CrossEntropyLoss(ignore_index=-1)\n            self.classifiers = nn.ModuleList()\n            self.emb_scales = []\n            for idx, (label, id_num) in enumerate(zip(self.label_name, id_nums)):\n                print(\"{}, tracking label name: '{}', tracking_id number: {}, feat dim: {}\".format(idx, label, id_num,\n                                                                                                   self.reid_dim))\n                self.emb_scales.append(np.math.sqrt(2) * np.math.log(id_num - 1))\n                self.classifiers.append(nn.Linear(self.reid_dim, id_num))\n\n    def forward(self, preds, targets, imgs=None):\n"}