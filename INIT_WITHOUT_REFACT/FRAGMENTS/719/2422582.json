{"BEFORE":"        hz = self.to_hz(mel)\n\n        # Computation of the filter bands\n        band = hz[1:] - hz[:-1]\n\n        self.band = band[:-1]\n        self.f_central = hz[1:-1]\n","AFTER":"            self.device_inp = first_input[0].device\n\n            # Check shape\n            if len(first_input[0].shape) > 4 or len(first_input[0].shape) < 2:\n\n                err_msg = (\n                    'The input of \"FBANKs\" must be a tensor with one of '\n                    \"the following dimensions: [n_freq_points, time] or \"\n                    \"[batch,n_freq_points, time] or \"\n                    \"[batch,channels,n_freq_points, time]. \"\n                    \"Got %s \" % (str(first_input[0].shape))\n                )\n\n                logger_write(err_msg, logfile=logger)\n\n        # Getting the outut folder\n        if not self.freeze:\n            self.output_folder = global_config[\"output_folder\"]\n\n        # Additional options\n        self.funct_name = funct_name\n        self.n_stft = self.n_fft \/\/ 2 + 1\n\n        # Make sure that the selected f_min < f_max\n        if self.f_min >= self.f_max:\n            err_msg = \"Require f_min: %f < f_max: %f\" % (\n                self.f_min,\n                self.f_max,\n            )\n            logger_write(err_msg, logfile=logger)\n\n        # Setting the multiplier for log conversion\n        if self.power_spectrogram == 2:\n            self.multiplier = 10\n        else:\n            self.multiplier = 20\n\n        self.db_multiplier = math.log10(max(self.amin, self.ref_value))\n\n        # Filter definition\n        mel = torch.linspace(\n            self.to_mel(self.f_min), self.to_mel(self.f_max), self.n_mels + 2\n        )\n\n        # Conversion to hz\n        hz = self.to_hz(mel)\n\n        # Computation of the filter bands\n        band = hz[1:] - hz[:-1]\n\n        self.band = band[:-1].to(self.device_inp)\n        self.f_central = hz[1:-1].to(self.device_inp)\n\n        # Adding the central frequency and the band to the list of nn param\n        if not self.freeze:\n            self.f_central = nn.Parameter(self.f_central)\n            self.band = nn.Parameter(self.band)\n\n        # Frequency axis\n        all_freqs = torch.linspace(0, self.sample_rate \/\/ 2, self.n_stft)\n        all_freqs = all_freqs.to(self.device_inp)\n\n        # replicating for all the filters\n        self.all_freqs_mat = all_freqs.repeat(self.f_central.shape[0], 1)\n        self.all_freqs_mat = self.all_freqs_mat.to(self.device_inp)\n"}