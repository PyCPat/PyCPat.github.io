{"BEFORE":"    def __init__(self, in_planes, planes, dropout_rate, stride=1):\n        super(wide_basic, self).__init__()\n        self.bn1 = nn.BatchNorm2d(in_planes)\n        self.conv1 = nn.Conv2d(\n            in_planes, planes, kernel_size=3, padding=1, bias=True\n        )\n        self.dropout = nn.Dropout(p=dropout_rate)\n        self.bn2 = nn.BatchNorm2d(planes)\n        self.conv2 = nn.Conv2d(\n            planes, planes, kernel_size=3, stride=stride, padding=1, bias=True\n        )\n\n        self.shortcut = nn.Sequential()\n        if stride != 1 or in_planes != planes:\n            self.shortcut = nn.Sequential(\n                nn.Conv2d(\n                    in_planes, planes, kernel_size=1, stride=stride, bias=True\n                ),\n            )\n\n    def forward(self, x):\n","AFTER":"    def __init__(self, in_planes, out_planes, stride, dropRate=0.0):\n        super().__init__()\n        self.bn1 = nn.BatchNorm2d(in_planes)\n        self.relu1 = nn.LeakyReLU(0.01, inplace=True)\n        self.conv1 = nn.Conv2d(\n            in_planes,\n            out_planes,\n            kernel_size=3,\n            stride=stride,\n            padding=1,\n            bias=False\n        )\n        self.bn2 = nn.BatchNorm2d(out_planes)\n        self.relu2 = nn.LeakyReLU(0.01, inplace=True)\n        self.conv2 = nn.Conv2d(\n            out_planes,\n            out_planes,\n            kernel_size=3,\n            stride=1,\n            padding=1,\n            bias=False\n        )\n        self.droprate = dropRate\n        self.equalInOut = (in_planes == out_planes)\n        self.convShortcut = (not self.equalInOut) and nn.Conv2d(\n            in_planes,\n            out_planes,\n            kernel_size=1,\n            stride=stride,\n            padding=0,\n            bias=False\n        ) or None\n"}