{"BEFORE":"    def forward(self, feats, mask):\r\n        best_path = self._viterbi_decode(feats, mask)  # [bts, seq_len]\r\n        return best_path\r\n","AFTER":"    def forward(self, emissions: torch.Tensor, mask: torch.ByteTensor,\r\n                tags: torch.LongTensor, reduction: str = 'mean') -> torch.Tensor:\r\n        \"\"\"Compute the conditional log likelihood of a sequence of tags given emission scores.\r\n            emissions: [btz, seq_len, num_tags]\r\n            mask: [btz, seq_len]\r\n            tags: [btz, seq_len]\r\n        \"\"\"\r\n        if reduction not in ('none', 'sum', 'mean', 'token_mean'):\r\n            raise ValueError(f'invalid reduction: {reduction}')\r\n        if mask.dtype != torch.uint8:\r\n            mask = mask.byte()\r\n        self._validate(emissions, tags=tags, mask=mask)\r\n\r\n        # shape: (batch_size,)\r\n        numerator = self._compute_score(emissions, tags, mask)\r\n        # shape: (batch_size,)\r\n        denominator = self._compute_normalizer(emissions, mask)\r\n        # shape: (batch_size,)\r\n        llh = denominator - numerator\r\n\r\n        if reduction == 'none':\r\n            return llh\r\n        if reduction == 'sum':\r\n            return llh.sum()\r\n        if reduction == 'mean':\r\n            return llh.mean()\r\n        return llh.sum() \/ mask.float().sum()\r\n"}