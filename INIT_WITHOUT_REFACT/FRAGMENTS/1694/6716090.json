{"BEFORE":"        weight = torch.tensor([1.0, 2.0], dtype=torch.float, device=self.device)\n        # cls_loss = F.cross_entropy(\n        #     pred_dict['target_prob'].transpose(1, 2),\n        #     gt_dict['target_prob'].long(),\n        #     weight=weight,\n        #     reduction='sum')\n        # cls_loss = F.binary_cross_entropy_with_logits(\n        cls_loss = F.binary_cross_entropy(\n            pred_dict['target_prob'], gt_dict['target_prob'].float(), reduction='sum')\n        offset = pred_dict['offset'][gt_dict['target_prob'].bool()]\n        offset_loss = F.smooth_l1_loss(offset, gt_dict['offset'], reduction='sum')\n        # loss += self.lambda1 * (cls_loss + offset_loss) \/ (1.0 if self.reduction == \"sum\" else batch_size)\n        loss += self.lambda1 * (cls_loss + offset_loss)\n\n        # compute motion estimation loss\n        reg_loss = F.smooth_l1_loss(pred_dict['traj_with_gt'].squeeze(1), gt_dict['y'], reduction='sum')\n        loss += self.lambda2 * reg_loss\n\n        # compute scoring gt and loss\n        score_gt = F.softmax(-distance_metric(pred_dict['traj'], gt_dict['y'])\/self.temper, dim=-1)\n        score_loss = torch.sum(torch.mul(- torch.log(pred_dict['score']), score_gt))\n","AFTER":"        cls_loss = F.binary_cross_entropy(\n            pred_dict['target_prob'], gt_dict['target_prob'].float(), reduction='none')\n\n        gt_idx = gt_dict['target_prob'].nonzero()\n        offset = pred_dict['offset'][gt_idx[:, 0], gt_idx[:, 1]]\n\n        # cls_loss, indices = torch.topk(cls_loss, self.m, dim=1)    # largest 50\n        cls_loss = cls_loss.sum()\n        offset_loss = F.smooth_l1_loss(offset, gt_dict['offset'], reduction='sum')\n        # loss += self.lambda1 * (cls_loss + offset_loss) \/ (1.0 if self.reduction == \"sum\" else batch_size)\n        loss += self.lambda1 * (cls_loss + offset_loss)\n\n        # compute motion estimation loss\n        reg_loss = F.smooth_l1_loss(pred_dict['traj_with_gt'].squeeze(1), gt_dict['y'], reduction='sum')\n        loss += self.lambda2 * reg_loss\n\n        # compute scoring gt and loss\n        score_gt = F.softmax(-distance_metric(pred_dict['traj'], gt_dict['y'])\/self.temper, dim=-1).detach()\n        # score_loss = torch.sum(torch.mul(- torch.log(pred_dict['score']), score_gt)) \/ batch_size\n        score_loss = F.binary_cross_entropy(pred_dict['score'], score_gt, reduction='sum')\n"}