{"BEFORE":"            hidden_features = [hidden_features]\n        self.act0 = F.elu\n        self.act1 = F.relu\n\n        self.layers = nn.ModuleList()\n        self.layers.append(RobustGCNConv(in_features, hidden_features[0], act0=self.act0, act1=self.act1,\n                                         initial=True, dropout=dropout))\n        for i in range(len(hidden_features) - 1):\n            self.layers.append(RobustGCNConv(hidden_features[i], hidden_features[i + 1],\n                                             act0=self.act0, act1=self.act1, dropout=True))\n        self.layers.append(RobustGCNConv(hidden_features[-1], out_features, act0=self.act0, act1=self.act1))\n","AFTER":"                 n_layers,\n                 feat_norm=None,\n                 adj_norm_func=RobustGCNAdjNorm,\n                 dropout=0.0):\n        super(RobustGCN, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.feat_norm = feat_norm\n        self.adj_norm_func = adj_norm_func\n        if type(hidden_features) is int:\n            hidden_features = [hidden_features] * (n_layers - 1)\n        elif type(hidden_features) is list or type(hidden_features) is tuple:\n            assert len(hidden_features) == (n_layers - 1), \"Incompatible sizes between hidden_features and n_layers.\"\n        n_features = [in_features] + hidden_features + [out_features]\n\n        self.act0 = F.elu\n        self.act1 = F.relu\n\n        self.layers = nn.ModuleList()\n        for i in range(n_layers):\n            self.layers.append(RobustGCNConv(n_features[i], n_features[i + 1], act0=self.act0, act1=self.act1,\n"}