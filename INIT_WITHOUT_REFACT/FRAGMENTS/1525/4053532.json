{"BEFORE":"    def __init__(self):\n        super().__init__()\n        self.conv_blocks = nn.ModuleList()\n        self.conv_blocks.append(\n            nn.Sequential(\n                nn.Conv2d(3, 64, 5, stride=2, padding=2), nn.LeakyReLU(0.2)))\n        self.conv_blocks.append(\n            nn.Sequential(\n                nn.Conv2d(64, 128, 5, stride=2, padding=2),\n                nn.BatchNorm2d(128), nn.LeakyReLU(0.2)))\n        self.conv_blocks.append(\n            nn.Sequential(\n                nn.Conv2d(128, 256, 5, stride=2, padding=2),\n                nn.BatchNorm2d(256), nn.LeakyReLU(0.2)))\n        self.conv_blocks.append(\n            nn.Sequential(\n                nn.Conv2d(256, 512, 5, stride=2, padding=2),\n                nn.BatchNorm2d(512), nn.LeakyReLU(0.2)))\n        self.decision = nn.Sequential(nn.Linear(7 * 7 * 512, 1), nn.Sigmoid())\n","AFTER":"    def __init__(self,\n                 input_scale=128,\n                 output_scale=8,\n                 out_channels=1,\n                 in_channels=3,\n                 base_channels=64,\n                 conv_cfg=dict(type='Conv2d'),\n                 default_norm_cfg=dict(type='BN'),\n                 default_act_cfg=dict(type='LeakyReLU', negative_slope=0.2),\n                 out_act_cfg=None):\n        super().__init__()\n        assert input_scale % output_scale == 0\n        assert input_scale \/\/ output_scale >= 2\n\n        self.input_scale = input_scale\n        self.output_scale = output_scale\n        self.out_channels = out_channels\n        self.base_channels = base_channels\n        self.with_activation = out_act_cfg is not None\n\n        self.conv_blocks = nn.ModuleList()\n        self.conv_blocks.append(\n            ConvModule(\n                in_channels,\n                base_channels,\n                kernel_size=5,\n                stride=2,\n                padding=2,\n                conv_cfg=conv_cfg,\n                norm_cfg=None,\n                act_cfg=default_act_cfg))\n\n        # the number of times for downsampling\n        self.num_downsamples = int(math.log2(input_scale \/\/ output_scale)) - 1\n\n        # build up downsampling backbone (excluding the output layer)\n        curr_channels = base_channels\n        for _ in range(self.num_downsamples):\n            self.conv_blocks.append(\n                ConvModule(\n                    curr_channels,\n                    curr_channels * 2,\n                    kernel_size=5,\n                    stride=2,\n                    padding=2,\n                    conv_cfg=conv_cfg,\n                    norm_cfg=default_norm_cfg,\n                    act_cfg=default_act_cfg))\n            curr_channels = curr_channels * 2\n\n        # output layer\n        self.decision = nn.Sequential(\n            nn.Linear(output_scale * output_scale * curr_channels,\n                      out_channels))\n        if self.with_activation:\n            self.activation = build_activation_layer(out_act_cfg)\n\n    def forward(self, x):\n"}