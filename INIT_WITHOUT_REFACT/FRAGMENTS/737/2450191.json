{"BEFORE":"    def __init__(self, num_conv_block=4):\n        r\"\"\"\n\n        Args:\n            num_conv_block (int): Number of overlapping residual blocks. Default: 4.\n        \"\"\"\n        super(Discriminator, self).__init__()\n\n        block = []\n\n        # Define the initial number of channels\n        in_channels = 3\n        out_channels = 64\n\n        for _ in range(num_conv_block):\n            block += [nn.ReflectionPad2d(1),\n                      nn.Conv2d(in_channels, out_channels, 3),\n                      nn.LeakyReLU(),\n                      nn.BatchNorm2d(out_channels)]\n            in_channels = out_channels\n\n            block += [nn.ReflectionPad2d(1),\n                      nn.Conv2d(in_channels, out_channels, 3, 2),\n                      nn.LeakyReLU()]\n            out_channels *= 2\n\n        out_channels \/\/= 2\n        in_channels = out_channels\n\n        block += [nn.Conv2d(in_channels, out_channels, 3),\n                  nn.LeakyReLU(0.2),\n                  nn.Conv2d(out_channels, out_channels, 3)]\n\n        self.features = nn.Sequential(*block)\n\n        self.avgpool = nn.AdaptiveAvgPool2d((512, 512))\n\n        self.classifier = nn.Sequential(\n","AFTER":"    def __init__(self):\n        super(Discriminator, self).__init__()\n\n        self.features = nn.Sequential(\n            # Conv0\n            nn.Conv2d(3, 64, kernel_size=3, stride=1, padding=1, bias=False),\n            nn.LeakyReLU(negative_slope=0.2, inplace=True),\n            nn.Conv2d(64, 64, kernel_size=4, stride=2, padding=1, bias=False),\n            nn.BatchNorm2d(64),\n            nn.LeakyReLU(negative_slope=0.2, inplace=True),\n\n            # Conv1\n            nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=1, bias=False),\n            nn.BatchNorm2d(128),\n            nn.LeakyReLU(negative_slope=0.2, inplace=True),\n            nn.Conv2d(128, 128, kernel_size=4, stride=2, padding=1, bias=False),\n            nn.BatchNorm2d(128),\n            nn.LeakyReLU(negative_slope=0.2, inplace=True),\n\n            # Conv2\n            nn.Conv2d(128, 256, kernel_size=3, stride=1, padding=1, bias=False),\n            nn.BatchNorm2d(256),\n            nn.LeakyReLU(negative_slope=0.2, inplace=True),\n            nn.Conv2d(256, 256, kernel_size=4, stride=2, padding=1, bias=False),\n            nn.BatchNorm2d(256),\n            nn.LeakyReLU(negative_slope=0.2, inplace=True),\n\n            # Conv3\n            nn.Conv2d(256, 512, kernel_size=3, stride=1, padding=1, bias=False),\n            nn.BatchNorm2d(512),\n            nn.LeakyReLU(negative_slope=0.2, inplace=True),\n            nn.Conv2d(512, 512, kernel_size=4, stride=2, padding=1, bias=False),\n            nn.BatchNorm2d(512),\n            nn.LeakyReLU(negative_slope=0.2, inplace=True),\n\n            # Conv4\n            nn.Conv2d(512, 512, kernel_size=3, stride=1, padding=1, bias=False),\n            nn.BatchNorm2d(512),\n            nn.LeakyReLU(negative_slope=0.2, inplace=True),\n            nn.Conv2d(512, 512, kernel_size=4, stride=2, padding=1, bias=False),\n            nn.BatchNorm2d(512),\n            nn.LeakyReLU(negative_slope=0.2, inplace=True)\n        )\n\n        self.avgpool = nn.AdaptiveAvgPool2d((512, 512))\n\n        self.classifier = nn.Sequential(\n            nn.Linear(8192, 100),\n            nn.LeakyReLU(negative_slope=0.2, inplace=True),\n"}