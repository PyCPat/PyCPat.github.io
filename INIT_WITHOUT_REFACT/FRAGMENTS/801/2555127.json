{"BEFORE":"        x = pad_to_multiple(x, block_mult, seq_dim = 1, dim = -2)\n\n        if exists(mask):\n            mask = pad_to_multiple(mask, block_mult, seq_dim = 1, dim = -1, value = False)\n\n        # compute representations for all blocks by mean pooling\n\n        block_masks = []\n        block_reprs = []\n\n        for block_size in self.block_sizes:\n            blocks = rearrange(x, 'b (n m) d -> b n m d', m = block_size)\n\n            if exists(mask):\n                mask_blocks = rearrange(mask, 'b (n m) -> b n m', m = block_size)\n","AFTER":"        x = pad_to_multiple(x, block_mult, seq_dim = 1, dim = -2)\n\n        if exists(mask):\n            mask = pad_to_multiple(mask, block_mult, seq_dim = 1, dim = -1, value = False)\n\n        # compute representations for all blocks by mean pooling\n\n        block_masks = []\n        block_reprs = []\n\n        for block_size, offset in self.blocks:\n            # clone the input sequence as well as the mask, in order to pad for offsets\n\n            block_x = x.clone()\n\n            if exists(mask):\n                block_mask = mask.clone()\n\n            # pad for offsets, if needed\n\n            need_padding = offset > 0\n\n            if need_padding:\n                left_offset, right_offset = (block_size - offset), offset\n                block_x = F.pad(block_x, (0, 0, left_offset, right_offset), value = 0.)\n\n                if exists(mask):\n                    block_mask = F.pad(block_mask, (left_offset, right_offset), value = False)\n\n            # group input sequence into blocks\n\n            blocks = rearrange(block_x, 'b (n m) d -> b n m d', m = block_size)\n\n            # either mean pool the blocks, or do a masked mean\n\n            if exists(mask):\n                mask_blocks = rearrange(block_mask, 'b (n m) -> b n m', m = block_size)\n                block_repr = masked_mean(blocks, mask_blocks, dim = -2)\n            else:\n                block_repr = blocks.mean(dim = -2)\n\n            # append the block representations, as well as the pooled block masks\n\n            block_repr = repeat(block_repr, 'b n d -> b (n m) d', m = block_size)\n\n            if need_padding:\n                block_repr = block_repr[:, left_offset:-right_offset]\n\n            block_reprs.append(block_repr)\n\n            if exists(mask):\n                mask_blocks = torch.any(mask_blocks, dim = -1)\n                mask_blocks = repeat(mask_blocks, 'b n -> b (n m)', m = block_size)\n\n                if need_padding:\n                    mask_blocks = mask_blocks[:, left_offset:-right_offset]\n\n                block_masks.append(mask_blocks)\n"}