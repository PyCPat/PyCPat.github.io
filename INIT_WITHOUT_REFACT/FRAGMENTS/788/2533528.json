{"BEFORE":"        seq_len, batch_size, n_heads, d = x.shape\n\n        # $\\frac{d}{2}$\n        d_2 = d \/\/ 2\n\n        # Create position indexes `[0, 1, ..., seq_len - 1]`\n        seq_idx = torch.arange(seq_len, device=x.device).type_as(self.theta)\n\n        # Calculate the product of position index and $\\theta_i$\n        idx_theta = torch.einsum('n,d->nd', seq_idx, self.theta)\n\n        # Concatenate so that for row $m$ we have\n        # $[m \\theta_0, m \\theta_1, ..., m \\theta_{\\frac{d}{2}}, m \\theta_0, m \\theta_1, ..., m \\theta_{\\frac{d}{2}}]$\n        idx_theta2 = torch.cat([idx_theta, idx_theta], dim=1)\n\n        # Calculate $[-x^{(\\frac{d}{2} + 1)}, -x^{(\\frac{d}{2} + 2)}, ..., -x^{(d)}, x^{(1)}, x^{(2)}, ..., -x^{(\\frac{d}{2})}]$\n        neg_half_x = torch.cat([-x[:, :, :, d_2:], x[:, :, :, :d_2]], dim=-1)\n\n        # Calculate\n        #\n        # \\begin{align}\n        # \\begin{pmatrix}\n        # x^{(i)}_m \\cos m \\theta_i - x^{(i + \\frac{d}{2})}_m \\sin m \\theta_i \\\\\n        # x^{(i + \\frac{d}{2})}_m \\cos m\\theta_i + x^{(i)}_m \\sin m \\theta_i \\\\\n        # \\end{pmatrix} \\\\\n        # \\end{align}\n        #\n        # for $i \\in {1, 2, ..., \\frac{d}{2}}$\n        rx = (x * idx_theta2.cos()[:, None, None, :]) + (neg_half_x * idx_theta2.sin()[:, None, None, :])\n\n        #\n        return rx\n","AFTER":"        self._build_cache(x)\n\n        # Split the features, we can choose to apply rotary embeddings only to a partial set of features.\n        x_rope, x_pass = x[..., :self.d], x[..., self.d:]\n\n        # Calculate\n        # $[-x^{(\\frac{d}{2} + 1)}, -x^{(\\frac{d}{2} + 2)}, ..., -x^{(d)}, x^{(1)}, x^{(2)}, ..., x^{(\\frac{d}{2})}]$\n        neg_half_x = self._neg_half(x_rope)\n\n        # Calculate\n        #\n        # \\begin{align}\n        # \\begin{pmatrix}\n        # x^{(i)}_m \\cos m \\theta_i - x^{(i + \\frac{d}{2})}_m \\sin m \\theta_i \\\\\n        # x^{(i + \\frac{d}{2})}_m \\cos m\\theta_i + x^{(i)}_m \\sin m \\theta_i \\\\\n        # \\end{pmatrix} \\\\\n        # \\end{align}\n        #\n        # for $i \\in {1, 2, ..., \\frac{d}{2}}$\n        x_rope = (x_rope * self.cos_cached[:x.shape[0]]) + (neg_half_x * self.sin_cached[:x.shape[0]])\n\n        #\n        return torch.cat((x_rope, x_pass), dim=-1)\n"}