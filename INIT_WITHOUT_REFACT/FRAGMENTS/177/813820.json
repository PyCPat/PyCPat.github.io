{"BEFORE":"            g.ndata['hv'] = node_feats\n            g.apply_edges(fn.copy_src('hv', 'he_src'))\n            concat_edge_feats = torch.cat([g.edata['he_src'], edge_feats], dim=1)\n            g.edata['he'] = self.project_concatenated_messages(concat_edge_feats)\n            g.update_all(fn.copy_edge('he', 'm'), fn.sum('m', 'hv_new'))\n            node_feats = self.get_new_node_feats(\n                torch.cat([node_feats, g.ndata['hv_new']], dim=1))\n\n        if not self.set_comparison:\n            return node_feats\n        else:\n            g = g.local_var()\n            g.ndata['hv'] = self.project_node_messages(node_feats)\n            g.edata['he'] = self.project_edge_messages(edge_feats)\n            g.update_all(fn.u_mul_e('hv', 'he', 'm'), fn.sum('m', 'h_nbr'))\n            h_self = self.project_self(node_feats)  # (V, node_out_feats)\n            return g.ndata['h_nbr'] * h_self\n","AFTER":"            node_feats = self.project_node_in_feats(node_feats)\n        for _ in range(self.n_layers):\n            g = g.local_var()\n            if g.num_edges() > 0:\n                # The following lines do not work for a graph without edges.\n                g.ndata['hv'] = node_feats\n                g.apply_edges(fn.copy_src('hv', 'he_src'))\n                concat_edge_feats = torch.cat([g.edata['he_src'], edge_feats], dim=1)\n                g.edata['he'] = self.project_concatenated_messages(concat_edge_feats)\n                g.update_all(fn.copy_edge('he', 'm'), fn.sum('m', 'hv_new'))\n                node_feats = self.get_new_node_feats(\n                    torch.cat([node_feats, g.ndata['hv_new']], dim=1))\n            else:\n                # If we don't have edges, above formula becomes very simple.\n                # The sum over the neighbors is zero then.\n                # Refer to equations in section S2.2 of\n                # http:\/\/www.rsc.org\/suppdata\/c8\/sc\/c8sc04228d\/c8sc04228d2.pdf\n                node_feats = self.get_new_node_feats(\n                    torch.cat([node_feats, node_feats*0], dim=1))\n\n        if not self.set_comparison:\n            return node_feats\n        else:\n            if g.num_edges() > 0:\n                # The following lines don't work for a graph without edges\n                g = g.local_var()\n                g.ndata['hv'] = self.project_node_messages(node_feats)\n                g.edata['he'] = self.project_edge_messages(edge_feats)\n                g.update_all(fn.u_mul_e('hv', 'he', 'm'), fn.sum('m', 'h_nbr'))\n                h_self = self.project_self(node_feats)  # (V, node_out_feats)\n                return g.ndata['h_nbr'] * h_self\n            else:\n                # If the graph has no edges, the formula becomes very simple.\n                # The sum over the neighbors is zero then.\n                # Refer to equations in section S2.5 of\n                # http:\/\/www.rsc.org\/suppdata\/c8\/sc\/c8sc04228d\/c8sc04228d2.pdf\n                return torch.zeros((g.num_nodes(), self.project_self.out_feats),\n                                   device=node_feats.device)\n"}