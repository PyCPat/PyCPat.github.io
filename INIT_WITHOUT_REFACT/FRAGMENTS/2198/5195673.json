{"BEFORE":"        self.inplanes = 64\n        self.dilation = 1\n        if replace_stride_with_dilation is None:\n            replace_stride_with_dilation = [False, False, False]\n        if len(replace_stride_with_dilation) != 3:\n            raise ValueError(\"replace_stride_with_dilation should be None \"\n                             \"or a 3-element tuple, got {}\".format(replace_stride_with_dilation))\n        self.groups = groups\n        self.base_width = width_per_group\n        self.conv1 = nn.Conv2d(3, self.inplanes, kernel_size=7, stride=2, padding=3,\n                               bias=False)\n        if has_bn:\n            self.bn1 = norm_layer(self.inplanes)\n        else:\n            self.bn1 = nn.Identity()\n        self.relu = nn.ReLU(inplace=True)\n        self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n\n        self.layers = [self._make_layer(block, 64, layers[0], has_bn=has_bn and (bn_block_num > 0))]\n        for num in range(1, len(layers)):\n            self.layers.append(self._make_layer(block, features[num], layers[num], stride=2,\n                                       dilate=replace_stride_with_dilation[num-1], has_bn=has_bn and (num < bn_block_num)))\n\n        self.layers = nn.Sequential(*self.layers)\n\n        self.avgpool = nn.AdaptiveAvgPool2d((1, 1))\n","AFTER":"        self.inplanes = 64\n        self.dilation = 1\n        if replace_stride_with_dilation is None:\n            replace_stride_with_dilation = [False, False, False]\n        if len(replace_stride_with_dilation) != 3:\n            raise ValueError(\"replace_stride_with_dilation should be None \"\n                             \"or a 3-element tuple, got {}\".format(replace_stride_with_dilation))\n        self.groups = groups\n        self.base_width = width_per_group\n\n        self.conv1 = nn.Sequential(\n            nn.Conv2d(3, self.inplanes, kernel_size=7, stride=2, padding=3, bias=False), \n            norm_layer(self.inplanes) if has_bn else nn.Identity(), \n            nn.ReLU(inplace=True), \n            nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n        )\n\n        self.layers = [self._make_layer(block, 64, layers[0], has_bn=has_bn and (bn_block_num > 0))]\n        for num in range(1, len(layers)):\n            self.layers.append(self._make_layer(block, features[num], layers[num], stride=2,\n                                       dilate=replace_stride_with_dilation[num-1], has_bn=has_bn and (num < bn_block_num)))\n\n        for i, layer in enumerate(self.layers):\n            setattr(self, f'layer_{i}', layer)\n\n        self.avgpool = nn.Sequential(\n            nn.AdaptiveAvgPool2d((1, 1)),\n            nn.Flatten()\n        )\n"}