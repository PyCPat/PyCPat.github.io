{"BEFORE":"    def forward(self, input, spk_idx=None):\n        \"\"\"\n        Args:\n            input (batch_size, 1, T)\n        Returns:\n            output (batch_size, 1, T)\n        \"\"\"\n        raise NotImplementedError(\"Implement forward.\")\n","AFTER":"    def forward(self, mixture, spk_idx=None, sorted_idx=None, return_all_layers=False, return_spk_vector=False, stack_dim=1):\n        \"\"\"\n        Only supports training time\n        Args:\n            mixture: (batch_size, 1, T)\n            spk_idx: (batch_size, n_sources)\n        Returns:\n            estimated_sources: (batch_size, num_blocks * num_layers, 1, T) if stack_dim=1.\n            sorted_speaker_vector: (batch_size, n_sources, latent_dim, T)\n        \"\"\"\n        if sorted_idx is None:    \n            sorted_idx = self.solve_permutation(mixture, spk_idx=spk_idx)\n\n            return sorted_idx # (batch_size, T, n_sources)\n        \n        estimated_sources, sorted_spk_vector = self.extract_latent(mixture, sorted_idx, return_all_layers=return_all_layers, stack_dim=stack_dim)\n\n        if return_spk_vector:\n            return estimated_sources, sorted_spk_vector\n        \n        return estimated_sources\n"}