{"BEFORE":"        tar_candit_prob = self.prob_mlp(feat_in_repeat).squeeze(-1)          # [batch_size, self.N_tar, 1]\n        tar_offset_mean = self.mean_mlp(feat_in_repeat)                     # [batch_size, self.N_tar, 2]\n        # print(\"tar_candit_pro size: \", tar_candit_prob.size())\n        # print(\"tar_offset_mean size: \", tar_offset_mean.size())\n\n        # compute the prob. of normal distribution\n        d_x_dist = Normal(tar_offset_mean[:, :, 0], torch.tensor([1.0], device=self.device))    # [batch_size, self.N_tar]\n        d_y_dist = Normal(tar_offset_mean[:, :, 1], torch.tensor([1.0], device=self.device))    # [batch_size, self.N_tar]\n\n        d_x = d_x_dist.sample()\n        d_y = d_y_dist.sample()\n\n        # p = tar_candit_pro * d_x_dist.log_prob(d_x) * d_y_dist.log_prob(d_y)\n        _, indices = tar_candit_prob.topk(self.M, dim=1)\n\n        return tar_candit_prob, d_x, d_y, indices\n","AFTER":"        tar_offset_mean = self.mean_mlp(feat_in_repeat)                     # [batch_size, self.N_tar, 2]\n        # print(\"tar_candit_pro size: \", tar_candit_prob.size())\n        # print(\"tar_offset_mean size: \", tar_offset_mean.size())\n\n        # compute the prob. of normal distribution\n        offset = torch.normal(tar_offset_mean, std=1.0)\n\n        # p = tar_candit_pro * d_x_dist.log_prob(d_x) * d_y_dist.log_prob(d_y)\n        _, indices = tar_candit_prob.topk(self.M, dim=1)\n        batch_idx = torch.vstack([torch.arange(0, batch_size, device=self.device) for _ in range(self.M)]).T\n        return tar_candidate[batch_idx, indices], offset[batch_idx, indices]\n"}