{"BEFORE":"        is_raw_image = len(image.shape) == 4\n\n        text_emb = self.text_emb(text)\n        text_emb += self.text_pos_emb(torch.arange(text.shape[1], device = device))\n\n        if is_raw_image:\n            assert exists(self.vae), 'VAE must be passed into constructor if you are to train directly on raw images'\n            image_logits = self.vae(image, return_logits = True)\n            codebook_indices = image_logits.argmax(dim = 1).flatten(1)\n            image = codebook_indices\n\n        image_emb = self.image_emb(image)\n        image_emb += self.image_pos_emb(torch.arange(image.shape[1], device = device))\n\n        tokens = torch.cat((text_emb, image_emb), dim = 1)\n\n        if exists(mask):\n            mask = F.pad(mask, (0, self.image_seq_len), value = True)\n\n        out = self.transformer(tokens, mask = mask)\n        out = self.to_logits(out)\n\n        if not return_loss:\n            return out\n\n        offsetted_image = image + self.num_text_tokens\n        labels = torch.cat((text, offsetted_image), dim = 1)\n        labels = F.pad(labels, (0, 1), value = (self.total_tokens - 1)) # last token predicts EOS\n        loss = F.cross_entropy(out.transpose(1, 2), labels[:, 1:])\n","AFTER":"        eos_token_id = self.total_tokens - 1\n\n        tokens = self.text_emb(text)\n        tokens += self.text_pos_emb(torch.arange(text.shape[1], device = device))\n\n        if exists(image) and not is_empty(image):\n            is_raw_image = len(image.shape) == 4\n\n            if is_raw_image:\n                assert exists(self.vae), 'VAE must be passed into constructor if you are to train directly on raw images'\n                image_logits = self.vae(image, return_logits = True)\n                codebook_indices = image_logits.argmax(dim = 1).flatten(1)\n                image = codebook_indices\n\n            image_emb = self.image_emb(image)\n            image_emb += self.image_pos_emb(torch.arange(image.shape[1], device = device))\n\n            tokens = torch.cat((tokens, image_emb), dim = 1)\n\n            if exists(mask):\n                mask = F.pad(mask, (0, image_emb.shape[1]), value = True)\n\n        out = self.transformer(tokens, mask = mask)\n        logits = self.to_logits(out)\n\n        if not return_loss:\n            return logits\n\n        assert exists(image), 'when training, image must be supplied'\n\n        offsetted_image = image + self.num_text_tokens\n        labels = torch.cat((text, offsetted_image), dim = 1)\n        labels = F.pad(labels, (0, 1), value = eos_token_id) # last token predicts EOS\n        loss = F.cross_entropy(logits.transpose(1, 2), labels[:, 1:])\n"}