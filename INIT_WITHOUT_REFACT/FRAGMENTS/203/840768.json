{"BEFORE":"    def forward(self, output, target, target_weights):\n        \"\"\"Forward function.\"\"\"\n        batch_size = output.size(0)\n        num_joints = output.size(1)\n        if num_joints < self.topk:\n            raise ValueError(f'topk ({self.topk}) should not '\n                             f'larger than num_joints ({num_joints}).')\n        heatmaps_pred = output.reshape(\n            (batch_size, num_joints, -1)).split(1, 1)\n        heatmaps_gt = target.reshape((batch_size, num_joints, -1)).split(1, 1)\n\n        losses = []\n        for idx in range(num_joints):\n            heatmap_pred = heatmaps_pred[idx].squeeze(1)\n            heatmap_gt = heatmaps_gt[idx].squeeze(1)\n            if self.use_target_weight:\n                target_weight = target_weights[:, idx, None]\n                losses.append(\n                    self.criterion(heatmap_pred * target_weight,\n                                   heatmap_gt * target_weight))\n            else:\n                losses.append(self.criterion(heatmap_pred, heatmap_gt))\n","AFTER":"    def forward(self, output: Tensor, target: Tensor,\n                target_weights: Tensor) -> Tensor:\n        \"\"\"Forward function of loss.\n\n        Note:\n            - batch_size: B\n            - num_keypoints: K\n            - heatmaps height: H\n            - heatmaps weight: W\n\n        Args:\n            output (Tensor): The output heatmaps with shape [B, K, H, W].\n            target (Tensor): The target heatmaps with shape [B, K, H, W].\n            target_weights (Tensor): The target weights of differet keypoints,\n                with shape [B, K].\n\n        Returns:\n            Tensor: The calculated loss.\n        \"\"\"\n        num_keypoints = output.size(1)\n        if num_keypoints < self.topk:\n            raise ValueError(f'topk ({self.topk}) should not be '\n                             f'larger than num_keypoints ({num_keypoints}).')\n\n        losses = []\n        for idx in range(num_keypoints):\n            if self.use_target_weight:\n                target_weight = target_weights[:, idx, None, None]\n                losses.append(\n                    self.criterion(output[:, idx] * target_weight,\n                                   target[:, idx] * target_weight))\n            else:\n                losses.append(self.criterion(output[:, idx], target[:, idx]))\n"}