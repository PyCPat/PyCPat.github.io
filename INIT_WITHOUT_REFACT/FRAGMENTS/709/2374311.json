{"BEFORE":"            density_grid = torch.zeros([self.cascade] + [128] * 3) # [CAS, H, H, H]\n","AFTER":"                 min_near=0.2,\n                 density_thresh=0.01,\n                 ):\n        super().__init__()\n\n        self.bound = bound\n        self.cascade = 1 + math.ceil(math.log2(bound))\n        self.grid_size = 128\n        self.density_scale = density_scale\n        self.min_near = min_near\n        self.density_thresh = density_thresh\n\n        # prepare aabb with a 6D tensor (xmin, ymin, zmin, xmax, ymax, zmax)\n        # NOTE: aabb (can be rectangular) is only used to generate points, we still rely on bound (always cubic) to calculate density grid and hashing.\n        aabb_train = torch.FloatTensor([-bound, -bound, -bound, bound, bound, bound])\n        aabb_infer = aabb_train.clone()\n        self.register_buffer('aabb_train', aabb_train)\n        self.register_buffer('aabb_infer', aabb_infer)\n\n        # extra state for cuda raymarching\n        self.cuda_ray = cuda_ray\n        if cuda_ray:\n            # density grid\n            density_grid = torch.zeros([self.cascade] + [self.grid_size] * 3) # [CAS, H, H, H]\n            density_bitfield = torch.zeros(self.cascade * self.grid_size ** 3 \/\/ 8, dtype=torch.uint8) # [CAS * H * H * H \/\/ 8]\n            self.register_buffer('density_grid', density_grid)\n            self.register_buffer('density_bitfield', density_bitfield)\n"}