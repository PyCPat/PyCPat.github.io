{"BEFORE":"        x = self.transformer(x)\n\n        # get cls token\n\n        x = x[:, 0]\n\n        # out in the paper is linear(relu(ln(cls)))\n\n        return self.to_logits(x)\n","AFTER":"    def forward(self, x_categ, x_numer, return_attn = False):\n        assert x_categ.shape[-1] == self.num_categories, f'you must pass in {self.num_categories} values for your categories input'\n\n        xs = []\n        if self.num_unique_categories > 0:\n            x_categ += self.categories_offset\n\n            x_categ = self.categorical_embeds(x_categ)\n\n            xs.append(x_categ)\n\n        # add numerically embedded tokens\n        if self.num_continuous > 0:\n            x_numer = self.numerical_embedder(x_numer)\n\n            xs.append(x_numer)\n\n        # concat categorical and numerical\n\n        x = torch.cat(xs, dim = 1)\n\n        # append cls tokens\n        b = x.shape[0]\n        cls_tokens = repeat(self.cls_token, '1 1 d -> b 1 d', b = b)\n        x = torch.cat((cls_tokens, x), dim = 1)\n\n        # attend\n\n        x, attns = self.transformer(x, return_attn = True)\n\n        # get cls token\n\n        x = x[:, 0]\n\n        # out in the paper is linear(relu(ln(cls)))\n\n        logits = self.to_logits(x)\n\n        if not return_attn:\n            return logits\n\n        return logits, attns\n"}