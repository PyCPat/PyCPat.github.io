{"BEFORE":"        self.net = nn.Sequential(OrderedDict([\n            # Input: N x channels_noise x 1 x 1\n            ('block1', self._block(channels_noise, features_g * 16, 4, 1, 0)),  # img: 4x4\n            ('block2', self._block(features_g * 16, features_g * 8, 4, 2, 1)),  # img: 8x8\n            ('block3', self._block(features_g * 8, features_g * 4, 4, 2, 1)),  # img: 16x16\n            ('block4', self._block(features_g * 4, features_g * 2, 4, 2, 1)),  # img: 32x32\n            ('transpose_conv_out', nn.ConvTranspose2d(\n                features_g * 2, channels_img, kernel_size=4,\n                stride=2, padding=1, bias=False)),\n            # Output: N x channels_img x 64 x 64\n            ('tanh', nn.Tanh()),\n            ]))\n","AFTER":"    def __init__(self, channels_noise, channels_img, features_g, img_size=64):\n        super(Generator, self).__init__()\n        n_blocks = int(math.log2(64\/4))\n        block_list = [\n            ('block1', self._block(channels_noise, features_g * (2**n_blocks), 4, 1, 0)),  # img: 4x4\n            ]\n        block_list.extend([\n        (f'block{a}', self._block(features_g * 2**b, features_g * 2**(b-1), 4, 2, 1))\n                for (a,b) in zip(range(1,n_blocks+1), range(n_blocks+1,1,-1))][1:])\n\n        full_list = [\n            # Input: N x channels_noise x 1 x 1\n            *block_list,\n            ('transpose_conv_out', nn.ConvTranspose2d(\n                features_g * 2, channels_img, kernel_size=4,\n                stride=2, padding=1, bias=False)),\n            # Output: N x channels_img x img_size x img_size\n            ('tanh', nn.Tanh()),\n            ]\n        self.net = nn.Sequential(OrderedDict(full_list))\n"}