{"BEFORE":"        pd_target = self.pd_target\n\n        generators = ripser_parallel(\n            X.detach(),\n            return_generators=True\n        )['gens']\n\n        # TODO: Is this always required? Can we calculate this in\n        # a smarter fashion?\n        #\n        # Calculate distances in the source space and select the\n        # appropriate tuples later on.\n        source_distances = torch.cdist(X, X, p=2)\n\n        generators_0d = generators[0]\n        generators_1d = generators[1]\n\n        edge_indices_0d = generators_0d[:, 1:]\n        edge_indices_1d = generators_1d[0][:, 0:]\n\n        destroyers_0d = source_distances[\n            edge_indices_0d[:, 0], edge_indices_0d[:, 1]\n        ]\n\n        creators_1d = source_distances[\n            edge_indices_1d[:, 0], edge_indices_1d[:, 1]\n        ]\n\n        destroyers_1d = source_distances[\n            edge_indices_1d[:, 2], edge_indices_1d[:, 3]\n        ]\n\n        persistence_0d = destroyers_0d\n        persistence_1d = destroyers_1d - creators_1d\n\n        persistence_diagram_0d = torch.stack(\n            (torch.zeros_like(persistence_0d), destroyers_0d), 1\n        )\n\n        persistence_diagram_1d = torch.stack(\n            (creators_1d, destroyers_1d), 1\n        )\n\n        source_total_persistence = persistence_0d.pow(2).sum() + persistence_1d.pow(2).sum()\n        target_total_persistence = _total_persistence(pd_target[0]) + _total_persistence(pd_target[1])\n\n        loss = torch.abs(source_total_persistence - target_total_persistence)\n","AFTER":"        persistence_diagram_0d = torch.stack(\n            (torch.zeros_like(persistence_0d), destroyers_0d), 1\n        )\n\n        persistence_diagram_1d = torch.stack(\n            (creators_1d, destroyers_1d), 1\n        )\n\n        loss = self.loss(\n            [persistence_diagram_0d, persistence_diagram_1d]\n        )\n"}