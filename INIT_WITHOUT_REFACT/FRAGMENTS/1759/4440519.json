{"BEFORE":"        in_out = list(zip(dims[:-1], dims[1:]))\n\n        self.downs = nn.ModuleList([])\n        self.ups = nn.ModuleList([])\n\n        num_resolutions = len(in_out)\n\n        # resnet or convnext\n\n        blocks = partial(ConvNextBlock) if use_convnext else partial(ResnetBlock, groups = resnet_groups)\n\n        # modules for all layers\n\n        skip_dims = []\n\n        for ind, (dim_in, dim_out) in enumerate(in_out):\n            is_last = ind >= (num_resolutions - 1)\n            skip_dims.append(dim_in)\n\n            self.downs.append(nn.ModuleList([\n                blocks(dim_in, dim_in),\n                blocks(dim_in, dim_in),\n                Downsample(dim_in, dim_out)\n            ]))\n\n        mid_dim = dims[-1]\n        self.mid = blocks(mid_dim, mid_dim)\n        self.mid_attn = Attention(mid_dim)\n        self.mid_after = blocks(mid_dim, mid_dim)\n        self.mid_upsample = Upsample(mid_dim, dims[-2])\n\n        for ind, (dim_in, dim_out) in enumerate(reversed(in_out[:-1])):\n","AFTER":"        nested_unet_depths = (0, 0, 0, 0),\n        nested_unet_dim = 32,\n        channels = 3,\n        use_convnext = False,\n        resnet_groups = 8,\n        consolidate_upsample_fmaps = True\n    ):\n        super().__init__()\n        self.channels = channels\n\n        init_dim = default(init_dim, dim)\n        self.init_conv = nn.Conv3d(channels, init_dim, (1, 7, 7), padding = (0, 3, 3))\n\n        dims = [init_dim, *map(lambda m: dim * m, dim_mults)]\n        in_out = list(zip(dims[:-1], dims[1:]))\n\n        self.downs = nn.ModuleList([])\n        self.ups = nn.ModuleList([])\n\n        num_resolutions = len(in_out)\n\n        # resnet or convnext\n\n        blocks = partial(ConvNextBlock) if use_convnext else partial(ResnetBlock, groups = resnet_groups)\n\n        # whether to use nested unet, as in unet squared paper\n\n        nested_unet_depths = cast_tuple(nested_unet_depths, num_resolutions)\n\n        # modules for all layers\n\n        skip_dims = []\n\n        for ind, ((dim_in, dim_out), nested_unet_depth) in enumerate(zip(in_out, nested_unet_depths)):\n            is_last = ind >= (num_resolutions - 1)\n            skip_dims.append(dim_in)\n\n            self.downs.append(nn.ModuleList([\n                blocks(dim_in, dim_in, nested_unet_depth = nested_unet_depth, nested_unet_dim = nested_unet_dim),\n                blocks(dim_in, dim_in, nested_unet_depth = nested_unet_depth, nested_unet_dim = nested_unet_dim),\n                Downsample(dim_in, dim_out)\n            ]))\n\n        mid_dim = dims[-1]\n        self.mid = blocks(mid_dim, mid_dim)\n        self.mid_attn = Attention(mid_dim)\n        self.mid_after = blocks(mid_dim, mid_dim)\n        self.mid_upsample = Upsample(mid_dim, dims[-2])\n\n        for ind, ((dim_in, dim_out), nested_unet_depth) in enumerate(zip(reversed(in_out[:-1]), reversed(nested_unet_depths[:-1]))):\n"}