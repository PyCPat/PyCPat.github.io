{"BEFORE":"    def __init__(self, in_channel, num_classes, dropout=0.1, bit=8, latent_dim=32):\n        super(PoER, self).__init__()\n        self.backbone = ResNet18(in_channel)\n        channel_in = self.backbone.out_plane\n        self.bitlayer = BitLayer(bit)\n    \n        self.cls_head = nn.Sequential(\n            self.cls_block(channel_in, 256, dropout),\n            self.cls_block(256, 128, dropout),\n            nn.Linear(128, num_classes))\n        \n        self.ranking_head = nn.Sequential(\n            self.cls_block(channel_in, 256, dropout),\n            self.cls_block(256, 128, dropout),\n            nn.Linear(128, latent_dim))\n        \n        self.recon_head = Decoder(output_dim=in_channel, hidden_dim=channel_in)\n","AFTER":"    def __init__(self, num_classes, depth, pretrained=True, dropout=0., latent_dim=128, num_prototypes=2):\n        super(ResNetCls, self).__init__()\n        if depth == 18:\n            model = resnet18(pretrained=pretrained)\n        elif depth == 34:\n            model = resnet34(pretrained=pretrained)\n        else:\n            model = resnet50(pretrained=pretrained)\n        \n        in_channel = model.fc.in_features\n        self.backbone = model\n        del self.backbone.fc\n\n        self.cls_head = nn.Sequential(\n            self.cls_block(in_channel, 256, dropout),\n            nn.Linear(256, latent_dim),\n            nn.InstanceNorm1d(latent_dim))\n        \n        self.pool = nn.AdaptiveAvgPool2d((1, 1))\n        self.prototypes = nn.Embedding(num_classes * num_prototypes, latent_dim)\n        self.num_classes = num_classes\n"}