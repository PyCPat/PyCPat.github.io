{"BEFORE":"        layer_outputs = []\n        output = []\n\n        for i, (mdef, module) in enumerate(zip(self.module_defs, self.module_list)):\n            mtype = mdef['type']\n            if mtype in ['convolutional', 'upsample', 'maxpool']:\n                x = module(x)\n            elif mtype == 'route':\n                layers = [int(x) for x in mdef['layers'].split(',')]\n                if len(layers) == 1:\n                    x = layer_outputs[layers[0]]\n                else:\n                    try:\n                        x = torch.cat([layer_outputs[i] for i in layers], 1)\n                    except:  # apply stride 2 for darknet reorg layer\n                        layer_outputs[layers[1]] = F.interpolate(layer_outputs[layers[1]], scale_factor=[0.5, 0.5])\n                        x = torch.cat([layer_outputs[i] for i in layers], 1)\n                    # print(''), [print(layer_outputs[i].shape) for i in layers], print(x.shape)\n            elif mtype == 'shortcut':\n                x = x + layer_outputs[int(mdef['from'])]\n","AFTER":"        layer_outputs = []\n        output = []\n        verbose = False\n        if verbose:\n            print('0', x.shape)\n\n        for i, (mdef, module) in enumerate(zip(self.module_defs, self.module_list)):\n            mtype = mdef['type']\n            if mtype in ['convolutional', 'upsample', 'maxpool']:\n                x = module(x)\n            elif mtype == 'route':\n                layers = [int(x) for x in mdef['layers'].split(',')]\n                if len(layers) == 1:\n                    x = layer_outputs[layers[0]]\n                else:\n                    try:\n                        x = torch.cat([layer_outputs[i] for i in layers], 1)\n                    except:  # apply stride 2 for darknet reorg layer\n                        layer_outputs[layers[1]] = F.interpolate(layer_outputs[layers[1]], scale_factor=[0.5, 0.5])\n                        x = torch.cat([layer_outputs[i] for i in layers], 1)\n                    # print(''), [print(layer_outputs[i].shape) for i in layers], print(x.shape)\n            elif mtype == 'shortcut':\n                j = int(mdef['from'])\n                if verbose:\n                    print('shortcut adding layer %g-%s to %g-%s' % (j, layer_outputs[j].shape, i - 1, x.shape))\n                x = x + layer_outputs[j]\n            elif mtype == 'yolo':\n                output.append(module(x, img_size))\n            layer_outputs.append(x if i in self.routs else [])\n            if verbose:\n                print(i, x.shape)\n\n        if self.training:\n"}