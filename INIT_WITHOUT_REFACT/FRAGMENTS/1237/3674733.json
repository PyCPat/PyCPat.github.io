{"BEFORE":"        masked_vector = target_location_logits.masked_fill((1 - mask).bool(), mask_fill_value)\r\n        target_location_probs = self.softmax(masked_vector)\r\n        location_id = torch.multinomial(target_location_probs, num_samples=1, replacement=True)\r\n\r\n        if target_location is None:\r\n            target_location = np.zeros([batch_size, 2])\r\n            for i, idx in enumerate(location_id):\r\n                row_number = idx \/\/ self.output_map_size\r\n                col_number = idx - self.output_map_size * row_number\r\n\r\n                target_location_y = row_number\r\n                target_location_x = col_number\r\n                print(\"target_location_x, target_location_y\", target_location_x, target_location_y) if debug else None\r\n                # note! sc2 and pysc2 all accept the position as [x, y], so x be the first, y be the last!\r\n                # below is right! so the location point map to the point in the matrix!\r\n                target_location[i] = np.array([target_location_x.item(), target_location_y.item()])\r\n\r\n            target_location = torch.tensor(target_location, device=device)\r\n        print('target_location', target_location) if debug else None\r\n        print('target_location.shape', target_location.shape) if debug else None\r\n\r\n        # AlphaStar: If `action_type` does not involve targetting location, this head is ignored.\r\n        target_location_mask = L.action_involve_targeting_location_mask(action_type)\r\n\r\n        target_location_logits = target_location_logits.reshape(-1, self.output_map_size, self.output_map_size)\r\n        target_location_logits = target_location_logits * target_location_mask.float().unsqueeze(-1)\r\n\r\n        no_target_location_mask = ~target_location_mask.squeeze(dim=1)\r\n        #target_location = target_location * target_location_mask.long()\r\n        target_location = target_location.long()\r\n        target_location[no_target_location_mask] = torch.tensor([self.output_map_size - 1, self.output_map_size - 1], device=device)\r\n","AFTER":"        target_location_mask = L.action_involve_targeting_location_mask(action_type)\r\n        no_target_location_mask = ~target_location_mask.squeeze(dim=1)\r\n\r\n        # AlphaStar: (masking out invalid locations using `action_type`, such as those outside \r\n        # the camera for build actions)\r\n        # TODO: use action to decide the mask\r\n        # referenced from lib\/utils.py function of masked_softmax()\r\n        mask = torch.zeros(batch_size, 1 * self.output_map_size * self.output_map_size, device=device)\r\n        mask = L.get_location_mask(mask)\r\n        mask_fill_value = -1e32  # a very small number\r\n        target_location_logits = target_location_logits.masked_fill((1 - mask).bool(), mask_fill_value)\r\n\r\n        if target_location is None:\r\n            target_location_probs = self.softmax(target_location_logits)\r\n            location_id = torch.multinomial(target_location_probs, num_samples=1, replacement=True)\r\n\r\n            target_location = np.zeros([batch_size, 2])\r\n            for i, idx in enumerate(location_id):\r\n                row_number = idx \/\/ self.output_map_size\r\n                col_number = idx - self.output_map_size * row_number\r\n\r\n                target_location_y = row_number\r\n                target_location_x = col_number\r\n                print(\"target_location_x, target_location_y\", target_location_x, target_location_y) if debug else None\r\n                # note! sc2 and pysc2 all accept the position as [x, y], so x be the first, y be the last!\r\n                # below is right! so the location point map to the point in the matrix!\r\n                target_location[i] = np.array([target_location_x.item(), target_location_y.item()])\r\n\r\n            target_location = torch.tensor(target_location, device=device).long()\r\n            target_location[no_target_location_mask] = torch.tensor([self.output_map_size - 1, self.output_map_size - 1], device=device)\r\n\r\n            print('target_location', target_location) if debug else None\r\n            print('target_location.shape', target_location.shape) if debug else None\r\n"}