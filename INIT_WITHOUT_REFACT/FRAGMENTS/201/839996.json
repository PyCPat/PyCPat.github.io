{"BEFORE":"    def forward(self, x, image_ids, image_scales):\n        class_out, box_out, indices, classes = self.model(x)\n\n        # FIXME do this in PyTorch\n        batch_detections = []\n        class_out = class_out.cpu().numpy()\n        box_out = box_out.cpu().numpy()\n        if self._anchor_cache is None:\n            anchor_boxes = self.anchors.boxes.cpu().numpy()\n            self._anchor_cache = anchor_boxes\n        else:\n            anchor_boxes = self._anchor_cache\n        indices = indices.cpu().numpy()\n        classes = classes.cpu().numpy()\n        image_ids = image_ids.cpu().numpy()\n        image_scale = image_scales.cpu().numpy()\n        for i in range(x.shape[0]):\n            detections = generate_detections(\n                class_out[i], box_out[i], anchor_boxes, indices[i], classes[i],\n                image_ids[i], image_scale[i], self.config.num_classes)\n            batch_detections.append(detections)\n\n        return batch_detections\n","AFTER":"        class_out, box_out = self.model(x)\n        class_out, box_out, indices, classes = _post_process(self.config, class_out, box_out)\n\n        anchor_boxes = self._anchor_cache.get(\n            class_out.device, self.anchors.boxes.to(device=class_out.device))\n\n        batch_detections = []\n        for i in range(x.shape[0]):\n            detections = generate_detections_pt(\n                class_out[i], box_out[i], anchor_boxes, indices[i], classes[i], image_scales[i])\n            batch_detections.append(detections)\n        return torch.stack(batch_detections, dim=0)\n"}