{"BEFORE":"        if dev.simulate:\n            self.quantize = Quantize(num_bits=dev.DATA_BITS + output_shift if not wide else 1)\n            bits = dev.ACTIVATION_BITS if not wide else dev.FULL_ACC_BITS\n            self.clamp = Clamp(min_val=-(2**(bits-1)), max_val=2**(bits-1)-1)\n            if pooling == 'Avg':\n                self.quantize_pool = Round() if dev.round_avg else Floor()\n            else:  # Max, None\n                self.quantize_pool = Empty()\n        else:\n            self.quantize = Empty()\n            self.quantize_pool = Empty()\n            self.clamp = Clamp(min_val=-1., max_val=1.)  # Do not combine with ReLU\n\n        if pooling == 'Avg':\n            self.clamp_pool = self.clamp\n        else:  # Max, None\n            self.clamp_pool = Empty()\n\n        self.activate = get_activation(activation)\n","AFTER":"        assert not wide or activation is None\n\n        if pooling is not None:\n            if pool_stride is None:\n                pool_stride = pool_size\n\n            if isinstance(pool_size, int):\n                assert dev.device != 84 or pool_size & 1 == 0\n                assert pool_size <= 16 \\\n                    and (dev.device != 84 or pool_size <= 4 or pooling == 'Max')\n            elif isinstance(pool_size, tuple):\n                assert len(pool_size) == 2\n                assert dev.device != 84 or pool_size[0] & 1 == 0\n                assert pool_size[0] <= 16 \\\n                    and (dev.device != 84 or pool_size[0] <= 4 or pooling == 'Max')\n                assert dev.device != 84 or pool_size[1] & 1 == 0\n                assert pool_size[1] <= 16 \\\n                    and (dev.device != 84 or pool_size[1] <= 4 or pooling == 'Max')\n            else:\n                raise ValueError('pool_size must be int or tuple')\n\n            if isinstance(pool_stride, int):\n                assert pool_stride > 0\n                assert pool_stride <= 16 \\\n                    and (dev.device != 84 or pool_stride <= 4 or pooling == 'Max')\n            elif isinstance(pool_stride, tuple):\n                assert len(pool_stride) == 2\n                assert dev.device != 84 or pool_stride[0] == pool_stride[1]\n                assert 0 < pool_stride[0] <= 16 \\\n                    and (dev.device != 84 or pool_stride[0] <= 4 or pooling == 'Max')\n                assert 0 < pool_stride[1] <= 16 \\\n                    and (dev.device != 84 or pool_stride[1] <= 4 or pooling == 'Max')\n            else:\n                raise ValueError('pool_stride must be int or tuple')\n\n            assert stride == 1\n        else:\n            assert 0 < stride <= 3\n\n        assert 0 <= padding <= 2\n\n        if pooling == 'Max':\n            self.pool = nn.MaxPool2d(kernel_size=pool_size, stride=pool_stride, padding=0)\n        elif pooling == 'Avg':\n            self.pool = nn.AvgPool2d(kernel_size=pool_size, stride=pool_stride, padding=0)\n        else:\n            self.pool = None\n\n        if kernel_size is not None:\n            if isinstance(kernel_size, tuple):\n                assert len(kernel_size) == 2 and kernel_size[0] == kernel_size[1]\n                kernel_size = kernel_size[0]\n\n            assert kernel_size == 3 or dev.device != 84 and kernel_size == 1\n\n            if op == 'Conv2d':\n                self.conv2d = nn.Conv2d(in_channels, out_channels,\n                                        kernel_size=kernel_size, stride=stride,\n                                        padding=padding, bias=bias)\n            elif op == 'ConvTranspose2d':\n                assert dev.device != 84\n                self.conv2d = nn.ConvTranspose2d(in_channels, out_channels,\n                                                 kernel_size=kernel_size, stride=stride,\n                                                 padding=padding, bias=bias)\n            else:\n                raise ValueError('Unsupported operation')\n        else:\n            self.conv2d = None\n\n        self.quantize_pool, self.clamp_pool = quantize_clamp_pool(pooling)\n        self.quantize, self.clamp = quantize_clamp(wide, output_shift)\n"}