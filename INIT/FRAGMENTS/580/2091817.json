{"BEFORE":"        inputFeaturesForClassifier,\n        n_outputClasses,\n        final_convolution_layer: str = \"softmax\",\n    ):\n        super(VGG, self).__init__()\n        self.features = features\n        self.final_convolution_layer = get_final_layer(final_convolution_layer)\n        if n_dimensions == 2:\n            self.Conv = nn.Conv2d\n        elif n_dimensions == 3:\n            self.Conv = nn.Conv3d\n        else:\n            sys.exit(\"Only 2D or 3D convolutions are supported.\")\n\n        self.classifier = nn.Sequential(\n            nn.Dropout(),\n            nn.Linear(inputFeaturesForClassifier, 512),\n            nn.ReLU(True),\n            nn.Dropout(),\n            nn.Linear(512, 512),\n            nn.ReLU(True),\n            nn.Linear(512, 10),\n            nn.ReLU(True),\n            nn.Linear(10, n_outputClasses),\n        )\n","AFTER":"            self.avg_pool = GlobalAveragePooling2D()\n        elif n_dimensions == 3:\n            self.Conv = nn.Conv3d\n            self.avg_pool = GlobalAveragePooling3D()\n        else:\n            sys.exit(\"Only 2D or 3D convolutions are supported.\")\n\n        self.classifier = nn.Sequential(\n            nn.Dropout(),\n            nn.Linear(512, n_outputClasses) # Should be changed later, but works for all vgg right now\n        )\n        # Initialize weights\n        for m in self.modules():\n            if isinstance(m, self.Conv):\n                n = m.kernel_size[0] * m.kernel_size[1] * m.out_channels\n                m.weight.data.normal_(0, math.sqrt(2.0 \/ n))\n                m.bias.data.zero_()\n            elif isinstance(m, nn.Linear):\n                torch.nn.init.xavier_uniform(m.weight)\n            else:\n                pass\n"}