{"BEFORE":"        self.discriminator = nn.ModuleList([\n            nn.Sequential(\n                nn.utils.weight_norm(nn.Conv2d(1, 64, kernel_size=(5, 1), stride=(3, 1))),\n                nn.LeakyReLU(0.2, inplace=True),\n            ),\n            nn.Sequential(\n                nn.utils.weight_norm(nn.Conv2d(64, 128, kernel_size=(5, 1), stride=(3, 1))),\n                nn.LeakyReLU(0.2, inplace=True),\n            ),\n            nn.Sequential(\n                nn.utils.weight_norm(nn.Conv2d(128, 256, kernel_size=(5, 1), stride=(3, 1))),\n                nn.LeakyReLU(0.2, inplace=True),\n            ),\n            nn.Sequential(\n                nn.utils.weight_norm(nn.Conv2d(256, 512, kernel_size=(5, 1), stride=(3, 1))),\n                nn.LeakyReLU(0.2, inplace=True),\n            ),\n            nn.Sequential(\n                nn.utils.weight_norm(nn.Conv2d(512, 1024, kernel_size=(5, 1))),\n                nn.LeakyReLU(0.2, inplace=True),\n            ),\n            nn.utils.weight_norm(nn.Conv2d(1024, 1, kernel_size=(3, 1))),\n        ])\n","AFTER":"        layer = []\n        self.period = period\n        inp = 1\n        for l in range(4):\n            out = int(2 ** (5 + l + 1))\n            layer += [\n                nn.utils.weight_norm(nn.Conv2d(inp, out, kernel_size=(5, 1), stride=(3, 1))),\n                nn.LeakyReLU(0.2)\n            ]\n            inp = out\n        self.layer = nn.Sequential(*layer)\n        self.output = nn.Sequential(\n            nn.utils.weight_norm(nn.Conv2d(out, 1024, kernel_size=(5, 1))),\n            nn.LeakyReLU(0.2),\n            nn.utils.weight_norm(nn.Conv2d(1024, 1, kernel_size=(3, 1)))\n        )\n"}