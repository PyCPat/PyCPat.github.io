{"BEFORE":"        squeezed_channels = make_divisible(int(channels * ratio), 8)\n        gating_fn = gating_fn if gating_fn else _SE_GATING_FN\n\n        self.se = nn.Sequential(OrderedDict([\n            ('pooling', nn.AdaptiveAvgPool2d((1, 1))),\n            ('reduce', Conv2d1x1(channels, squeezed_channels, bias=True)),\n            ('relu', inner_activation_fn(inplace=True)),\n            ('expand', Conv2d1x1(squeezed_channels, channels, bias=True)),\n            ('sigmoid', gating_fn()),\n        ]))\n","AFTER":"        squeezed_channels = make_divisible(int(channels * ratio), _SE_DIVISOR)\n        gating_fn = gating_fn if gating_fn else _SE_GATING_FN\n\n        layers = OrderedDict([])\n\n        layers['pooling'] = nn.AdaptiveAvgPool2d((1, 1))\n        layers['reduce'] = Conv2d1x1(channels, squeezed_channels, bias=True)\n        if _SE_USE_NORM:\n            layers['norm'] = nn.BatchNorm2d(squeezed_channels)\n        layers['relu'] = inner_activation_fn(inplace=True)\n        layers['expand'] = Conv2d1x1(squeezed_channels, channels, bias=True)\n        layers['sigmoid'] = gating_fn()\n\n        self.se = nn.Sequential(layers)\n"}