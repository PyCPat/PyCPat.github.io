{"BEFORE":"        self.erb_stage = ErbStage()\n        self.mask = Mask(erb_inv_fb, post_filter=p.mask_pf)\n        self.refinement_stages: List[SpectralRefinement]\n        self.refinement_stages = nn.ModuleList(  # type: ignore\n            SpectralRefinement(kernel_size_t=2 if i == 0 else 1, dilation=i + 1)\n            for i in range(self.n_stages)\n","AFTER":"        p = ModelParams()\n        assert p.nb_erb % 8 == 0, \"erb_bins should be divisible by 8\"\n        self.n_stages = p.n_stages\n        self.freq_bins = p.fft_size \/\/ 2 + 1\n        self.erb_bins = p.nb_erb\n        self.df_bins = p.nb_df\n        self.erb_stage = FreqStage(1, 1, nn.Sigmoid, p.conv_ch, p.nb_erb, p.erb_hidden_dim)\n        self.mask = Mask(erb_inv_fb, post_filter=p.mask_pf)\n        refinement_act = {\"tanh\": nn.Tanh, \"identity\": nn.Identity}[p.refinement_act.lower()]\n        self.refinement_stages = nn.ModuleList(\n            [\n                FreqStage(\n                    in_ch=2,\n                    out_ch=2,\n                    out_act=refinement_act,\n                    conv_ch=p.conv_ch,\n                    num_freqs=p.nb_df,\n                    hidden_dim=p.refinement_hidden_dim,\n                    patch_size=2 ** (i + 1),\n                    downsample_hprev=i >= 1,\n                )\n                for i in range(self.n_stages)\n            ]\n        )\n        self.lsnr_net = LSNRNet(p.conv_ch * 2, lsnr_min=p.lsnr_min, lsnr_max=p.lsnr_max)\n"}