{"BEFORE":"        patch_height_width = image_size \/\/ patch_size\n        num_patches = patch_height_width ** 2\n        pixel_patch_dim = channels * (patch_size ** 2)\n\n        # time conditioning\n\n        sinu_pos_emb = LearnedSinusoidalPosEmb(learned_sinusoidal_dim)\n        time_dim = dim * 4\n        fourier_dim = learned_sinusoidal_dim + 1\n\n        self.latent_token_time_cond = latent_token_time_cond\n        time_output_dim = dim_latent if latent_token_time_cond else time_dim\n\n        self.time_mlp = nn.Sequential(\n            sinu_pos_emb,\n            nn.Linear(fourier_dim, time_dim),\n            nn.GELU(),\n            nn.Linear(time_dim, time_output_dim)\n        )\n\n        # pixels to patch and back\n\n        self.to_patches = Sequential(\n            Rearrange('b c (h p1) (w p2) -> b (h w) (c p1 p2)', p1 = patch_size, p2 = patch_size),\n            nn.LayerNorm(pixel_patch_dim * 2) if dual_patchnorm else None,\n            nn.Linear(pixel_patch_dim * 2, dim),\n            nn.LayerNorm(dim) if dual_patchnorm else None,\n        )\n\n        self.axial_pos_emb = nn.Parameter(torch.randn(2, patch_height_width, dim) * 0.02)\n","AFTER":"        pos_emb_dim = dim \/\/ 2\n\n        self.axial_pos_emb_height_mlp = nn.Sequential(\n            Rearrange('... -> ... 1'),\n            nn.Linear(1, pos_emb_dim),\n            nn.SiLU(),\n            nn.Linear(pos_emb_dim, pos_emb_dim),\n            nn.SiLU(),\n            nn.Linear(pos_emb_dim, dim)\n        )\n\n        self.axial_pos_emb_width_mlp = nn.Sequential(\n            Rearrange('... -> ... 1'),\n            nn.Linear(1, pos_emb_dim),\n            nn.SiLU(),\n            nn.Linear(pos_emb_dim, pos_emb_dim),\n            nn.SiLU(),\n            nn.Linear(pos_emb_dim, dim)\n        )\n"}