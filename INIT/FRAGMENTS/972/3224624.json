{"BEFORE":"                 style='pytorch',\n                 sync_bn=False,\n                 with_cp=False,\n                 strict_frozen=False):\n        super(ResNet, self).__init__()\n        if not len(layers) == len(strides) == len(dilations):\n            raise ValueError(\n                'The number of layers, strides and dilations must be equal, '\n                'but found have {} layers, {} strides and {} dilations'.format(\n                    len(layers), len(strides), len(dilations)))\n        assert max(out_indices) < len(layers)\n        self.out_indices = out_indices\n        self.frozen_stages = frozen_stages\n        self.style = style\n        self.sync_bn = sync_bn\n        self.inplanes = 64\n        self.conv1 = nn.Conv2d(\n            3, 64, kernel_size=7, stride=2, padding=3, bias=False)\n        self.bn1 = nn.BatchNorm2d(64)\n        self.relu = nn.ReLU(inplace=True)\n        self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n        self.res_layers = []\n        for i, num_blocks in enumerate(layers):\n\n            stride = strides[i]\n            dilation = dilations[i]\n\n            layer_name = 'layer{}'.format(i + 1)\n            planes = 64 * 2**i\n            res_layer = make_res_layer(\n                block,\n                self.inplanes,\n                planes,\n                num_blocks,\n                stride=stride,\n                dilation=dilation,\n                style=self.style,\n                with_cp=with_cp)\n            self.inplanes = planes * block.expansion\n            self.add_module(layer_name, res_layer)\n            self.res_layers.append(layer_name)\n        self.feat_dim = block.expansion * 64 * 2**(len(layers) - 1)\n        self.with_cp = with_cp\n\n        self.strict_frozen = strict_frozen\n","AFTER":"                 style='pytorch',\n                 frozen_stages=-1,\n                 bn_eval=True,\n                 bn_frozen=False,\n                 with_cp=False):\n        super(ResNet, self).__init__()\n        if depth not in self.arch_settings:\n            raise KeyError('invalid depth {} for resnet'.format(depth))\n        assert num_stages >= 1 and num_stages <= 4\n        block, stage_blocks = self.arch_settings[depth]\n        stage_blocks = stage_blocks[:num_stages]\n        assert len(strides) == len(dilations) == num_stages\n        assert max(out_indices) < num_stages\n\n        self.out_indices = out_indices\n        self.style = style\n        self.frozen_stages = frozen_stages\n        self.bn_eval = bn_eval\n        self.bn_frozen = bn_frozen\n        self.with_cp = with_cp\n\n        self.inplanes = 64\n        self.conv1 = nn.Conv2d(\n            3, 64, kernel_size=7, stride=2, padding=3, bias=False)\n        self.bn1 = nn.BatchNorm2d(64)\n        self.relu = nn.ReLU(inplace=True)\n        self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n\n        self.res_layers = []\n        for i, num_blocks in enumerate(stage_blocks):\n            stride = strides[i]\n            dilation = dilations[i]\n            planes = 64 * 2**i\n            res_layer = make_res_layer(\n                block,\n                self.inplanes,\n                planes,\n                num_blocks,\n                stride=stride,\n                dilation=dilation,\n                style=self.style,\n                with_cp=with_cp)\n            self.inplanes = planes * block.expansion\n            layer_name = 'layer{}'.format(i + 1)\n"}