{"BEFORE":"                 eff_swish=False):\n        super(ReXNetV1, self).__init__()\n\n        layers = [1, 2, 2, 3, 3, 5]\n        strides = [1, 2, 2, 2, 1, 2]\n        layers = [ceil(element * depth_mult) for element in layers]\n        strides = sum([[element] + [1] * (layers[idx] - 1)\n                       for idx, element in enumerate(strides)], [])\n        ts = [1] * layers[0] + [6] * sum(layers[1:])\n        self.depth = sum(layers[:]) * 3\n\n        stem_channel = 32 \/ width_mult if width_mult < 1.0 else 32\n        inplanes = input_ch \/ width_mult if width_mult < 1.0 else input_ch\n\n        features = []\n        in_channels_group = []\n        channels_group = []\n\n        _add_conv_swish(features, 3, int(round(stem_channel * width_mult)),\n                        kernel=3, stride=2, pad=1, eff_swish=eff_swish)\n\n        # The following channel configuration is a simple instance to make each layer become an expand layer.\n        for i in range(self.depth \/\/ 3):\n            if i == 0:\n                in_channels_group.append(int(round(stem_channel * width_mult)))\n                channels_group.append(int(round(inplanes * width_mult)))\n            else:\n                in_channels_group.append(int(round(inplanes * width_mult)))\n                inplanes += final_ch \/ (self.depth \/\/ 3 * 1.0)\n                channels_group.append(int(round(inplanes * width_mult)))\n\n        if use_se:\n            use_ses = [False] * (layers[0] + layers[1]) + \\\n                [True] * sum(layers[2:])\n        else:\n            use_ses = [False] * sum(layers[:])\n\n        for block_idx, (in_c, c, t, s, se) in enumerate(zip(in_channels_group, channels_group, ts, strides, use_ses)):\n            features.append(LinearBottleneck(in_channels=in_c,\n                                             channels=c,\n                                             t=t,\n                                             stride=s,\n                                             use_se=se, se_ratio=se_ratio,\n                                             eff_swish=eff_swish))\n\n        pen_channels = int(1280 * width_mult)\n        _add_conv_swish(features, c, pen_channels, eff_swish=eff_swish)\n","AFTER":"        use_ses = [False, False, True, True, True, True]\n\n        layers = [ceil(element * depth_mult) for element in layers]\n        strides = sum([[element] + [1] * (layers[idx] - 1)\n                       for idx, element in enumerate(strides)], [])\n        if use_se:\n            use_ses = sum([[element] * layers[idx] for idx, element in enumerate(use_ses)], [])\n        else:\n            use_ses = [False] * sum(layers[:])\n        ts = [1] * layers[0] + [6] * sum(layers[1:])\n\n        self.depth = sum(layers[:]) * 3\n        stem_channel = 32 \/ width_mult if width_mult < 1.0 else 32\n        inplanes = input_ch \/ width_mult if width_mult < 1.0 else input_ch\n\n        features = []\n        in_channels_group = []\n        channels_group = []\n\n        # The following channel configuration is a simple instance to make each layer become an expand layer.\n        for i in range(self.depth \/\/ 3):\n            if i == 0:\n                in_channels_group.append(int(round(stem_channel * width_mult)))\n                channels_group.append(int(round(inplanes * width_mult)))\n            else:\n                in_channels_group.append(int(round(inplanes * width_mult)))\n                inplanes += final_ch \/ (self.depth \/\/ 3 * 1.0)\n                channels_group.append(int(round(inplanes * width_mult)))\n\n        ConvBNSwish(features, 3, int(round(stem_channel * width_mult)), kernel=3, stride=2, pad=1)\n\n        for block_idx, (in_c, c, t, s, se) in enumerate(zip(in_channels_group, channels_group, ts, strides, use_ses)):\n            features.append(LinearBottleneck(in_channels=in_c,\n                                             channels=c,\n                                             t=t,\n                                             stride=s,\n                                             use_se=se, se_ratio=se_ratio))\n\n        pen_channels = int(1280 * width_mult)\n        ConvBNSwish(features, c, pen_channels)\n"}