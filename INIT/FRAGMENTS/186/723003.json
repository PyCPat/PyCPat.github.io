{"BEFORE":"        self.noise_mlp = PositionalEncoding(inner_channel*4)\n\n        self.start_conv = nn.Conv2d(in_channel, inner_channel,\n                                    kernel_size=3, padding=1)\n        pre_channel = inner_channel\n        downs = []\n        num_mults = len(channel_mults)\n        self.skip_start = int((1-skip_range)*num_mults*res_blocks)\n\n        for ind in range(num_mults):\n            is_last = (ind == num_mults - 1)\n            channel_mult = inner_channel * channel_mults[ind]\n            for _ in range(0, res_blocks-1):\n                downs.append(ResBlockUp(\n                    pre_channel, channel_mult, use_affine_level=use_affine_level, noise_channel=inner_channel*4, dropout=dropout, stride=1))\n                pre_channel = channel_mult\n            if not is_last:\n                downs.append(ResBlockUp(\n                    pre_channel, pre_channel, use_affine_level=use_affine_level, noise_channel=inner_channel*4, dropout=dropout, stride=2))\n        self.downs = nn.ModuleList(downs)\n\n        ups = []\n        for ind in reversed(range(num_mults)):\n            is_last = (ind < 1)\n            channel_mult = inner_channel * channel_mults[ind]\n            for _ in range(0, res_blocks-1):\n                ups.append(ResBlockDown(\n                    pre_channel, channel_mult, use_affine_level=use_affine_level, noise_channel=inner_channel*4, dropout=dropout, stride=1))\n                pre_channel = channel_mult\n            if not is_last:\n","AFTER":"        noise_channel = inner_channel*4\n        self.noise_mlp = PositionalEncoding(noise_channel)\n\n        self.start_conv = nn.Conv2d(in_channel, inner_channel,\n                                    kernel_size=3, padding=1)\n        pre_channel = inner_channel\n        num_mults = len(channel_mults)\n        self.skip_start = int((1-skip_range)*num_mults*res_blocks)\n\n        downs = []\n        for ind in range(num_mults):\n            is_last = (ind == num_mults - 1)\n            channel_mult = inner_channel * channel_mults[ind]\n            for _ in range(0, res_blocks-1):\n                downs.append(ResBlockDown(\n                    pre_channel, channel_mult, use_affine_level=use_affine_level, noise_channel=noise_channel, dropout=dropout, stride=1))\n                pre_channel = channel_mult\n            if not is_last:\n                downs.append(ResBlockDown(\n                    pre_channel, pre_channel, use_affine_level=use_affine_level, noise_channel=noise_channel, dropout=dropout, stride=2))\n        self.downs = nn.ModuleList(downs)\n\n        ups = []\n        for ind in reversed(range(num_mults)):\n            is_last = (ind == num_mults - 1)\n            channel_mult = inner_channel * channel_mults[ind]\n            ups.append(ResBlockUp(\n                pre_channel, channel_mult, use_affine_level=use_affine_level, noise_channel=noise_channel, dropout=dropout, stride=1))\n            pre_channel = channel_mult\n            if not is_last:\n                ups.append(ResBlockUp(\n                    pre_channel, pre_channel, use_affine_level=use_affine_level, noise_channel=noise_channel, dropout=dropout, stride=2))\n            for _ in range(0, res_blocks-2):\n                ups.append(ResBlockUp(\n                    pre_channel, channel_mult, use_affine_level=use_affine_level, noise_channel=noise_channel, dropout=dropout, stride=1))\n                pre_channel = channel_mult\n        self.ups = nn.ModuleList(ups)\n"}