{"BEFORE":"        downs = [nn.Conv2d(in_channel, inner_channel, 3)]\n        for ind in range(num_mults):\n            is_last = (ind < num_mults - 1)\n            use_attn = (channel_mults[ind] in attn_mults)\n            channel_mult = inner_channel * channel_mults[ind]\n            for _ in range(0, res_blocks):\n                downs.append(ResnetBlock(\n                    pre_channel, channel_mult, time_emb_dim=time_dim))\n                if use_attn:\n                    downs.append(SelfAttention(channel_mult))\n                feat_channels.append(channel_mult)\n                pre_channel = channel_mult\n            if not is_last:\n                downs.append(Downsample(pre_channel))\n                feat_channels.append(pre_channel)\n        self.downs = nn.ModuleList(downs)\n\n        self.mid = nn.ModuleList([\n            ResnetBlock(pre_channel, pre_channel, time_emb_dim=time_dim,\n                        dropout=dropout),\n            SelfAttention(pre_channel),\n            ResnetBlock(pre_channel, pre_channel,\n                        time_emb_dim=time_dim, dropout=dropout)\n        ])\n\n        ups = []\n        for ind in reversed(range(num_mults)):\n            is_last = (ind < 1)\n            use_attn = (channel_mults[ind] in attn_mults)\n            channel_mult = inner_channel * channel_mults[ind]\n            for _ in range(0, res_blocks+1):\n                ups.append(ResnetBlock(\n                    pre_channel+feat_channels.pop(), channel_mult, time_emb_dim=time_dim))\n                if use_attn:\n                    ups.append(SelfAttention(channel_mult))\n                pre_channel = channel_mult\n            ups.append(Upsample(pre_channel)\n                       if not is_last else nn.Identity())\n","AFTER":"        image_size=128\n    ):\n        super().__init__()\n\n        if with_time_emb:\n            time_dim = inner_channel\n            self.time_mlp = nn.Sequential(\n                TimeEmbedding(inner_channel),\n                nn.Linear(inner_channel, inner_channel * 4),\n                Swish(),\n                nn.Linear(inner_channel * 4, inner_channel)\n            )\n        else:\n            time_dim = None\n            self.time_mlp = None\n\n        num_mults = len(channel_mults)\n        pre_channel = inner_channel\n        feat_channels = [pre_channel]\n        now_res = image_size\n        downs = [nn.Conv2d(in_channel, inner_channel,\n                           kernel_size=3, padding=1)]\n        for ind in range(num_mults):\n            is_last = (ind == num_mults - 1)\n            use_attn = (now_res in attn_res)\n            channel_mult = inner_channel * channel_mults[ind]\n            for _ in range(0, res_blocks):\n                downs.append(ResnetBlocWithAttn(\n                    pre_channel, channel_mult, time_emb_dim=time_dim, dropout=dropout, with_attn=use_attn))\n                feat_channels.append(channel_mult)\n                pre_channel = channel_mult\n            if not is_last:\n                downs.append(Downsample(pre_channel))\n                feat_channels.append(pre_channel)\n                now_res = now_res\/\/2\n        self.downs = nn.ModuleList(downs)\n\n        self.mid = nn.ModuleList([\n            ResnetBlocWithAttn(pre_channel, pre_channel, time_emb_dim=time_dim,\n                               dropout=dropout, with_attn=True),\n            ResnetBlocWithAttn(pre_channel, pre_channel,\n                               time_emb_dim=time_dim, dropout=dropout, with_attn=False)\n        ])\n\n        ups = []\n        for ind in reversed(range(num_mults)):\n            is_last = (ind < 1)\n            use_attn = (now_res in attn_res)\n            channel_mult = inner_channel * channel_mults[ind]\n            for _ in range(0, res_blocks+1):\n                ups.append(ResnetBlocWithAttn(\n                    pre_channel+feat_channels.pop(), channel_mult, time_emb_dim=time_dim, dropout=dropout, with_attn=use_attn))\n                pre_channel = channel_mult\n            if not is_last:\n                ups.append(Upsample(pre_channel))\n                now_res = now_res*2\n\n        self.ups = nn.ModuleList(ups)\n"}