{"BEFORE":"        l = []\n        for n_out, ksize, p in zip(num_filters, filter_size, pool_size):\n            l += [ \n                nn.Conv1d(n_in, n_out, kernel_size=ksize, dilation=2**dilation, padding=2**dilation*(ksize\/\/2)),\n                nn.MaxPool1d(p, stride=1, padding=p\/\/2) if p > 1 else nn.Identity(),\n                nn.GroupNorm(1, n_out), # same as LayerNorm?\n                nn.CELU(), \n                nn.Dropout(p=dropout_rate) ]\n            n_in = n_out\n        self.net = nn.Sequential(*l)\n","AFTER":"    def __init__(self, n_in, num_filters=(128,), filter_size=(7,), pool_size=(1,), dilation=1, dropout_rate=0.0, resnet=False):\n        super(CNNLayer, self).__init__()\n        self.resnet = resnet\n        self.net = []\n        for n_out, ksize, p in zip(num_filters, filter_size, pool_size):\n            self.net.append( \n                nn.Sequential( \n                    nn.Conv1d(n_in, n_out, kernel_size=ksize, dilation=2**dilation, padding=2**dilation*(ksize\/\/2)),\n                    nn.MaxPool1d(p, stride=1, padding=p\/\/2) if p > 1 else nn.Identity(),\n                    nn.GroupNorm(1, n_out), # same as LayerNorm?\n                    nn.CELU(), \n                    nn.Dropout(p=dropout_rate) ) )\n"}