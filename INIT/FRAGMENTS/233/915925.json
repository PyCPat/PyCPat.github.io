{"BEFORE":"        combining_operation: str = \"mean\",\n        num_layers: int = 2,\n        num_hiddens: int = 40,\n        output_dim: int = 20,\n    ):\n        \"\"\"Permutation invariant multi-layer NN.\n\n        The trial_net is applied to each \"trial\" of the input\n        and is combined by the combining_operation (mean or sum) to construct a\n        permutation invariant embedding across iid trials.\n        This embedding is embedded again using an additional fully connected net.\n\n        Args:\n            trial_net: Network to process one trial. The combining_operation is\n                applied to its output. Takes as input (batch, input_dim), where\n                input_dim is the dimensionality of a single trial. Produces output\n                (batch, latent_dim).\n                Remark: This network should be large enough as it acts on all (iid)\n                inputs seperatley and needs enough capacity to process the information\n                of all inputs.\n            trial_net_output_dim: Dimensionality of the output of the trial_net \/ input\n                to the fully connected layers.\n            combining_operation: How to combine the permutational dimensions, one of\n                'mean' or 'sum'.\n            num_layers: Number of fully connected layer, minimum of 2.\n            num_hiddens: Number of hidden dimensions in fully-connected layers.\n            output_dim: Dimensionality of the output.\n        \"\"\"\n        super().__init__()\n        self.trial_net = trial_net\n        self.combining_operation = combining_operation\n\n        # define function for permutation invariant embedding\n        if combining_operation == \"mean\":\n            self.combining_function = torch.mean\n        elif self.combining_operation == \"sum\":\n            self.combining_function = torch.sum\n        else:\n            raise ValueError(\"combining_operation must be in ['sum', 'mean'].\")\n\n        # construct fully connected layers\n        self.fc_subnet = FCEmbedding(\n","AFTER":"        aggregation_fn: Optional[str] = \"sum\",\n        num_hiddens: int = 100,\n        num_layers: int = 2,\n        output_dim: int = 20,\n        aggregation_dim: int = 1,\n    ):\n        \"\"\"Permutation invariant multi-layer NN.\n\n        Applies the trial_net to every trial to obtain trial embeddings.\n        It then aggregates the trial embeddings across the aggregation dimension to\n        construct a permutation invariant embedding across iid trials.\n        The resulting embedding is processed further using an additional fully\n        connected net. The input to the final embedding net is the trial_net output\n        plus the number of trials N: (batch, trial_net_output_dim + 1)\n\n        If the data x has varying number of trials per batch element, missing trials\n        should be encoded as NaNs. In the forward pass, the NaNs are masked.\n\n        Args:\n            trial_net: Network to process one trial. The combining_operation is\n                applied to its output. Takes as input (batch, input_dim), where\n                input_dim is the dimensionality of a single trial. Produces output\n                (batch, latent_dim).\n                Remark: This network should be large enough as it acts on all (iid)\n                inputs seperatley and needs enough capacity to process the information\n                of all inputs.\n            trial_net_output_dim: Dimensionality of the output of the trial_net.\n            aggregation_fn: Function to aggregate the trial embeddings. Defaults to\n                taking the sum over the non-nan values.\n            num_layers: Number of fully connected layer, minimum of 2.\n            num_hiddens: Number of hidden dimensions in fully-connected layers.\n            output_dim: Dimensionality of the output.\n            aggregation_dim: Dimension along which to aggregate the trial embeddings.\n        \"\"\"\n        super().__init__()\n        self.trial_net = trial_net\n        self.aggregation_dim = aggregation_dim\n        assert aggregation_fn in [\n            \"mean\",\n            \"sum\",\n        ], \"aggregation_fn must be 'mean' or 'sum'.\"\n        self.aggregation_fn = aggregation_fn\n"}