{"BEFORE":"        in_out = list(zip(dims[:-1], dims[1:]))\n\n        self.downs = nn.ModuleList([])\n        self.ups = nn.ModuleList([])\n\n        num_resolutions = len(in_out)\n\n        # resnet or convnext\n\n        blocks = partial(ConvNextBlock) if use_convnext else partial(ResnetBlock, groups = resnet_groups)\n\n        # whether to use nested unet, as in unet squared paper\n\n        nested_unet_depths = cast_tuple(nested_unet_depths, num_resolutions)\n\n        # modules for all layers\n\n        skip_dims = []\n\n        for ind, ((dim_in, dim_out), nested_unet_depth) in enumerate(zip(in_out, nested_unet_depths)):\n            is_last = ind >= (num_resolutions - 1)\n            skip_dims.append(dim_in)\n\n            self.downs.append(nn.ModuleList([\n                blocks(dim_in, dim_in, nested_unet_depth = nested_unet_depth, nested_unet_dim = nested_unet_dim),\n                blocks(dim_in, dim_in, nested_unet_depth = nested_unet_depth, nested_unet_dim = nested_unet_dim),\n                Downsample(dim_in, dim_out)\n            ]))\n\n        mid_dim = dims[-1]\n        self.mid = blocks(mid_dim, mid_dim)\n        self.mid_attn = Attention(mid_dim)\n        self.mid_after = blocks(mid_dim, mid_dim)\n        self.mid_upsample = Upsample(mid_dim, dims[-2])\n\n        for ind, ((dim_in, dim_out), nested_unet_depth) in enumerate(zip(reversed(in_out[:-1]), reversed(nested_unet_depths[:-1]))):\n            is_last = ind >= (num_resolutions - 1)\n\n            self.ups.append(nn.ModuleList([\n                blocks(dim_out + skip_dims.pop(), dim_out, nested_unet_depth = nested_unet_depth, nested_unet_dim = nested_unet_dim),\n                blocks(dim_out, dim_out, nested_unet_depth = nested_unet_depth, nested_unet_dim = nested_unet_dim),\n","AFTER":"        num_blocks_per_stage = (2, 2, 2, 2),\n        nested_unet_depths = (0, 0, 0, 0),\n        nested_unet_dim = 32,\n        channels = 3,\n        use_convnext = False,\n        resnet_groups = 8,\n        consolidate_upsample_fmaps = True\n    ):\n        super().__init__()\n        self.channels = channels\n\n        init_dim = default(init_dim, dim)\n        self.init_conv = nn.Conv3d(channels, init_dim, (1, 7, 7), padding = (0, 3, 3))\n\n        dims = [init_dim, *map(lambda m: dim * m, dim_mults)]\n        in_out = list(zip(dims[:-1], dims[1:]))\n\n        self.downs = nn.ModuleList([])\n        self.ups = nn.ModuleList([])\n\n        num_resolutions = len(in_out)\n\n        # resnet or convnext\n\n        blocks = partial(ConvNextBlock) if use_convnext else partial(ResnetBlock, groups = resnet_groups)\n\n        # whether to use nested unet, as in unet squared paper\n\n        nested_unet_depths = cast_tuple(nested_unet_depths, num_resolutions)\n\n        # number of blocks per stage\n\n        num_blocks_per_stage = cast_tuple(num_blocks_per_stage, num_resolutions)\n        assert all([num_blocks > 0 for num_blocks in num_blocks_per_stage])\n\n        # modules for all layers\n\n        skip_dims = []\n\n        down_stage_parameters = [\n            in_out,\n            nested_unet_depths,\n            num_blocks_per_stage\n        ]\n\n        up_stage_parameters = [reversed(params[:-1]) for params in down_stage_parameters]\n\n        # downs\n\n        for ind, ((dim_in, dim_out), nested_unet_depth, num_blocks) in enumerate(zip(*down_stage_parameters)):\n            is_last = ind >= (num_resolutions - 1)\n            skip_dims.append(dim_in)\n\n            self.downs.append(nn.ModuleList([\n                blocks(dim_in, dim_in, nested_unet_depth = nested_unet_depth, nested_unet_dim = nested_unet_dim),\n                nn.ModuleList([blocks(dim_in, dim_in, nested_unet_depth = nested_unet_depth, nested_unet_dim = nested_unet_dim) for _ in range(num_blocks - 1)]),\n                Downsample(dim_in, dim_out)\n            ]))\n\n        # middle\n\n        mid_dim = dims[-1]\n        mid_nested_unet_depth = nested_unet_depths[-1]\n\n        self.mid = blocks(mid_dim, mid_dim, nested_unet_depth = mid_nested_unet_depth, nested_unet_dim = nested_unet_dim)\n        self.mid_attn = Attention(mid_dim)\n        self.mid_after = blocks(mid_dim, mid_dim, nested_unet_depth = mid_nested_unet_depth, nested_unet_dim = nested_unet_dim)\n\n        self.mid_upsample = Upsample(mid_dim, dims[-2])\n\n        # ups\n\n        for ind, ((dim_in, dim_out), nested_unet_depth, num_blocks) in enumerate(zip(*up_stage_parameters)):\n            is_last = ind >= (num_resolutions - 1)\n\n            self.ups.append(nn.ModuleList([\n                blocks(dim_out + skip_dims.pop(), dim_out, nested_unet_depth = nested_unet_depth, nested_unet_dim = nested_unet_dim),\n                nn.ModuleList([blocks(dim_out, dim_out, nested_unet_depth = nested_unet_depth, nested_unet_dim = nested_unet_dim) for _ in range(num_blocks - 1)]),\n"}