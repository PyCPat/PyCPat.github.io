{"BEFORE":"        out_dim = default(out_dim, channels)\n        self.final_conv = nn.Sequential(\n            block_klass(dim, dim),\n            nn.Conv2d(dim, out_dim, 1)\n","AFTER":"        learned_variance = False\n    ):\n        super().__init__()\n\n        # determine dimensions\n\n        self.channels = channels\n\n        init_dim = default(init_dim, dim \/\/ 3 * 2)\n        self.init_conv = nn.Conv2d(channels, init_dim, 7, padding = 3)\n\n        dims = [init_dim, *map(lambda m: dim * m, dim_mults)]\n        in_out = list(zip(dims[:-1], dims[1:]))\n\n        block_klass = partial(ResnetBlock, groups = resnet_block_groups)\n\n        # time embeddings\n\n        if with_time_emb:\n            time_dim = dim * 4\n            self.time_mlp = nn.Sequential(\n                SinusoidalPosEmb(dim),\n                nn.Linear(dim, time_dim),\n                nn.GELU(),\n                nn.Linear(time_dim, time_dim)\n            )\n        else:\n            time_dim = None\n            self.time_mlp = None\n\n        # layers\n\n        self.downs = nn.ModuleList([])\n        self.ups = nn.ModuleList([])\n        num_resolutions = len(in_out)\n\n        for ind, (dim_in, dim_out) in enumerate(in_out):\n            is_last = ind >= (num_resolutions - 1)\n\n            self.downs.append(nn.ModuleList([\n                block_klass(dim_in, dim_out, time_emb_dim = time_dim),\n                block_klass(dim_out, dim_out, time_emb_dim = time_dim),\n                Residual(PreNorm(dim_out, LinearAttention(dim_out))),\n                Downsample(dim_out) if not is_last else nn.Identity()\n            ]))\n\n        mid_dim = dims[-1]\n        self.mid_block1 = block_klass(mid_dim, mid_dim, time_emb_dim = time_dim)\n        self.mid_attn = Residual(PreNorm(mid_dim, Attention(mid_dim)))\n        self.mid_block2 = block_klass(mid_dim, mid_dim, time_emb_dim = time_dim)\n\n        for ind, (dim_in, dim_out) in enumerate(reversed(in_out[1:])):\n            is_last = ind >= (num_resolutions - 1)\n\n            self.ups.append(nn.ModuleList([\n                block_klass(dim_out * 2, dim_in, time_emb_dim = time_dim),\n                block_klass(dim_in, dim_in, time_emb_dim = time_dim),\n                Residual(PreNorm(dim_in, LinearAttention(dim_in))),\n                Upsample(dim_in) if not is_last else nn.Identity()\n            ]))\n\n        default_out_dim = channels * (1 if not learned_variance else 2)\n        self.out_dim = default(out_dim, default_out_dim)\n\n        self.final_conv = nn.Sequential(\n            block_klass(dim, dim),\n            nn.Conv2d(dim, self.out_dim, 1)\n"}