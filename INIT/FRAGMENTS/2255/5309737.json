{"BEFORE":"        self.ismlp = ismlp\n        c = [1, 4, 32]\n        f = [feat_len, 16, 1]\n        if not self.ismlp:\n            self.feat1 = FeatTrans1d(in_channels=c[0], in_features=f[0], out_channels=c[1], out_features=f[1])\n            self.acvt1 = nn.Sequential(nn.BatchNorm1d(c[1]), nn.Softsign())\n            self.feat2 = FeatTrans1d(in_channels=c[1], in_features=f[1], out_channels=c[2], out_features=f[2])\n            self.acvt2 = nn.Sequential(nn.BatchNorm1d(c[2]), nn.Softsign())\n            self.classifier = nn.Sequential(nn.Flatten(), nn.Dropout(p=0.1), nn.Linear(c[2]*f[2], num_class))\n        else:\n            print(\"usinf mlpp\")\n            self.feat1 = Mlp(in_channels=c[0], in_features=f[0], out_channels=c[1], out_features=f[1])\n            self.acvt1 = nn.Sequential(nn.BatchNorm1d(c[1]), nn.Softsign())\n            self.feat2 = Mlp(in_channels=c[1], in_features=f[1], out_channels=c[2], out_features=f[2])\n            self.acvt2 = nn.Sequential(nn.BatchNorm1d(c[2]), nn.Softsign())\n            self.classifier = nn.Sequential(nn.Flatten(), nn.Dropout(p=0.1), nn.Linear(c[2]*f[2], num_class))\n\n    def forward(self, x, neighbor):\n","AFTER":"    def __init__(self, feat_len, num_class, hidden = [64, 32], ismlp = False):\n        ## the Flag ismlp will encode without neighbor\n        super(LGL, self).__init__()\n        self.ismlp = ismlp\n        c = [1, 4, hidden[1]]\n        f = [feat_len, 16, 1]\n            \n        self.feat1 = FeatTrans1d(in_channels=c[0], in_features=f[0], out_channels=c[1], out_features=f[1])\n        self.acvt1 = nn.Sequential(nn.BatchNorm1d(c[1]), nn.Softsign())\n        self.feat2 = FeatTrans1d(in_channels=c[1], in_features=f[1], out_channels=c[2], out_features=f[2])\n        self.acvt2 = nn.Sequential(nn.BatchNorm1d(c[2]), nn.Softsign())\n        self.classifier = nn.Sequential(nn.Flatten(), nn.Dropout(p=0.1), nn.Linear(c[2]*f[2], num_class))\n"}