{"BEFORE":"    def __init__(self, imheight, n_layers, n_out, kernels, strides, batch_norm, max_pool):\r\n        \"\"\"imheight :\r\n        :param imheight: height of the images that will be given as input of the network.\r\n        The height needs to be fixed, not the width.\r\n        :param n_layers: number of layers of the feature extractor\r\n        :param n_out: number of channels that each convolutional layer should output.\r\n        :param kernels: list : size of the kernel of each convolutional layer\r\n        :param strides: list : stride for each convolutional layer\r\n        :param batch_norm: list of booleans : says if batch normalization is to be applied at the end of each layer\r\n        :param max_pool: list : says if maxpooling is to bo applied at the end of each layer, and the size of the\r\n        eventual maxpooling\r\n        \"\"\"\r\n        super(FeatureExtractor, self).__init__()\r\n        list_layers = []\r\n        # Create layers iteratively\r\n        for k in range(n_layers):\r\n            if k == 0:\r\n                n_in = imheight\r\n            else:\r\n                n_in = n_out[k-1]\r\n            list_layers.append(('conv{0}'.format(k), nn.Conv2d(n_in, n_out[k], kernel_size=kernels[k], stride=strides[k])))\r\n            if batch_norm[k]:\r\n                list_layers.append(('batchnorm{0}'.format(k), nn.BatchNorm2d(n_out[k])))\r\n            list_layers.append(('relu{0}'.format(k), nn.ReLU()))\r\n            if max_pool[k] != 0:\r\n                list_layers.append(('maxpool{0}'.format(k), nn.MaxPool2d(kernel_size=max_pool[k])))\r\n\r\n        # Create network\r\n        self.network = nn.Sequential(OrderedDict(list_layers))\r\n","AFTER":"        network = nn.Sequential()\r\n        # Create layers iteratively\r\n        for k in range(n_layers):\r\n            if k == 0:\r\n                n_in = imheight\r\n            else:\r\n                n_in = n_out[k-1]\r\n            network.add_module('conv{0}'.format(k), nn.Conv2d(n_in,\r\n                                                              n_out[k],\r\n                                                              kernel_size=conv['kernel'][k],\r\n                                                              stride=conv['stride'][k],\r\n                                                              padding=conv['padding'][k]))\r\n            if batch_norm[k]:\r\n                network.add_module('batchnorm{0}'.format(k), nn.BatchNorm2d(n_out[k]))\r\n            network.add_module('relu{0}'.format(k), nn.ReLU())\r\n            if max_pool['kernel'][k] != 0:\r\n                network.add_module('maxpool{0}'.format(k),\r\n                                   nn.MaxPool2d(kernel_size=max_pool['kernel'][k],\r\n                                                stride=max_pool['stride'][k],\r\n                                                padding=max_pool['padding'][k]))\r\n\r\n        # Create network\r\n        self.network = network\r\n"}