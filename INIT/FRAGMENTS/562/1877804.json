{"BEFORE":"        bn_epsilon: float = None,\n        bn_momentum: float = None,\n        normalizer_fn: nn.Module = nn.BatchNorm2d,\n        activation_fn: nn.Module = None\n    ):\n        super().__init__()\n\n        bn_epsilon = bn_epsilon if bn_epsilon else _BN_EPSILON\n        bn_momentum = bn_momentum if bn_momentum else _BN_MOMENTUM\n        activation_fn = activation_fn if activation_fn else _NONLINEAR\n\n        self.has_se = se_ratio is not None and se_ratio > 0 and se_ratio <= 1\n        self.use_shortcut = stride != 1 or inp != oup * self.expansion\n\n        if width_per_group != 64:\n            raise ValueError('width_per_group are not supported!')\n\n        self.branch1 = nn.Sequential(OrderedDict([\n            ('conv1', Conv2d3x3(inp, oup, stride=stride, groups=groups)),\n            ('norm1', normalizer_fn(oup, eps=bn_epsilon, momentum=bn_momentum)),\n            ('relu1', activation_fn(inplace=True)),\n            ('conv2', Conv2d3x3(oup, oup)),\n            ('norm2', normalizer_fn(oup, eps=bn_epsilon, momentum=bn_momentum))\n        ]))\n\n        if self.has_se:\n            self.branch1.add_module('se', SEBlock(oup, se_ratio))\n\n        if drop_connect_rate:\n            self.branch1.add_module('drop', DropPath(drop_connect_rate))\n\n        self.branch2 = nn.Identity()\n\n        if self.use_shortcut:\n            if use_resnetd_shortcut and stride != 1:\n                self.branch2 = nn.Sequential(OrderedDict([\n                    ('pool', nn.AvgPool2d(2, stride=stride)),\n                    ('conv', Conv2d1x1(inp, oup * self.expansion))\n                ]))\n            else:\n                self.branch2 = nn.Sequential(OrderedDict([\n                    ('conv', Conv2d1x1(inp, oup * self.expansion, stride=stride))\n                ]))\n            self.branch2.add_module(\n                'norm', normalizer_fn(\n                    oup * self.expansion, eps=bn_epsilon, momentum=bn_momentum)\n            )\n","AFTER":"        normalizer_fn = normalizer_fn or _NORMALIZER\n        activation_fn = activation_fn or _NONLINEAR\n\n        self.has_se = se_ratio is not None and se_ratio > 0 and se_ratio <= 1\n        self.use_shortcut = stride != 1 or inp != oup * self.expansion\n\n        if width_per_group != 64:\n            raise ValueError('width_per_group are not supported!')\n\n        self.branch1 = nn.Sequential(OrderedDict([\n            ('conv1', Conv2d3x3(inp, oup, stride=stride, groups=groups)),\n            ('norm1', normalizer_fn(oup)),\n            ('relu1', activation_fn()),\n            ('conv2', Conv2d3x3(oup, oup)),\n            ('norm2', normalizer_fn(oup))\n        ]))\n\n        if self.has_se:\n            self.branch1.add_module('se', SEBlock(oup, se_ratio))\n\n        if drop_path_rate:\n            self.branch1.add_module('drop', DropPath(1. - drop_path_rate))\n\n        self.branch2 = nn.Identity()\n\n        if self.use_shortcut:\n            if use_resnetd_shortcut and stride != 1:\n                self.branch2 = nn.Sequential(OrderedDict([\n                    ('pool', nn.AvgPool2d(2, stride=stride)),\n                    ('conv', Conv2d1x1(inp, oup)),\n                    ('norm', normalizer_fn(oup))\n                ]))\n            else:\n                self.branch2 = nn.Sequential(OrderedDict([\n                    ('conv', Conv2d1x1(inp, oup, stride=stride)),\n                    ('norm', normalizer_fn(oup))\n"}