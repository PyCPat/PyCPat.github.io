{"BEFORE":"        output_dim: int = 20,\n        num_fully_connected: int = 2,\n        num_hiddens: int = 120,\n        out_channels_cnn_1: int = 10,\n        out_channels_cnn_2: int = 16,\n        kernel_size: int = 5,\n        pool_size=4,\n    ):\n        \"\"\"Multi-layer (C)NN\n            First two layers are convolutional, followed by fully connected layers.\n            Performing 1d convolution and max pooling with preset configs.\n\n        Args:\n            input_dim: Dimensionality of input.\n            output_dim: Dimensionality of the output.\n            num_conv: Number of convolutional layers.\n            num_fully_connected: Number fully connected layer, minimum of 2.\n            num_hiddens: Number of hidden dimensions in fully-connected layers.\n            out_channels_cnn_1: Number of oputput channels for the first convolutional\n                layer.\n            out_channels_cnn_2: Number of oputput channels for the second\n                convolutional layer.\n            kernel_size: Kernel size for both convolutional layers.\n            pool_size: pool size for MaxPool1d operation after the convolutional\n                layers.\n\n            Remark: The implementation of the convolutional layers was not tested\n            rigourously. While it works for the default configuration parameters it\n            might cause shape conflicts fot badly chosen parameters.\n        \"\"\"\n        super().__init__()\n        self.input_dim = input_dim\n        self.output_dim = output_dim\n        self.num_hiddens = num_hiddens\n\n        # construct convolutional-pooling subnet\n        pool = nn.MaxPool1d(pool_size)\n        conv_layers = [\n            nn.Conv1d(1, out_channels_cnn_1, kernel_size, padding=\"same\"),\n            nn.ReLU(),\n            pool,\n            nn.Conv1d(\n                out_channels_cnn_1, out_channels_cnn_2, kernel_size, padding=\"same\"\n            ),\n            nn.ReLU(),\n            pool,\n        ]\n        self.conv_subnet = nn.Sequential(*conv_layers)\n\n        # construct fully connected layers\n        input_dim_fc = out_channels_cnn_2 * (int(input_dim \/ out_channels_cnn_2))\n","AFTER":"        num_linear_units: int = 50,\n        output_dim: int = 20,\n        kernel_size: int = 5,\n        pool_kernel_size: int = 2,\n    ):\n        \"\"\"Convolutional embedding network.\n        First two layers are convolutional, followed by fully connected layers.\n\n        Automatically infers whether to apply 1D or 2D convolution depending on\n        input_shape.\n        Allows usage of multiple (color) channels by passing in_channels > 1.\n\n        Args:\n            input_shape: Dimensionality of input, e.g., (28,) for 1D, (28, 28) for 2D.\n            in_channels: Number of image channels, default 1.\n            out_channels_per_layer: Number of out convolutional out_channels for each\n                layer. Must match the number of layers passed below.\n            num_cnn_layers: Number of convolutional layers.\n            num_linear_layers: Number fully connected layer.\n            num_linear_units: Number of hidden units in fully-connected layers.\n            output_dim: Number of output units of the final layer.\n            kernel_size: Kernel size for both convolutional layers.\n            pool_size: pool size for MaxPool1d operation after the convolutional\n                layers.\n        \"\"\"\n        super(CNNEmbedding, self).__init__()\n\n        assert isinstance(\n            input_shape, Tuple\n        ), \"input_shape must be a Tuple of size 1 or 2, e.g., (width, [height]).\"\n        assert (\n            0 < len(input_shape) < 3\n        ), \"\"\"input_shape must be a Tuple of size 1 or 2, e.g.,\n            (width, [height]). Number of input channels are passed separately\"\"\"\n\n        use_2d_cnn = len(input_shape) == 2\n        conv_module = nn.Conv2d if use_2d_cnn else nn.Conv1d\n        pool_module = nn.MaxPool2d if use_2d_cnn else nn.MaxPool1d\n\n        assert (\n            len(out_channels_per_layer) == num_conv_layers\n        ), \"out_channels needs as many entries as num_cnn_layers.\"\n\n        # define input shape with channel\n        self.input_shape = (in_channels, *input_shape)\n\n        # Construct CNN feature extractor.\n        cnn_layers = []\n        cnn_output_size = input_shape\n        stride = 1\n        padding = 1\n        for ii in range(num_conv_layers):\n            # Defining another 2D convolution layer\n            conv_layer = conv_module(\n                in_channels=in_channels if ii == 0 else out_channels_per_layer[ii - 1],\n                out_channels=out_channels_per_layer[ii],\n                kernel_size=kernel_size,\n                stride=stride,\n                padding=padding,\n            )\n            pool = pool_module(kernel_size=pool_kernel_size)\n            cnn_layers += [conv_layer, nn.ReLU(inplace=True), pool]\n            # Calculate change of output size of each CNN layer\n            cnn_output_size = get_new_cnn_output_size(cnn_output_size, conv_layer, pool)\n\n        self.cnn_subnet = nn.Sequential(*cnn_layers)\n"}