{"BEFORE":"        for size, std, mgrid in zip(kernel_size, sigma, meshgrids):\n            mean = (size - 1) \/ 2\n            kernel *= 1 \/ (std * math.sqrt(2 * math.pi)) * \\\n                      torch.exp(-((mgrid - mean) \/ (2 * std)) ** 2)\n\n        # Make sure sum of values in gaussian kernel equals 1.\n        kernel = kernel \/ torch.sum(kernel)\n","AFTER":"    def __init__(self, channels, kernel_size, sigma, dim=2, cuda=False, padding=lambda x: x, kernel_f='gaussian'):\n        super().__init__()\n        if isinstance(kernel_size, numbers.Number):\n            kernel_size = [kernel_size] * dim\n        if isinstance(sigma, numbers.Number):\n            sigma = [sigma] * dim\n        self.kernel_f = kernel_f\n\n        # The gaussian kernel is the product of the\n        # gaussian function of each dimension.\n        kernel = 1\n        meshgrids = torch.meshgrid(\n            [\n                torch.arange(size, dtype=torch.float32)\n                for size in kernel_size\n            ]\n        )\n        if self.kernel_f == 'gaussian':\n            for size, std, mgrid in zip(kernel_size, sigma, meshgrids):\n                mean = (size - 1) \/ 2\n                kernel *= 1 \/ (std * math.sqrt(2 * math.pi)) * \\\n                          torch.exp(-((mgrid - mean) \/ (2 * std)) ** 2)\n        elif self.kernel_f == 'laplacian':\n            for size, std, mgrid in zip(kernel_size, sigma, meshgrids):\n                mean = (size - 1) \/ 2\n                kernel *= 1 \/ (2 * std) * torch.exp(-torch.abs((mgrid - mean)) \/ std)\n        else:\n            raise ValueError(\"Mode must either be gaussian or laplacian.\")\n\n        # Make sure sum of values in gaussian kernel equals 1.\n        kernel = kernel \/ torch.sum(kernel)\n"}