{"BEFORE":"    def __init__(self, dag, name='synth', fixed_params={}, static_params=[]):\n        \"\"\"\n        \n        Args:\n            dag (list of tuples): [(processor, {'param_name':'INPUT_KEY' or 'processor.name'})] \n            ex.)    [   \n                    (additive, {'amplitudes':'ADD_AMP', 'harmonic_distribution':'ADD_HARMONIC', 'f0_hz':'ADD_F0'}),\n                    (filter, {'input':'additive', 'cutoff':'CUTOFF'}),\n                    ...\n                    ]\n            name (str, optional): Defaults to 'synth'.\n            fixed_params: Values of fixed parameters ex.) {'INPUT_KEY': Tensor([(n_frames), param_size])\n                          Value=None if the param is added to dict as conditioning later\n            static_params: These values use only the last frame of the input_tensor\n        \"\"\"\n        super().__init__()\n        self.dag = dag\n        self.name = name\n        self.ext_param_sizes = {}\n        self.processor_names = [processor.name for processor, connections in self.dag]\n        self.fixed_param_names = list(fixed_params.keys())\n        for k, v in fixed_params.items():\n            if v is not None:\n                self.register_buffer(k, v)\n            else:\n                setattr(self, k, None)\n        self.processors = nn.ModuleList([]) # register modules for .to(device)\n        self.dag_summary = {}\n        for processor, connections in self.dag:\n            self.processors.append(processor)\n            # parameters that rely on external input and not outputs of other modules and are not fixed\n            ext_params = [k for k, v in connections.items() if v not in self.processor_names+self.fixed_param_names]\n            ext_sizes = {connections[k]: desc['size'] for k, desc in processor.param_desc.items() if k in ext_params}\n            self.ext_param_sizes.update(ext_sizes)\n            # {'ADD_AMP':1, 'ADD_HARMONIC': n_harmonics, 'CUTOFF': ...}\n            # summarize dag\n            self.dag_summary.update({processor.name +'_'+ input_name: output_name for input_name, output_name in connections.items()})\n        self.ext_param_size = sum(self.ext_param_sizes.values())\n        self.static_params = static_params\n","AFTER":"        self.processors = nn.ModuleList([p for p, _c in dag])\n        self.connections = tuple(dict(c) for _p, c in dag)\n        self.name = name\n        self.ext_param_sizes = {}\n        self.processor_names = [processor.name for processor in self.processors]\n        self.conditioned_params = list(conditioned)\n        self.dag_summary = {}\n        for processor, connections in zip(self.processors, self.connections):\n            # parameters that rely on external input and not outputs of other modules and are not conditioned\n            ext_params = [k for k, v in connections.items() if v not in self.processor_names+self.conditioned_params]\n            ext_sizes = {connections[k]: size for k, size in processor.param_sizes.items() if k in ext_params}\n"}