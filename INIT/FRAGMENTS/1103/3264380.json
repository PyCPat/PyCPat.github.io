{"BEFORE":"        self.sparse_shape = output_shape\n        self.output_shape = output_shape\n        self.in_channels = in_channels\n        self.pre_act = pre_act\n        self.base_channels = base_channels\n        self.output_channels = output_channels\n        self.encoder_channels = encoder_channels\n        self.encoder_paddings = encoder_paddings\n        self.decoder_channels = decoder_channels\n        self.decoder_paddings = decoder_paddings\n        self.stage_num = len(self.encoder_channels)\n        # Spconv init all weight on its own\n\n        if pre_act:\n            # TODO: use ConvModule to encapsulate\n            self.conv_input = spconv.SparseSequential(\n                spconv.SubMConv3d(\n                    in_channels,\n                    self.base_channels,\n                    3,\n                    padding=1,\n                    bias=False,\n                    indice_key='subm1'))\n            make_block = self.pre_act_block\n        else:\n            self.conv_input = spconv.SparseSequential(\n                spconv.SubMConv3d(\n                    in_channels,\n                    self.base_channels,\n                    3,\n                    padding=1,\n                    bias=False,\n                    indice_key='subm1'),\n                build_norm_layer(norm_cfg, self.base_channels)[1], nn.ReLU())\n            make_block = self.post_act_block\n\n        encoder_out_channels = self.make_encoder_layers(\n            make_block, norm_cfg, self.base_channels)\n        self.make_decoder_layers(make_block, norm_cfg, encoder_out_channels)\n\n        self.conv_out = spconv.SparseSequential(\n            # [200, 176, 5] -> [200, 176, 2]\n            spconv.SparseConv3d(\n                encoder_out_channels,\n                self.output_channels, (3, 1, 1),\n                stride=(2, 1, 1),\n                padding=0,\n                bias=False,\n                indice_key='spconv_down2'),\n            build_norm_layer(norm_cfg, self.output_channels)[1],\n            nn.ReLU())\n","AFTER":"        self.sparse_shape = sparse_shape\n        self.in_channels = in_channels\n        self.order = order\n        self.base_channels = base_channels\n        self.output_channels = output_channels\n        self.encoder_channels = encoder_channels\n        self.encoder_paddings = encoder_paddings\n        self.decoder_channels = decoder_channels\n        self.decoder_paddings = decoder_paddings\n        self.stage_num = len(self.encoder_channels)\n        # Spconv init all weight on its own\n\n        assert isinstance(order, tuple) and len(order) == 3\n        assert set(order) == {'conv', 'norm', 'act'}\n\n        if self.order[0] != 'conv':  # pre activate\n            self.conv_input = make_sparse_convmodule(\n                in_channels,\n                self.base_channels,\n                3,\n                norm_cfg=norm_cfg,\n                padding=1,\n                indice_key='subm1',\n                conv_type='SubMConv3d',\n                order=('conv', ))\n        else:  # post activate\n            self.conv_input = make_sparse_convmodule(\n                in_channels,\n                self.base_channels,\n                3,\n                norm_cfg=norm_cfg,\n                padding=1,\n                indice_key='subm1',\n                conv_type='SubMConv3d')\n\n        encoder_out_channels = self.make_encoder_layers(\n            make_sparse_convmodule, norm_cfg, self.base_channels)\n        self.make_decoder_layers(make_sparse_convmodule, norm_cfg,\n                                 encoder_out_channels)\n\n        self.conv_out = make_sparse_convmodule(\n            encoder_out_channels,\n            self.output_channels,\n            kernel_size=(3, 1, 1),\n            stride=(2, 1, 1),\n            norm_cfg=norm_cfg,\n            padding=0,\n            indice_key='spconv_down2',\n            conv_type='SparseConv3d')\n"}