{"BEFORE":"        loss = F.binary_cross_entropy_with_logits(input,target, reduction='none')\n\n        if self.neg_select_rule == 'none':\n            return loss\n\n        s_pos, = torch.where(target==1)\n        s_neg, = torch.where(target==0)\n\n        num_of_positives = s_pos.size(0)\n        num_of_negatives = s_neg.size(0)\n\n        min_num_of_negatives = int(target.size(0)*self.min_num_of_neg_ratio)\n        max_num_of_negatives = num_of_negatives\n\n        num_of_negatives = int(num_of_positives*self.neg_select_ratio)\n\n        if self.neg_select_rule == 'random':\n            # select negatives randomly\n            num_of_negatives = min(num_of_negatives, int(num_of_positives*self.random_ratio))\n            num_of_negatives = max(min_num_of_negatives, num_of_negatives)\n            num_of_negatives = min(max_num_of_negatives, num_of_negatives)\n            s_neg = random.sample(s_neg.cpu().numpy().tolist(), k=num_of_negatives)\n            if s_pos.size(0) == 0:\n                return loss[s_neg]\n            return torch.cat([loss[s_neg],loss[s_pos]])\n        elif self.neg_select_rule == 'ohem':\n            # select negatives using ohem\n            num_of_negatives = min(num_of_negatives, num_of_positives*self.ohem_ratio)\n            num_of_negatives = max(min_num_of_negatives, num_of_negatives)\n            num_of_negatives = min(max_num_of_negatives, num_of_negatives)\n            pos_loss = loss[s_pos]\n            neg_loss = loss[s_neg]\n            s_neg = neg_loss.argsort(descending=True)\n            neg_loss = neg_loss[s_neg][:num_of_negatives]\n            if pos_loss.size(0) == 0:\n                return neg_loss\n            return torch.cat([pos_loss,neg_loss])\n","AFTER":"        loss = F.binary_cross_entropy_with_logits(input,target, reduction='none')\n\n        if self.neg_select_rule == 'none':\n            return loss.mean()\n\n        s_pos, = torch.where(target==1)\n        s_neg, = torch.where(target==0)\n\n        num_of_positives = s_pos.size(0)\n        num_of_negatives = s_neg.size(0)\n        min_num_of_negatives = int(target.size(0)*self.min_num_of_neg_ratio)\n        max_num_of_negatives = num_of_negatives\n\n        num_of_negatives = int(num_of_positives*self.neg_select_ratio)\n\n        if self.neg_select_rule == 'random':\n            # select negatives randomly\n            num_of_negatives = int(num_of_positives*self.random_ratio)\n            num_of_negatives = max(min_num_of_negatives, num_of_negatives)\n            num_of_negatives = min(max_num_of_negatives, num_of_negatives)\n            num_of_negatives = max(num_of_negatives,1) # for safety\n            s_neg = random.sample(s_neg.cpu().numpy().tolist(), k=num_of_negatives)\n            if s_pos.size(0) == 0:\n                return loss[s_neg].mean()\n            return torch.cat([loss[s_neg],loss[s_pos]]).mean()\n        elif self.neg_select_rule == 'ohem':\n            # select negatives using ohem\n            num_of_negatives = min(num_of_negatives, num_of_positives*self.ohem_ratio)\n            num_of_negatives = max(min_num_of_negatives, num_of_negatives)\n            num_of_negatives = min(max_num_of_negatives, num_of_negatives)\n            pos_loss = loss[s_pos]\n            neg_loss = loss[s_neg]\n            s_neg = neg_loss.argsort(descending=True)\n            neg_loss = neg_loss[s_neg][:num_of_negatives]\n            if pos_loss.size(0) == 0:\n                return neg_loss.mean()\n            return torch.cat([pos_loss,neg_loss]).mean()\n"}