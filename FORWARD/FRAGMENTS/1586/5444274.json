{"BEFORE":"        targets = torch.cat([y, negatives], dim=0)\n\n        x = x.unsqueeze(-1)\n        x = self.project_to_steps(x)  # BxCxTxS\n        x = self.dropout(x)\n        x = x.unsqueeze(0).expand(targets.size(0), -1, -1, -1, -1)\n\n        copies, bsz, dim, tsz, steps = x.shape\n        steps = min(steps, tsz - self.offset)\n        predictions = x.new(bsz * copies * (tsz - self.offset + 1) * steps - ((steps + 1) * steps \/\/ 2) * copies * bsz)\n        labels = torch.zeros_like(predictions)\n        weights = torch.full_like(labels, 1 \/ self.n_negatives) if self.balanced_classes else None\n\n        start = end = 0\n        for i in range(steps):\n            offset = i + self.offset\n            end = start + (tsz - offset) * bsz * copies\n            pos_num = (end - start) \/\/ copies\n            predictions[start:end] = (x[..., :-offset, i] * targets[..., offset:]).sum(dim=2).flatten()\n            labels[start:start + pos_num] = 1.\n            if weights is not None:\n                weights[start:start + pos_num] = 1.\n            start = end\n        assert end == predictions.numel(), '{} != {}'.format(end, predictions.numel())\n\n        if weights is not None:\n            labels = (labels, weights)\n\n        return predictions, labels\n","AFTER":"        x = x.unsqueeze(-1)\n        x = self.project_to_steps(x)  # BxCxTxS\n        x = self.dropout(x)\n\n        negatives = self.sample_negatives(y)\n        y = y.unsqueeze(0)\n        targets = torch.cat([y, negatives], dim=0)  # Copies x B x C x T\n\n        copies = targets.size(0)\n        bsz, dim, tsz, steps = x.shape\n        steps = min(steps, tsz - self.offset)\n\n        predictions = x.new(\n            bsz * copies * (tsz - self.offset + 1) * steps\n            - ((steps + 1) * steps \/\/ 2) * copies * bsz\n        )\n        if self.infonce:\n            labels = predictions.new_full(\n                (predictions.shape[0] \/\/ copies,), 0, dtype=torch.long\n            )\n        else:\n            labels = torch.zeros_like(predictions)\n        weights = (\n            torch.full_like(labels, 1 \/ self.n_negatives)\n            if self.balanced_classes and not self.infonce\n            else None\n        )\n\n        start = end = 0\n        for i in range(steps):\n            offset = i + self.offset\n            end = start + (tsz - offset) * bsz * copies\n            if self.infonce:\n                predictions[start:end] = torch.einsum(\n                    \"bct,nbct->tbn\", x[..., :-offset, i], targets[..., offset:]\n                ).flatten()\n            else:\n                pos_num = (end - start) \/\/ copies\n                predictions[start:end] = torch.einsum(\n                    \"bct,nbct->nbt\", x[..., :-offset, i], targets[..., offset:]\n                ).flatten()\n                labels[start : start + pos_num] = 1.0\n                if weights is not None:\n                    weights[start : start + pos_num] = 1.0\n            start = end\n        assert end == predictions.numel(), \"{} != {}\".format(end, predictions.numel())\n\n        if self.infonce:\n            predictions = predictions.view(-1, copies)\n        else:\n            if weights is not None:\n                labels = (labels, weights)\n\n        return predictions, labels\n"}