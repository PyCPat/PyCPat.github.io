{"BEFORE":"            h = torch.sum(h, dim=[2, 3])\n\n            # adversarial training\n            adv_output = torch.squeeze(self.linear1(h))\n\n            # make class labels odd (for fake) or even (for real) for ADC\n            if self.aux_cls_type == \"ADC\":\n                if adc_fake:\n                    label = label*2 + 1\n                else:\n                    label = label*2\n\n            # forward pass through InfoGAN Q head\n            if self.MODEL.info_num_discrete_c != \"N\/A\":\n                info_discrete_c_logits = self.info_discrete_linear(h)\n            if self.MODEL.info_num_conti_c != \"N\/A\":\n                info_conti_mu = self.info_conti_mu_linear(h)\n                info_conti_var = self.info_conti_var_linear(h)\n","AFTER":"                    h = block(h)\n            bottom_h, bottom_w = h.shape[2], h.shape[3]\n            h = self.activation(h)\n            h = torch.sum(h, dim=[2, 3])\n\n            # adversarial training\n            adv_output = torch.squeeze(self.linear1(h))\n\n            # make class labels odd (for fake) or even (for real) for ADC\n            if self.aux_cls_type == \"ADC\":\n                if adc_fake:\n                    label = label*2 + 1\n                else:\n                    label = label*2\n\n            # forward pass through InfoGAN Q head\n            if self.MODEL.info_type in [\"discrete\", \"both\"]:\n                info_discrete_c_logits = self.info_discrete_linear(h\/(bottom_h*bottom_w))\n            if self.MODEL.info_type in [\"continuous\", \"both\"]:\n                info_conti_mu = self.info_conti_mu_linear(h\/(bottom_h*bottom_w))\n                info_conti_var = torch.exp(self.info_conti_var_linear(h\/(bottom_h*bottom_w)))\n"}