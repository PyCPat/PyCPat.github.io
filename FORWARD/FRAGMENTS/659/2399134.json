{"BEFORE":"                input: torch.Tensor) -> torch.Tensor:\n        \"\"\" Forward pass.\n\n        Args:\n            input (torch.Tensor): Input images of the shape (B, C, H, W)\n\n        Returns:\n            classification (torch.Tensor): Classification of the shape (B, num_classes)\n        \"\"\"\n        # Check input resolution\n        assert input.shape[2:] == self.input_resolution, \\\n            \"Input resolution and utilized resolution does not match. Please update the models resolution by calling \" \\\n            \"update_resolution the provided method.\"\n        # Perform patch embedding\n        output: torch.Tensor = self.patch_embedding(input)\n        # Forward pass of each stage\n        for stage in self.stages:\n            output: torch.Tensor = stage(output)\n        # Perform average pooling\n        output: torch.Tensor = self.average_pool(output).flatten(start_dim=1)\n        # Predict classification\n        classification: torch.Tensor = self.head(output)\n        return classification\n","AFTER":"    def forward(self, x):\n        B, C, H, W = x.shape\n        _assert(H == self.img_size[0], f\"Input image height ({H}) doesn't match model ({self.img_size[0]}).\")\n        _assert(W == self.img_size[1], f\"Input image width ({W}) doesn't match model ({self.img_size[1]}).\")\n        x = self.proj(x)\n        x = self.norm(x.permute(0, 2, 3, 1)).permute(0, 3, 1, 2)\n        return x\n"}