{"BEFORE":"        if self.weight:\n            w = torch.sigmoid(self.w) * (2 \/ self.n)  # sigmoid weights (0-1)\n            if self.n == 2:\n                return x * w[0] + outputs[self.layers[0]] * w[1]\n            elif self.n == 3:\n                return x * w[0] + outputs[self.layers[0]] * w[1] + outputs[self.layers[1]] * w[2]\n        else:\n            if self.n == 2:\n                return x + outputs[self.layers[0]]\n            elif self.n == 3:\n                return x + outputs[self.layers[0]] + outputs[self.layers[1]]\n\n\nclass SwishImplementation(torch.autograd.Function):\n","AFTER":"        if self.weight:\n            w = torch.sigmoid(self.w) * (2 \/ self.n)  # sigmoid weights (0-1)\n            x = x * w[0]\n\n        # Fusion\n        nc = x.shape[1]  # number of channels\n        for i in range(self.n - 1):\n            a = outputs[self.layers[i]]  # feature to add\n            dc = nc - a.shape[1]  # delta channels\n\n            # Adjust channels\n            if dc > 0:  # pad\n                pad = nn.ZeroPad2d((0, 0, 0, 0, 0, dc))\n                a = pad(a)\n            elif dc < 0:  # slice\n                a = a[:, :nc]\n\n            # Sum\n            x = x + a * w[i + 1] if self.weight else x + a\n        return x\n"}