{"BEFORE":"        n = inputs_col.size(0)\n        if self.norm:\n            inputs_col = F.normalize(inputs_col)\n            inputs_row = F.normalize(inputs_row)\n\n        dist = pairwise_euclidean_distance(inputs_col, inputs_row)\n\n        # split the positive and negative pairs\n        pos_mask = targets_col.expand(\n            targets_row.shape[0], n\n        ).t() == targets_row.expand(n, targets_row.shape[0])\n        neg_mask = ~pos_mask\n        # For each anchor, find the hardest positive and negative\n        dist_ap, dist_an = [], []\n\n        for i in range(n):\n            dist_ap.append(dist[i][pos_mask[i]].max().unsqueeze(0))\n            dist_an.append(dist[i][neg_mask[i]].min().unsqueeze(0))\n\n        dist_ap = torch.cat(dist_ap)\n        dist_an = torch.cat(dist_an)\n","AFTER":"            f = F.normalize(f)\n            xbm_f = F.normalize(xbm_f)\n\n        dist_mat = pairwise_euclidean_distance(f, xbm_f)\n\n        # hard examples mining\n        n, m = f.size(0), xbm_f.size(0)\n        identity_mat = labels.expand(m, n).t().eq(xbm_labels.expand(n, m)).float()\n        dist_ap, dist_an = hard_examples_mining(dist_mat, identity_mat)\n"}