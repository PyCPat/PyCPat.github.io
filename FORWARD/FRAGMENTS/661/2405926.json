{"BEFORE":"        st = self.net(x)\n        s, t = st.split(self.dim, dim=1)\n        z = x * torch.exp(s) + t\n        # Reverse order, so if we stack MAFs, correct things happen.\n        z = z.flip(dims=(1,)) if self.parity else z\n        log_det = torch.sum(s, dim=1)\n        return z, log_det\n","AFTER":"        x = torch.zeros_like(z)\n        log_det = torch.zeros(z.size(0))\n        z = z.flip(dims=(1,)) if self.parity else z\n        for i in range(self.dim):\n            st = self.net(x.clone())  # clone to avoid in-place op errors if using IAF\n            s, t = st.split(self.dim, dim=1)\n            x[:, i] = (z[:, i] - t[:, i]) * torch.exp(-s[:, i])\n            log_det += -s[:, i]\n        return x, log_det\n"}