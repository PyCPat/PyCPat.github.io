{"BEFORE":"        output = [None] * prediction.shape[0]\n        for xi, x in enumerate(prediction):  # image index, image inference\n            # Apply constraints\n            # x[((x[..., 2:4] < min_wh) | (x[..., 2:4] > max_wh)).any(1), 4] = 0  # width-height\n            x = x[xc[xi]]  # confidence\n\n            # If none remain process next image\n            if not x.shape[0]:\n                continue\n\n            # Compute conf\n            x[:, 5:] *= x[:, 4:5]  # conf = obj_conf * cls_conf\n\n            # Box (center x, center y, width, height) to (x1, y1, x2, y2)\n            box = xywh2xyxy(x[:, :4])\n\n            # Detections matrix nx6 (xyxy, conf, cls)\n            if multi_label:\n                i, j = (x[:, 5:] > self.conf_thres).nonzero(as_tuple=False).T\n                x = torch.cat((box[i], x[i, j + 5, None], j[:, None].float()), 1)\n            else:  # best class only\n                conf, j = x[:, 5:].max(1, keepdim=True)\n                x = torch.cat((box, conf, j.float()), 1)[conf.view(-1) > self.conf_thres]\n\n            # Apply finite constraint\n            # if not torch.isfinite(x).all():\n            #     x = x[torch.isfinite(x).all(1)]\n\n            # If none remain process next image\n            n = x.shape[0]  # number of boxes\n            if not n:\n                continue\n\n            # Sort by confidence\n            # x = x[x[:, 4].argsort(descending=True)]\n\n            # Batched NMS\n            c = x[:, 5:6] * (0 if self.agnostic else max_wh)  # classes\n            boxes, scores = x[:, :4] + c, x[:, 4]  # boxes (offset by class), scores\n            i = nms(boxes, scores, self.iou_thres)\n            if i.shape[0] > max_det:  # limit detections\n                i = i[:max_det]\n            if self.merge and (1 < n < 3E3):  # Merge NMS (boxes merged using weighted mean)\n                try:  # update boxes as boxes(i,4) = weights(i,n) * boxes(n,4)\n                    iou = self.box_iou(boxes[i], boxes) > self.iou_thres  # iou matrix\n                    weights = iou * scores[None]  # box weights\n                    x[i, :4] = torch.mm(weights, x[:, :4]).float() \/ weights.sum(1, keepdim=True)  # merged boxes\n                    if redundant:\n                        i = i[iou.sum(1) > 1]  # require redundancy\n                except RuntimeError:  # possible CUDA error https:\/\/github.com\/ultralytics\/yolov3\/issues\/1139\n                    print(x, i, x.shape, i.shape)\n                    pass\n\n            output[xi] = x[i]\n\n        return output\n","AFTER":"        output = torch.jit.annotate(List[Tensor], [])\n        for xi, x in enumerate(prediction):  # image index, image inference\n            # Apply constraints\n            # x[((x[..., 2:4] < min_wh) | (x[..., 2:4] > max_wh)).any(1), 4] = 0  # width-height\n            x = x[xc[xi]]  # confidence\n\n            # If none remain process next image\n            if not x.shape[0]:\n                continue\n\n            # Compute conf\n            x[:, 5:] *= x[:, 4:5]  # conf = obj_conf * cls_conf\n\n            # Box (center x, center y, width, height) to (x1, y1, x2, y2)\n            box = box_cxcywh_to_xyxy(x[:, :4])\n\n            # Detections matrix nx6 (xyxy, conf, cls)\n            if multi_label:\n                inds = torch.nonzero(x[:, 5:] > self.conf_thres)\n                i = inds[:, 0]\n                j = inds[:, 1]\n                x = torch.cat((box[i], x[i, j + 5, None], j[:, None].float()), 1)\n            else:  # best class only\n                conf, j = x[:, 5:].max(1, keepdim=True)\n                x = torch.cat((box, conf, j.float()), 1)[conf.view(-1) > self.conf_thres]\n\n            # Apply finite constraint\n            # if not torch.isfinite(x).all():\n            #     x = x[torch.isfinite(x).all(1)]\n\n            # If none remain process next image\n            n = x.shape[0]  # number of boxes\n            if not n:\n                continue\n\n            # Sort by confidence\n            # x = x[x[:, 4].argsort(descending=True)]\n\n            # Batched NMS\n            c = x[:, 5:6] * (0 if self.agnostic else max_wh)  # classes\n            boxes, scores = x[:, :4] + c, x[:, 4]  # boxes (offset by class), scores\n            i = nms(boxes, scores, self.iou_thres)\n            if i.shape[0] > max_det:  # limit detections\n                i = i[:max_det]\n            if self.merge and (1 < n < 3E3):  # Merge NMS (boxes merged using weighted mean)\n                iou = box_iou(boxes[i], boxes) > self.iou_thres  # iou matrix\n                weights = iou * scores[None]  # box weights\n                x[i, :4] = torch.mm(weights, x[:, :4]).float() \/ weights.sum(1, keepdim=True)  # merged boxes\n                if redundant:\n                    i = i[iou.sum(1) > 1]  # require redundancy\n\n            output.append(x[i])\n\n        return torch.stack(output, dim=0)\n"}