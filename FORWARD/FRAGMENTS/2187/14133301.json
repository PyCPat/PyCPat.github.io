{"BEFORE":"        self.bas_coords = self.atom_coords.repeat_interleave(self.nshells,dim=0)\n        print(self.bas_coords.shape)\n\n        # get the x,y,z, distance component of each point from each RBF center\n        # -> (Nbatch,Nelec,Nrbf,Ndim)\n        xyz =  (input.view(-1,self.nelec,1,self.ndim) - self.bas_coords[None,...])\n        print(xyz.shape)\n\n        # compute the distance\n        # -> (Nbatch,Nelec,Nrbf)\n        R = torch.sqrt((xyz**2).sum(3))\n        print(R.shape)\n\n        # radial part\n        # -> (Nbatch,Nelec,Nrbf)\n        X = R**self.bas_n * torch.exp(-self.bas_exp*R)\n        print(X.shape)\n\n        # compute by the spherical harmonics\n        # -> (Nbatch,Nelec,Nrbf)\n        Y = SphericalHarmonics(xyz,self.bas_l,self.bas_m)\n        print(Y.shape)\n\n        return X * Y\n","AFTER":"        X = R**self.bas_n * torch.exp(-self.bas_exp*R)\n        \n        # compute by the spherical harmonics\n        # -> (Nbatch,Nelec,Nrbf)\n        Y = SphericalHarmonics(xyz,self.bas_l,self.bas_m)\n        \n        # product\n        XY = X * Y\n\n        # add the components if DZ basis set\n        if self.basis == 'dz':\n            nrbf = XY.shape[-1]\n            norb = int(nrbf\/2)\n            XY = XY.view(-1,self.nelec,2,norb).sum(2)\n\n        return XY\n"}