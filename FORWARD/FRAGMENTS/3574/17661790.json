{"BEFORE":"        z: torch.Tensor,\n        msa_mask: torch.Tensor,\n        pair_mask: torch.Tensor,\n        chunk_size: Optional[int] = None,\n        use_lma: bool = False,\n        _mask_trans: bool = True,\n        _attn_chunk_size: Optional[int] = None,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        inplace_safe = not (self.training or torch.is_grad_enabled())\n\n        print(chunk_size)\n        print(_attn_chunk_size)\n\n        if(_attn_chunk_size is None):\n            _attn_chunk_size = chunk_size\n\n        m = add(m, \n            self.msa_dropout_layer(\n                self.msa_att_row(\n                    m, \n                    z=z, \n                    mask=msa_mask, \n                    chunk_size=_attn_chunk_size,\n                    use_lma=use_lma,\n                )\n            ),\n            inplace=inplace_safe,\n        )\n        m = add(m, \n            self.msa_att_col(\n                m, \n                mask=msa_mask, \n                chunk_size=chunk_size,\n                use_lma=use_lma,\n            ),\n            inplace=inplace_safe,\n        )\n        m, z = self.core(\n            m, \n            z, \n            msa_mask=msa_mask, \n            pair_mask=pair_mask, \n            chunk_size=chunk_size, \n            use_lma=use_lma,\n            _mask_trans=_mask_trans,\n            _attn_chunk_size=_attn_chunk_size,\n        )\n\n        return m, z\n","AFTER":"        _offload_inference: bool = False,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        inplace_safe = not (self.training or torch.is_grad_enabled())\n\n        if(_attn_chunk_size is None):\n            _attn_chunk_size = chunk_size\n\n        m, z = input_tensors\n\n        m = add(m, \n            self.msa_dropout_layer(\n                self.msa_att_row(\n                    m, \n                    z=z, \n                    mask=msa_mask, \n                    chunk_size=_attn_chunk_size,\n                    use_lma=use_lma,\n                )\n            ),\n            inplace=inplace_safe,\n        )\n        m = add(m, \n            self.msa_att_col(\n                m, \n                mask=msa_mask, \n                chunk_size=chunk_size,\n                use_lma=use_lma,\n            ),\n            inplace=inplace_safe,\n        )\n\n        if(not inplace_safe):\n            input_tensors = [m, input_tensors[1]]\n        \n        del m, z\n\n        m, z = self.core(\n            input_tensors, \n            msa_mask=msa_mask, \n            pair_mask=pair_mask, \n            chunk_size=chunk_size, \n            use_lma=use_lma,\n            _mask_trans=_mask_trans,\n            _attn_chunk_size=_attn_chunk_size,\n            _offload_inference=_offload_inference,\n        )\n\n        if(inplace_safe):\n            out = input_tensors\n        else:\n            out = [m, z]\n\n        return out\n"}