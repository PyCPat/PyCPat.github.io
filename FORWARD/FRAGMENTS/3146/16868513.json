{"BEFORE":"                adjacency_matrix = weights.reshape(n_h, n)\n\n                # Update human nodes\n                messages_to_h = F.relu(torch.mm(\n                    adjacency_matrix.softmax(dim=1),\n                    self.obj_to_sub(node_encodings)\n                ))\n                h_node_encodings = self.norm_h(\n                    h_node_encodings + messages_to_h\n                )\n\n                # Update object nodes (including human nodes)\n                messages_to_o = F.relu(torch.mm(\n                    adjacency_matrix.t().softmax(dim=1),\n                    self.sub_to_obj(h_node_encodings)\n                ))\n                node_encodings = self.norm_o(\n                    node_encodings + messages_to_o\n                )\n\n            if targets is not None:\n                all_labels.append(self.associate_with_ground_truth(\n                    coords[x_keep], coords[y_keep], targets[b_idx])\n                )\n                \n            all_box_pair_features.append(torch.cat([\n                h_node_encodings[x_keep], node_encodings[y_keep]\n            ], 1))\n            all_boxes_h.append(coords[x_keep])\n            all_boxes_o.append(coords[y_keep])\n            all_object_class.append(labels[y_keep])\n            # The prior score is the product between edge weights and the\n            # pre-computed object detection scores with LIS\n            all_prior.append(\n                adjacency_matrix[x_keep, y_keep, None] *\n                self.compute_prior_scores(x_keep, y_keep, scores, labels)\n","AFTER":"                self.compute_prior_scores(x_keep, y_keep, scores, labels)\n"}