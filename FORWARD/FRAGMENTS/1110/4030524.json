{"BEFORE":"        batch_size, num_classes = input.size()\n        scale, margin = self.scale, self.margin\n        eps = self.eps\n\n        input = torch.clamp(input, -1+eps, 1-eps)\n        theta = torch.arccos(input) # (batch_size, num_classes)\n        theta_modified = theta + margin # (batch_size, num_classes)\n        mesh = torch.arange(0, num_classes).unsqueeze(dim=0) # (1, num_classes) \n        mesh_target = target.unsqueeze(dim=1) # (batch_size, 1)\n        condition = mesh==mesh_target # (batch_size, num_classes)\n        theta_modified = torch.where(condition, theta_modified, theta)\n        cos = scale * torch.cos(theta_modified) # (batch_size, num_classes)\n\n        indices = num_classes * torch.arange(batch_size) + target # (batch_size,)\n        cos_target = torch.take(cos, indices) # (batch_size,)\n\n        loss = - cos_target + torch.logsumexp(cos, dim=1)\n","AFTER":"        num_classes = input.size(-1)\n        scale, margin = self.scale, self.margin\n        cos_m, sin_m = self.cos_m, self.sin_m\n        eps = self.eps\n\n        cos_th = input\n        sin_th = torch.sqrt(1 - cos_th**2 + eps)\n        cos_phi = cos_th * cos_m - sin_th * sin_m # (batch_size, num_classes)\n\n        # For target class\n        if self.easy_margin:\n            cos_phi = torch.where(cos_th < 0, cos_th, cos_phi) # (batch_size, num_classes)\n        else:\n            cos_phi = torch.where(cos_th > self.cos_pi_m, cos_th - margin, cos_phi) # (batch_size, num_classes)\n        \n        # For non-target class\n        mask = F.one_hot(target, num_classes=num_classes) # (batch_size, num_classes)\n        input = scale * (mask * cos_phi + (1.0 - mask) * cos_th)\n        loss = F.cross_entropy(input, target, reduction=\"none\")\n"}