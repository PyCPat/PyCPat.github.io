{"BEFORE":"        if isinstance(x, torch.Tensor):  # torch\n            return self.model(x.to(p.device).type_as(p), augment, profile)  # inference\n\n        # Pre-process\n        if not isinstance(x, list):\n            x = [x]\n        shape0, shape1 = [], []  # image and inference shapes\n        batch = range(len(x))  # batch size\n        for i in batch:\n            x[i] = np.array(x[i])  # to numpy\n            x[i] = x[i][:, :, :3] if x[i].ndim == 3 else np.tile(x[i][:, :, None], 3)  # enforce 3ch input\n            s = x[i].shape[:2]  # HWC\n            shape0.append(s)  # image shape\n            g = (size \/ max(s))  # gain\n            shape1.append([y * g for y in s])\n        shape1 = [make_divisible(x, int(self.stride.max())) for x in np.stack(shape1, 0).max(0)]  # inference shape\n        x = [letterbox(x[i], new_shape=shape1, auto=False)[0] for i in batch]  # pad\n        x = np.stack(x, 0) if batch[-1] else x[0][None]  # stack\n        x = np.ascontiguousarray(x.transpose((0, 3, 1, 2)))  # BHWC to BCHW\n        x = torch.from_numpy(x).to(p.device).type_as(p) \/ 255.  # uint8 to fp16\/32\n\n        # Inference\n        x = self.model(x, augment, profile)  # forward\n        x = non_max_suppression(x[0], conf_thres=self.conf, iou_thres=self.iou, classes=self.classes)  # NMS\n\n        # Post-process\n        for i in batch:\n            if x[i] is not None:\n                x[i][:, :4] = scale_coords(shape1, x[i][:, :4], shape0[i])\n        return x\n","AFTER":"        if isinstance(imgs, torch.Tensor):  # torch\n            return self.model(imgs.to(p.device).type_as(p), augment, profile)  # inference\n\n        # Pre-process\n        if not isinstance(imgs, list):\n            imgs = [imgs]\n        shape0, shape1 = [], []  # image and inference shapes\n        batch = range(len(imgs))  # batch size\n        for i in batch:\n            imgs[i] = np.array(imgs[i])  # to numpy\n            imgs[i] = imgs[i][:, :, :3] if imgs[i].ndim == 3 else np.tile(imgs[i][:, :, None], 3)  # enforce 3ch input\n            s = imgs[i].shape[:2]  # HWC\n            shape0.append(s)  # image shape\n            g = (size \/ max(s))  # gain\n            shape1.append([y * g for y in s])\n        shape1 = [make_divisible(x, int(self.stride.max())) for x in np.stack(shape1, 0).max(0)]  # inference shape\n        x = [letterbox(imgs[i], new_shape=shape1, auto=False)[0] for i in batch]  # pad\n        x = np.stack(x, 0) if batch[-1] else x[0][None]  # stack\n        x = np.ascontiguousarray(x.transpose((0, 3, 1, 2)))  # BHWC to BCHW\n        x = torch.from_numpy(x).to(p.device).type_as(p) \/ 255.  # uint8 to fp16\/32\n\n        # Inference\n        with torch.no_grad():\n            y = self.model(x, augment, profile)[0]  # forward\n        y = non_max_suppression(y, conf_thres=self.conf, iou_thres=self.iou, classes=self.classes)  # NMS\n\n        # Post-process\n        for i in batch:\n            if y[i] is not None:\n                y[i][:, :4] = scale_coords(shape1, y[i][:, :4], shape0[i])\n\n        return Detections(imgs, y, self.names)\n"}