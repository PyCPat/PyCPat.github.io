{"BEFORE":"        F = self.F(f)\r\n\r\n        # IAC\r\n        Fs = torch.split(F[:, :self.N * (self.ch4 * self.Fs * 2), :, :], self.ch4 * self.Fs * 2, dim = 1)\r\n        F_bs = torch.split(F[:, self.N * (self.ch4 * self.Fs * 2):, :, :], self.ch4, dim = 1)\r\n        for i in range(self.N):\r\n            F1, F2= torch.split(Fs[i], self.ch4 * self.Fs, dim = 1)\r\n            f = SAC(feat_in=f_C if i == 0 else f, kernel1=F1, kernel2=F2, ksize=self.Fs) ## image\r\n            f = f + F_bs[i]\r\n            f = Func.leaky_relu(f, 0.1, inplace=True)\r\n\r\n        # reconstructor\r\n        f = self.conv_res(f)\r\n","AFTER":"        f_C = self.conv4_3(self.conv4_2(self.conv4_1(f3)))\r\n\r\n        # filter encoder\r\n        f = self.kconv1_3(self.kconv1_2(self.kconv1_1(torch.cat([R, L], axis = 1))))\r\n        f = self.kconv2_3(self.kconv2_2(self.kconv2_1(f)))\r\n        f = self.kconv3_3(self.kconv3_2(self.kconv3_1(f)))\r\n        f = self.kconv4_3(self.kconv4_2(self.kconv4_1(f)))\r\n\r\n        # disparity map estimator\r\n        DM = self.DME(f)\r\n\r\n        # filter predictor\r\n        f_DM = self.conv_DME(DM)\r\n        f = self.conv4_4(torch.cat([f, f_DM], 1))\r\n        F = self.F(f)\r\n\r\n        # IAC\r\n        f = IAC(f_C, F, self.N, self.ch4, self.Fs)\r\n"}