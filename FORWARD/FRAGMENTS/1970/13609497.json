{"BEFORE":"        z: List[Tensor] = []  # inference output\n        for i in range(self.nl):\n            x[i] = self.get_result_from_m(x[i], i)  # conv\n            bs, _, ny, nx = x[i].shape  # x(bs,255,20,20) to x(bs,3,20,20,85)\n            x[i] = x[i].view(bs, self.na, self.no, ny, nx).permute(0, 1, 3, 4, 2).contiguous()\n\n            if not self.training:  # inference\n                if self.grid[i].shape[2:4] != x[i].shape[2:4]:\n                    self.grid[i] = self._make_grid(nx, ny).to(x[i].device)\n\n                y = x[i].sigmoid()\n                y[..., 0:2] = (y[..., 0:2] * 2. - 0.5 + self.grid[i].to(x[i].device)) * self.stride[i]  # xy\n                y[..., 2:4] = (y[..., 2:4] * 2) ** 2 * self.anchor_grid[i]  # wh\n                z.append(y.view(bs, -1, self.no))\n\n        if torch.jit.is_scripting():\n            warnings.warn(\"YOLO always returns a (outputs, features) tuple in scripting\")\n            return (torch.cat(z, 1), x)\n        else:\n            return self.eager_outputs(torch.cat(z, 1), x)\n\n    @torch.jit.unused\n","AFTER":"        device = x[0].device\n        z: List[Tensor] = []  # inference output\n        for i in range(self.nl):\n            x[i] = self.get_result_from_m(x[i], i)  # conv\n            bs, _, ny, nx = x[i].shape  # x(bs,255,20,20) to x(bs,3,20,20,85)\n            x[i] = x[i].view(bs, self.na, self.no, ny, nx).permute(0, 1, 3, 4, 2).contiguous()\n\n            if not self.training:  # inference\n                if not isinstance(self.stride, Tensor):\n                    self.stride = torch.tensor(self.stride, device=device)\n\n                if self.grid[i].shape[2:4] != x[i].shape[2:4]:\n                    self.grid[i] = self._make_grid(nx, ny).to(device)\n\n                y = x[i].sigmoid()\n                y[..., 0:2] = (y[..., 0:2] * 2. - 0.5 + self.grid[i].to(device)) * self.stride[i]  # xy\n                y[..., 2:4] = (y[..., 2:4] * 2) ** 2 * self.anchor_grid[i]  # wh\n                z.append(y.view(bs, -1, self.no))\n\n        return (torch.cat(z, 1), x)\n"}