{"BEFORE":"        input_length, target_length = inputs.size(1), targets.size(1)\n\n        inputs_mask = pad_masking(inputs, input_length, self.pad_id)\n        memory_mask = pad_masking(inputs, target_length, self.pad_id)\n        targets_mask = subsequent_masking(targets)\n\n        memory, encoder_self_attns = self.encoder(inputs, inputs_mask)\n        output, decoder_self_attns, decoder_encoder_attns = self.decoder(targets, memory, targets_mask, memory_mask)\n        output = self.linear(output)\n\n        return output, encoder_self_attns, decoder_self_attns, decoder_encoder_attns\n","AFTER":"    def forward(self, inputs: Tensor, input_lengths: Tensor,\n                targets: Optional[Tensor],\n                return_attns: bool = False) -> Tuple[Tensor, Tensor, Tensor, Tensor]:\n        batch_size = targets.size(0)\n        targets = targets[targets != self.eos_id].view(batch_size, -1)\n\n        memory, encoder_self_attns = self.encoder(inputs, input_lengths)\n        output, decoder_self_attns, memory_attns = self.decoder(targets, input_lengths, memory)\n        output = self.generator(output)\n\n        if return_attns:\n            return output, encoder_self_attns, decoder_self_attns, memory_attns\n\n        return output\n"}