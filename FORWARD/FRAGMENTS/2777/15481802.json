{"BEFORE":"        b = data.shape[0]\n        data = fourier_encode(data, self.num_fourier_features)\n        data = rearrange(data, 'b n ... -> b n (...)')\n","AFTER":"        b, *axis, _, device = *data.shape, data.device\n        assert len(axis) == self.input_axis, 'input data must have the right number of axis'\n\n        # calculate fourier encoded positions in the range of [-1, 1], for all axis\n\n        axis_pos = list(map(lambda size: torch.linspace(-1., 1., steps = size, device = device), axis))\n        pos = torch.stack(torch.meshgrid(*axis_pos), dim = -1)\n        enc_pos = fourier_encode(pos, self.num_fourier_features)\n        enc_pos = rearrange(enc_pos, '... n d -> ... (n d)')\n        enc_pos = repeat(enc_pos, '... -> b ...', b = b)\n\n        # concat to channels of data and flatten axis\n\n        data = torch.cat((data, enc_pos), dim = -1)\n        data = rearrange(data, 'b ... d -> b (...) d')\n"}