{"BEFORE":"        input_ = input.view(-1, self.nelec, self.ndim)\n        dist = self._get_distance_quadratic(input_, self.atoms)\n        dist = torch.sqrt(dist)\n\n        if derivative == 0:\n            return dist\n\n        elif derivative == 1:\n            invr = (1. \/ dist).unsqueeze(-1)\n            diff_axis = (input_.unsqueeze(-1) -\n                         self.atoms.T).transpose(2, 3)\n            return (diff_axis * invr).permute(0, 3, 1, 2)\n\n        elif derivative == 2:\n\n            invr3 = (1. \/ (dist**3)).unsqueeze(1)\n            diff_axis = input_.transpose(1, 2).unsqueeze(3)\n            diff_axis = (diff_axis - self.atoms.T.unsqueeze(1))**2\n\n            diff_axis = diff_axis[:, [\n                [1, 2], [2, 0], [0, 1]], ...].sum(2)\n\n            return (diff_axis * invr3)\n","AFTER":"        input_ = input.view(-1, self.nelec, self.ndim)\n        dist = self._get_distance_quadratic(input_, self.atoms)\n        dist = torch.sqrt(dist)\n\n        if derivative == 0:\n            if self.scale:\n                return get_scaled_distance(self.kappa, dist)\n            else:\n                return dist\n\n        elif derivative == 1:\n            der_dist = self.get_der_distance(input_, dist)\n            if self.scale:\n                return get_der_scaled_distance(self.kappa,\n                                               dist, der_dist)\n            else:\n                return der_dist\n\n        elif derivative == 2:\n\n            d2_dist = self.get_second_der_distance(input_, dist)\n\n            if self.scale:\n                der_dist = self.get_der_distance(input_, dist)\n                return get_second_der_scaled_distance(self.kappa,\n                                                      dist,\n                                                      der_dist,\n                                                      d2_dist)\n            else:\n                return d2_dist\n\n    def get_der_distance(self, pos, dist):\n"}