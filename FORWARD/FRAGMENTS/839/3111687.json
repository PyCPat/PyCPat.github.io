{"BEFORE":"        output = []\n        for step in range(input.size(1)):\n            # Compute current time-step\n            hidden_state = self.rnn_cell(input[:, step, :, :, :], hidden_state)\n            output.append(hidden_state)\n        # Stack the list of output hidden states into a tensor\n        output = torch.stack(output, 0)\n        return output\n","AFTER":"        input = self.input_dp(input)\n        cur_layer_input = torch.unbind(input, dim=int(self.batch_first))\n\n        if hidden_state is None:\n            hidden_state = self.get_init_states(cur_layer_input[0])\n\n        seq_len = len(cur_layer_input)\n\n        layer_output_list = []\n        last_state_list = []\n\n        for l, (gru_cell, hid_dp) in enumerate(zip(self.cell_list, self.hidden_dps)):\n            h = hidden_state[l]\n            output_inner = []\n            for t in range(seq_len):\n                h = gru_cell(input=cur_layer_input[t], h_prev=h)\n                output_inner.append(h)\n\n            cur_layer_input = torch.stack(output_inner)  # list to array\n            if l != self.n_layers:\n                cur_layer_input = hid_dp(cur_layer_input)\n            last_state_list.append(h)\n\n        layer_output = torch.stack(output_inner, dim=int(self.batch_first))\n        last_state_list = torch.stack(last_state_list, dim=0)\n        return layer_output, last_state_list\n"}