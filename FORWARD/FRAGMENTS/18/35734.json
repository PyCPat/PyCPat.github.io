{"BEFORE":"        buckets = k.shape[1] \/\/ bucket_size\n\n        b_q = bucket(buckets, q) if self.n_sortcut == 0 else bucket(1, q)\n        b_k = bucket(buckets, k)\n\n        sq = b_q.mean(dim=2)\n        sk = b_k.mean(dim=2)\n\n        R = torch.einsum('bie,bje->bij', sq, sk).to(q) * (dim ** -0.5)\n\n        if self.n_sortcut > 0:\n            values, indices = torch.topk(R, self.n_sortcut)\n            values = values.reshape(bh, self.n_sortcut, -1)\n            indices = indices.reshape(bh, self.n_sortcut, -1)\n            R = torch.zeros(bh, self.n_sortcut, buckets, device=device, dtype=dtype).scatter(2, indices, values)\n\n        return R.softmax(dim=-1) if self.non_permutative else gumbel_sinkhorn(F.relu(R), self.sinkhorn_iter, self.temperature)\n","AFTER":"    def forward(self, q, k, topk=1):\n        bh, *_, bucket_size, kv_bucket_size, device, dtype, dim = *q.shape, self.bucket_size, self.kv_bucket_size, q.device, q.dtype, self.dim\n        b = bh \/\/ self.heads\n\n        buckets = q.shape[1] \/\/ bucket_size\n        kv_buckets = k.shape[1] \/\/ kv_bucket_size\n\n        b_q = bucket(buckets, q) if self.n_sortcut == 0 else bucket(1, q)\n        b_k = bucket(kv_buckets, k)\n\n        sq = b_q.mean(dim=2)\n        sk = b_k.mean(dim=2)\n\n        R = torch.einsum('bie,bje->bij', sq, sk).to(q) * (dim ** -0.5)\n\n        if self.non_permutative:\n            k = topk if self.n_sortcut == 0 else self.n_sortcut\n            return differentiable_topk(R, k=k)\n\n        return gumbel_sinkhorn(F.relu(R), self.sinkhorn_iter, self.temperature)\n"}