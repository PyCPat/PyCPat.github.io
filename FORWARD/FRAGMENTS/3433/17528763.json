{"BEFORE":"\t\tx = F.dropout(F.leaky_relu(self.batchnorm1(self.conv1(x, edge_index, edge_weight)), negative_slope=0.01), p=0.5, training=self.training)\n\t\tx = F.dropout(F.leaky_relu(self.batchnorm2(self.conv2(x, edge_index, edge_weight)), negative_slope=0.01), p=0.5, training=self.training)\n\n\t\t# NOTE: this takes node-level features\/\"embeddings\" and aggregates to graph-level - use for graph-level classification\n\t\tout = global_mean_pool(x, batch=batch)\n\t\tif return_graph_embedding:\n\t\t\treturn out\n\n\t\tout = self.fc_block1(out)\n","AFTER":"\t\tx = F.leaky_relu(self.conv1(x, edge_index, edge_weight=edge_weight))\n\t\tx = F.leaky_relu(self.conv2_bn(self.conv2(x, edge_index, edge_weight=edge_weight)))\n\n\t\t# NOTE: this takes node-level features\/\"embeddings\" and aggregates to graph-level - use for graph-level classification\n\n\t\tout = global_add_pool(x, batch=batch)\n\t\tif return_graph_embedding:\n\t\t\treturn out\n\t\tout = F.dropout(out, p=0.2, training=self.training)\n\t\tout = F.leaky_relu(self.fc_block1(out))\n\t\tout = self.fc_block2(out)\n"}