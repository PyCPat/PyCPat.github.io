{"BEFORE":"    def forward(self, \n        z: torch.Tensor, \n        mask: Optional[torch.Tensor] = None\n    ) -> torch.Tensor:\n        \"\"\"\n        Args:\n            x:\n                [*, N_res, N_res, C_z] input tensor\n            mask:\n                [*, N_res, N_res] input mask\n        Returns:\n            [*, N_res, N_res, C_z] output tensor\n        \"\"\"\n        if mask is None:\n            mask = z.new_ones(z.shape[:-1])\n\n        mask = mask.unsqueeze(-1)\n\n        z = self.layer_norm_in(z)\n        a = self.linear_a_p(z) * self.sigmoid(self.linear_a_g(z))\n        a = a * mask\n        b = self.linear_b_p(z) * self.sigmoid(self.linear_b_g(z))\n        b = b * mask\n        x = self._combine_projections(a, b)\n        x = self.layer_norm_out(x)\n        x = self.linear_z(x)\n        g = self.sigmoid(self.linear_g(z))\n        z = x * g\n\n        return z\n","AFTER":"    def forward(self, \n        z: torch.Tensor, \n        mask: Optional[torch.Tensor] = None,\n        _inplace: bool = False,\n        _add_with_inplace: bool = False,\n        _inplace_chunk_size: Optional[int] = 256,\n    ) -> torch.Tensor:\n        \"\"\"\n        Args:\n            x:\n                [*, N_res, N_res, C_z] input tensor\n            mask:\n                [*, N_res, N_res] input mask\n        Returns:\n            [*, N_res, N_res, C_z] output tensor\n        \"\"\"\n        if(_inplace):\n            x = self._inference_forward(\n                z, \n                mask, \n                inplace_chunk_size=_inplace_chunk_size,\n                with_add=_add_with_inplace,\n            )\n            return x\n\n        if mask is None:\n            mask = z.new_ones(z.shape[:-1])\n\n        mask = mask.unsqueeze(-1)\n        \n        z = self.layer_norm_in(z)\n        a = mask\n        a = a * self.sigmoid(self.linear_a_g(z)) \n        a = a * self.linear_a_p(z)\n        b = mask\n        b = b * self.sigmoid(self.linear_b_g(z))\n        b = b * self.linear_b_p(z)\n        x = self._combine_projections(a, b)\n        del a, b\n        x = self.layer_norm_out(x)\n        x = self.linear_z(x)\n        g = self.sigmoid(self.linear_g(z))\n        x = x * g\n\n        return x\n"}