{"BEFORE":"        feats_i = repeat(feats, 'b i d -> b i n d', n = n)\n        feats_j = repeat(feats, 'b j d -> b n j d', n = n)\n","AFTER":"    def forward(self, feats, coors, edges = None, mask = None):\n        b, n, d, fourier_features, num_nearest = *feats.shape, self.fourier_features, self.num_nearest_neighbors\n        use_nearest = num_nearest > 0\n\n        rel_coors = rearrange(coors, 'b i d -> b i () d') - rearrange(coors, 'b j d -> b () j d')\n        rel_dist = (rel_coors ** 2).sum(dim = -1, keepdim = True)\n\n        i = j = n\n\n        if use_nearest:\n            nbhd_indices = rel_dist[..., 0].topk(num_nearest, dim = -1, largest = False).indices\n            rel_coors = batched_index_select(rel_coors, nbhd_indices, dim = 2)\n            rel_dist = batched_index_select(rel_dist, nbhd_indices, dim = 2)\n\n            if exists(edges):\n                edges = batched_index_select(edges, nbhd_indices, dim = 2)\n\n            j = num_nearest\n\n        if fourier_features > 0:\n            rel_dist = fourier_encode_dist(rel_dist, num_encodings = fourier_features)\n            rel_dist = rearrange(rel_dist, 'b i j () d -> b i j d')\n\n        if use_nearest:\n            feats_j = batched_index_select(feats, nbhd_indices, dim = 1)\n        else:\n            feats_j = repeat(feats, 'b j d -> b i j d', i = i)\n\n        feats_i = repeat(feats, 'b i d -> b i j d', j = j)\n        edge_input = torch.cat((feats_i, feats_j, rel_dist), dim = -1)\n\n        if exists(edges):\n            edge_input = torch.cat((edge_input, edges), dim = -1)\n\n        m_ij = self.edge_mlp(edge_input)\n\n        coor_weights = self.coors_mlp(m_ij)\n        coor_weights = rearrange(coor_weights, 'b i j () -> b i j')\n\n        if self.norm_rel_coors:\n            rel_coors = F.normalize(rel_coors, dim = -1) * self.rel_coors_scale\n\n        if exists(mask):\n            if use_nearest:\n                mask = batched_index_select(mask, nbhd_indices, dim = 1)\n            else:\n                mask = rearrange(mask, 'b j -> b () j')\n\n            coor_weights.masked_fill_(~mask, 0.)\n\n        coors_out = einsum('b i j, b i j c -> b i c', coor_weights, rel_coors) + coors\n"}