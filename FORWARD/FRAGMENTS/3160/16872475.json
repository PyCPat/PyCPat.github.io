{"BEFORE":"        bsz = t \/\/ buckets\n\n        q = q.reshape(b * h, t, d_h)\n        k = k.reshape(b * h, t, d_h)\n        v = v.reshape(b * h, t, d_h)\n\n        # bucket query, key, values\n\n        bucket_fn = partial(bucket, buckets)\n        b_q, b_k, b_v = map(bucket_fn, (q, k, v))\n\n        # calculate reordering matrix R with simple sort net\n\n        R = self.sort_net(q, k)\n\n        # gumbel sinkhorn\n\n        R = gumbel_sinkhorn(R, self.sinkhorn_iter, temperature) if not self.non_permutative else R.softmax(dim=-1)\n        R = R.type_as(q).to(q)\n\n        # only allow one bucket to be reordered to, needed for input masking to work\n        R = zero_all_but_top(R, dim=2, k=1)\n\n        # concatenate reordered buckets\n\n        b_k_r = reorder_buckets(b_k, R)\n        b_v_r = reorder_buckets(b_v, R)\n\n        # choose the top n ranked buckets for all query buckets\n\n        if self.n_sortcut > 0:\n            b_k_r = b_k_r[:, 0:self.n_sortcut].reshape(-1, 1, bsz * self.n_sortcut, d_h)\n            b_v_r = b_v_r[:, 0:self.n_sortcut].reshape(-1, 1, bsz * self.n_sortcut, d_h)\n            b_k_r = expand_dim(b_k_r, 1, buckets)\n            b_v_r = expand_dim(b_v_r, 1, buckets)\n\n        b_k = torch.cat((b_k_r, b_k), dim=2)\n        b_v = torch.cat((b_v_r, b_v), dim=2)\n","AFTER":"        b, h, t, d_h, d, heads, temperature, buckets, kv_buckets, device = *q.shape, self.dim, self.heads, self.temperature, self.buckets, self.kv_buckets, q.device\n\n        q = q.reshape(b * h, t, d_h)\n        k = k.reshape(b * h, t, d_h)\n        v = v.reshape(b * h, t, d_h)\n\n        # bucket query, key, values\n\n        b_q = bucket(buckets, q)\n        b_k, b_v = map(partial(bucket, self.kv_buckets), (k, v))\n\n        bsz = b_k.shape[2]\n\n        # calculate reordering matrix R with simple sort net\n\n        R = self.sort_net(q, k)\n\n        # gumbel sinkhorn\n\n        R = gumbel_sinkhorn(R, self.sinkhorn_iter, temperature) if not self.non_permutative else R.softmax(dim=-1)\n        R = R.type_as(q).to(q)\n\n        # only allow one bucket to be reordered to, needed for input masking to work\n        R = zero_all_but_top(R, dim=2, k=1)\n\n        # concatenate reordered buckets\n\n        b_k_r = reorder_buckets(b_k, R)\n        b_v_r = reorder_buckets(b_v, R)\n\n        # choose the top n ranked buckets for all query buckets\n\n        if self.n_sortcut > 0:\n            b_k_r = b_k_r[:, 0:self.n_sortcut].reshape(-1, 1, bsz * self.n_sortcut, d_h)\n            b_v_r = b_v_r[:, 0:self.n_sortcut].reshape(-1, 1, bsz * self.n_sortcut, d_h)\n            b_k_r = expand_dim(b_k_r, 1, buckets)\n            b_v_r = expand_dim(b_v_r, 1, buckets)\n        \n        b_k = torch.cat((b_k_r, b_k), dim=2) if buckets == kv_buckets else b_k_r\n        b_v = torch.cat((b_v_r, b_v), dim=2) if buckets == kv_buckets else b_v_r\n"}