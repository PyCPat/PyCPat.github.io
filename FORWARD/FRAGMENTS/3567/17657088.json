{"BEFORE":"        batch = torch.zeros_like(z) if batch is None else batch\n\n        if self.derivative:\n            pos.requires_grad_(True)\n\n        # run the potentially wrapped representation model\n        x, z, pos, batch = self.representation_model(z, pos, batch=batch)\n        x = self.output_network(x)\n\n        if self.dipole:\n            # Get center of mass.\n            mass = self.atomic_mass[z].view(-1, 1)\n            c = scatter(mass * pos, batch, dim=0) \/ scatter(mass, batch, dim=0)\n            x = x * (pos - c[batch])\n        elif self.prior_model is not None:\n            # apply prior model\n            x = self.prior_model(x, z, pos, batch)\n\n        # aggregate atoms\n        out = scatter(x, batch, dim=0, reduce=self.reduce_op)\n\n        if not self.dipole and self.prior_model is None:\n            if self.std is not None:\n                out = out * self.std\n            if self.mean is not None:\n                out = out + self.mean\n\n        if self.dipole:\n            out = torch.norm(out, dim=-1, keepdim=True)\n\n        if self.derivative:\n","AFTER":"        batch = torch.zeros_like(z) if batch is None else batch\n\n        if self.derivative:\n            pos.requires_grad_(True)\n\n        # run the potentially wrapped representation model\n        representation = self.representation_model(z, pos, batch=batch)\n\n        if len(representation) == 5:\n            x, v, z, pos, batch = representation\n        else:\n            v = None\n            x, z, pos, batch = representation\n\n        # apply the output network\n        x = self.output_model.pre_reduce(x, v, z, pos, batch)\n\n        # apply prior model\n        if self.prior_model is not None:\n            x = self.prior_model(x, z, pos, batch)\n\n        # aggregate atoms\n        out = scatter(x, batch, dim=0, reduce=self.reduce_op)\n\n        # standardize if no prior model is given and the output model allows priors\n        if self.prior_model is None and self.output_model.allow_prior_model:\n            if self.std is not None:\n                out = out * self.std\n            if self.mean is not None:\n                out = out + self.mean\n\n        out = self.output_model.post_reduce(out)\n"}