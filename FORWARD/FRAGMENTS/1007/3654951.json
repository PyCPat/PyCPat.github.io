{"BEFORE":"        batch_size = int(bsz \/ self.window_size)\n        _, _, height, width = desc_dense.size()\n\n        src_desc = keypoint_desc[::self.window_size]  # B x C x N\n        src_desc = F.normalize(src_desc, dim=1)\n\n        tgt_desc_dense = desc_dense[1::self.window_size]  # B x C x H x W\n        tgt_desc_unrolled = F.normalize(tgt_desc_dense.view(batch_size, encoder_dim, -1), dim=1)  # B x C x HW\n\n        match_vals = torch.matmul(src_desc.transpose(2, 1), tgt_desc_unrolled)  # B x N x HW\n        soft_match_vals = F.softmax(match_vals \/ self.softmax_temp, dim=2)  # B x N x HW\n\n        v_coord, u_coord = torch.meshgrid([torch.arange(0, height), torch.arange(0, width)])\n        v_coord = v_coord.reshape(height * width).float()  # HW\n        u_coord = u_coord.reshape(height * width).float()\n        coords = torch.stack((u_coord, v_coord), dim=1)  # HW x 2\n        tgt_coords_dense = coords.unsqueeze(0).expand(batch_size, height * width, 2).to(self.gpuid)  # B x HW x 2\n\n        pseudo_coords = torch.matmul(tgt_coords_dense.transpose(2, 1),\n                                     soft_match_vals.transpose(2, 1)).transpose(2, 1)  # BxNx2\n\n        # GET SCORES for pseudo point locations\n        pseudo_norm = normalize_coords(pseudo_coords, height, width).unsqueeze(1)          # B x 1 x N x 2\n        tgt_scores_dense = scores_dense[1::self.window_size]\n        pseudo_scores = F.grid_sample(tgt_scores_dense, pseudo_norm, mode='bilinear')           # B x 1 x 1 x N\n        pseudo_scores = pseudo_scores.reshape(batch_size, 1, n_points)                          # B x 1 x N\n        # GET DESCRIPTORS for pseudo point locations\n        pseudo_desc = F.grid_sample(tgt_desc_dense, pseudo_norm, mode='bilinear')               # B x C x 1 x N\n        pseudo_desc = pseudo_desc.reshape(batch_size, encoder_dim, n_points)                    # B x C x N\n\n        desc_match_score = torch.sum(src_desc * pseudo_desc, dim=1, keepdim=True) \/ float(encoder_dim)  # Bx1xN\n        src_scores = keypoint_scores[::self.window_size]\n        if self.score_comp:\n            match_weights = 0.5 * (desc_match_score + 1) * src_scores * pseudo_scores\n        else:\n            match_weights = pseudo_scores\n\n        return pseudo_coords, match_weights\n","AFTER":"        batch_size = int(BW \/ self.window_size)\n        _, _, height, width = desc_dense.size()\n        kp_inds, dense_inds = get_indices(batch_size, self.window_size)\n\n        src_desc = keypoint_desc[kp_inds]  # B x C x N\n        src_desc = F.normalize(src_desc, dim=1)\n        B = src_desc.size(0)\n\n        tgt_desc_dense = desc_dense[dense_inds]  # B x C x H x W\n        tgt_desc_unrolled = F.normalize(tgt_desc_dense.view(B, encoder_dim, -1), dim=1)  # B x C x HW\n\n        match_vals = torch.matmul(src_desc.transpose(2, 1), tgt_desc_unrolled)  # B x N x HW\n        soft_match_vals = F.softmax(match_vals \/ self.softmax_temp, dim=2)  # B x N x HW\n\n        v_coord, u_coord = torch.meshgrid([torch.arange(0, height), torch.arange(0, width)])\n        v_coord = v_coord.reshape(height * width).float()  # HW\n        u_coord = u_coord.reshape(height * width).float()\n        coords = torch.stack((u_coord, v_coord), dim=1)  # HW x 2\n        tgt_coords_dense = coords.unsqueeze(0).expand(B, height * width, 2).to(self.gpuid)  # B x HW x 2\n\n        pseudo_coords = torch.matmul(tgt_coords_dense.transpose(2, 1),\n                                     soft_match_vals.transpose(2, 1)).transpose(2, 1)  # BxNx2\n\n        # GET SCORES for pseudo point locations\n        pseudo_norm = normalize_coords(pseudo_coords, height, width).unsqueeze(1)          # B x 1 x N x 2\n        tgt_scores_dense = scores_dense[dense_inds]\n        pseudo_scores = F.grid_sample(tgt_scores_dense, pseudo_norm, mode='bilinear')           # B x 1 x 1 x N\n        pseudo_scores = pseudo_scores.reshape(B, 1, n_points)                          # B x 1 x N\n        # GET DESCRIPTORS for pseudo point locations\n        pseudo_desc = F.grid_sample(tgt_desc_dense, pseudo_norm, mode='bilinear')               # B x C x 1 x N\n        pseudo_desc = pseudo_desc.reshape(B, encoder_dim, n_points)                    # B x C x N\n\n        desc_match_score = torch.sum(src_desc * pseudo_desc, dim=1, keepdim=True) \/ float(encoder_dim)  # Bx1xN\n        src_scores = keypoint_scores[kp_inds]\n        if self.score_comp:\n            match_weights = 0.5 * (desc_match_score + 1) * src_scores * pseudo_scores\n        else:\n            match_weights = pseudo_scores\n\n        return pseudo_coords, match_weights, kp_inds\n"}