{"BEFORE":"        self, input: Tensor, h: Optional[Tensor] = None, h_snr: Optional[Tensor] = None\n    ) -> Tuple[Tensor, Tensor, Tensor, Tensor]:\n        # input shape: [B, 1, T, F]\n        x0 = self.conv0(input)  # [B, C, T, F]\n        x1 = self.conv1(x0)  # [B, C, T, F\/2]\n        x_rnn, h = self.gru(x1, h)\n        x1 = self.convt1(x_rnn) + x0\n        lsnr, h_snr = self.gru_snr(x_rnn.transpose(1, 2).flatten(2, 3), h_snr)\n        lsnr = self.fc_snr(lsnr) * self.lsnr_scale + self.lsnr_offset\n        m = self.conv_out(x1)\n        return m, lsnr, h, h_snr\n","AFTER":"        self, input: Tensor, h_prev: Optional[Tensor] = None, h: Optional[Tensor] = None\n    ) -> Tuple[Tensor, Tensor, Tensor]:\n        # input shape: [B, 1, T, F]\n        x0 = self.conv_in(input)  # [B, C, T, F]\n        x1 = self.down_block(x0)  # [B, C, T, F\/2]\n        if h_prev is not None:\n            assert self.conv_hprev_down is not None\n            h_prev = self.conv_hprev_down(h_prev)\n            x1 = x1 + h_prev\n        x_rnn, h = self.gru(x1, h)\n        x_rnn = x_rnn + x1\n        x1 = self.up_block(x_rnn)\n        x1 = x1 + x0\n        m = self.conv_out(x1)\n        return m, x_rnn, h\n"}