{"BEFORE":"    def forward(self, x):\n        reverse = x.shape[1] > self.reverse_thres\n        blocks = self.blocks if reverse else self.irrev_blocks\n\n        if self.training and self.layer_dropout > 0:\n            to_drop = torch.empty(len(self.blocks)).uniform_(0, 1) < self.layer_dropout\n            blocks = [block for block, drop in zip(self.blocks, to_drop) if not drop]\n            blocks = self.blocks[:1] if len(blocks) == 0 else blocks\n\n        if not reverse:\n            return nn.Sequential(*blocks)(x)\n\n        return _ReversibleFunction.apply(x, blocks)\n","AFTER":"    def forward(self, x, arg_route = (True, True), **kwargs):\n        reverse = x.shape[1] > self.reverse_thres\n        blocks = self.blocks if reverse else self.irrev_blocks\n\n        if self.training and self.layer_dropout > 0:\n            to_drop = torch.empty(len(self.blocks)).uniform_(0, 1) < self.layer_dropout\n            blocks = [block for block, drop in zip(self.blocks, to_drop) if not drop]\n            blocks = self.blocks[:1] if len(blocks) == 0 else blocks\n\n        f_args, g_args = map(lambda route: kwargs if route else {}, arg_route)\n        block_kwargs = {'f_args': f_args, 'g_args': g_args}\n\n        if not reverse:\n            for block in blocks:\n                x = block(x, **block_kwargs)\n            return x\n\n        return _ReversibleFunction.apply(x, blocks, block_kwargs)\n"}