{"BEFORE":"                torch.cat([torch.tensor([idx]), roi_row])\n                for idx, roi in enumerate(bboxes)\n                for roi_row in roi\n","AFTER":"            assert targets is not None, \"Targets are required for training\"\n            losses = self.obj_detection_model(x, targets)\n            polygonrnn_loss, acc = self.polygonrnn_model.get_polygonrnn_losses_and_accuracy(  # type: ignore\n                x, targets\n            )\n            losses.update(polygonrnn_loss)\n            return losses, acc\n        detections = self.obj_detection_model(x)\n        empty_entries = self._get_empty_entries(detections)\n        if len(empty_entries) == len(detections):\n            for idx, _ in enumerate(detections):\n                detections[idx].update(\n                    {key: [] for key in [\"min_row\", \"min_col\", \"scale_h\", \"scale_w\"]}\n                )\n            return detections\n        bboxes = [\n            item[\"boxes\"]\n            for idx, item in enumerate(detections)\n            if idx not in empty_entries\n        ]\n        bboxes = torch.cat(\n            [\n                torch.column_stack([idx * torch.ones(bbox.shape[0]), bbox])\n                for idx, bbox in enumerate(bboxes)\n            ]\n        )  # num_rois, 5\n        polygonrnn_output = self.polygonrnn_model.test(\n            x, bboxes, self.val_seq_len\n        )  # type: ignore\n        min_bound = 0\n        for idx, det in enumerate(detections):\n            if idx in empty_entries:\n                detections[idx].update(\n                    {key: [] for key in [\"min_row\", \"min_col\", \"scale_h\", \"scale_w\"]}\n                )\n"}