{"BEFORE":"            graph.apply_edges(lambda edges: {'h': edges.data['_edge_weight'] * 2})\n            graph.update_all(aggregate_fn, fn.sum(msg='m', out='h'))\n            rst = graph.dstdata['h']\n            rst = th.matmul(feat_src, self.weight1) + th.matmul(rst, self.weight2)\n\n\n            if self.activation is not None:\n                rst = self.activation(rst)\n\n            return rst\n","AFTER":"            outputs = {}\n            aggregate_fn = fn.copy_src('h', 'm')\n            if edge_weight is not None:\n                #assert edge_weight.shape[0] == graph.number_of_edges()\n                hg.edata['_edge_weight'] = edge_weight\n                aggregate_fn = fn.u_sub_e('h', '_edge_weight', 'm')\n\n            feat_src, feat_dst = expand_as_pair(feat, hg)\n\n            # aggregate first then mult W\n            hg.srcdata['h'] = feat_src\n            for e in hg.canonical_etypes:\n                stype, etype, dtype = e\n                sub_graph = hg[stype, etype, dtype]\n                sub_graph.update_all(aggregate_fn, fn.sum(msg='m', out='out'))\n                temp = hg.ndata['out'].pop(dtype)\n                if isinstance(temp, dict):\n                    temp = temp[dtype]\n                if outputs.get(dtype) is None:\n                    outputs[dtype] = temp\n                else:\n                    outputs[dtype].add_(temp)\n\n            def _apply(ntype, h):\n\n                h = th.matmul(feat[ntype], self.weight1) + th.matmul(h, self.weight2)\n\n                if self.activation:\n                    h = self.activation(h)\n                return F.dropout(h, p=self.dropout, training=False)\n\n            return {ntype: _apply(ntype, h) for ntype, h in outputs.items()}\n"}