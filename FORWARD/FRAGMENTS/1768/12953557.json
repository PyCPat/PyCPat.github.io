{"BEFORE":"                key_padding_mask = torch.cat(\n                    [key_padding_mask, key_padding_mask.new_zeros(key_padding_mask.size(0), 1)], dim=1)\n\n        q = q.contiguous().view(tgt_len, bsz * self.num_heads, self.head_dim).transpose(0, 1)\n        if k is not None:\n            k = k.contiguous().view(-1, bsz * self.num_heads, self.head_dim).transpose(0, 1)\n        if v is not None:\n            v = v.contiguous().view(-1, bsz * self.num_heads, self.head_dim).transpose(0, 1)\n\n        if saved_state is not None:\n            # saved states are stored with shape (bsz, num_heads, seq_len, head_dim)\n            if 'prev_key' in saved_state:\n                prev_key = saved_state['prev_key'].view(bsz * self.num_heads, -1, self.head_dim)\n                if static_kv:\n                    k = prev_key\n                else:\n                    k = torch.cat((prev_key, k), dim=1)\n            if 'prev_value' in saved_state:\n                prev_value = saved_state['prev_value'].view(bsz * self.num_heads, -1, self.head_dim)\n                if static_kv:\n                    v = prev_value\n                else:\n                    v = torch.cat((prev_value, v), dim=1)\n            saved_state['prev_key'] = k.view(bsz, self.num_heads, -1, self.head_dim)\n            saved_state['prev_value'] = v.view(bsz, self.num_heads, -1, self.head_dim)\n\n            self._set_input_buffer(incremental_state, saved_state)\n\n        src_len = k.size(1)\n\n        if key_padding_mask is not None:\n            assert key_padding_mask.size(0) == bsz\n            assert key_padding_mask.size(1) == src_len\n\n        if self.add_zero_attn:\n            src_len += 1\n            k = torch.cat([k, k.new_zeros((k.size(0), 1) + k.size()[2:])], dim=1)\n            v = torch.cat([v, v.new_zeros((v.size(0), 1) + v.size()[2:])], dim=1)\n            if attn_mask is not None:\n                attn_mask = torch.cat([attn_mask, attn_mask.new_zeros(attn_mask.size(0), 1)], dim=1)\n            if key_padding_mask is not None:\n                key_padding_mask = torch.cat([key_padding_mask, key_padding_mask.new_zeros(key_padding_mask.size(0), 1)], dim=1)\n\n        attn_weights = torch.bmm(q, k.transpose(1, 2))\n        assert list(attn_weights.size()) == [bsz * self.num_heads, tgt_len, src_len]\n\n        if attn_mask is not None:\n            attn_weights += attn_mask.unsqueeze(0)\n        if key_padding_mask is not None:\n            # don't attend to padding symbols\n            attn_weights = attn_weights.view(bsz, self.num_heads, tgt_len, src_len)\n            attn_weights = attn_weights.float().masked_fill(\n                key_padding_mask.unsqueeze(1).unsqueeze(2),\n                float('-inf'),\n            ).type_as(attn_weights)  # FP16 support: cast to float and back\n","AFTER":"                key_padding_mask = torch.cat(\n                    [key_padding_mask, key_padding_mask.new_zeros(key_padding_mask.size(0), 1)], dim=1)\n\n        q = q.contiguous().view(tgt_len, bsz * self.num_heads, self.head_dim).transpose(0, 1)\n        if k is not None:\n            k = k.contiguous().view(-1, bsz * self.num_heads, self.head_dim).transpose(0, 1)\n        if v is not None:\n            v = v.contiguous().view(-1, bsz * self.num_heads, self.head_dim).transpose(0, 1)\n\n        if saved_state is not None:\n            # saved states are stored with shape (bsz, num_heads, seq_len, head_dim)\n            if 'prev_key' in saved_state:\n                prev_key = saved_state['prev_key'].view(bsz * self.num_heads, -1, self.head_dim)\n                if static_kv:\n                    k = prev_key\n                else:\n                    k = torch.cat((prev_key, k), dim=1)\n            if 'prev_value' in saved_state:\n                prev_value = saved_state['prev_value'].view(bsz * self.num_heads, -1, self.head_dim)\n                if static_kv:\n                    v = prev_value\n                else:\n                    v = torch.cat((prev_value, v), dim=1)\n            saved_state['prev_key'] = k.view(bsz, self.num_heads, -1, self.head_dim)\n            saved_state['prev_value'] = v.view(bsz, self.num_heads, -1, self.head_dim)\n\n            self._set_input_buffer(incremental_state, saved_state)\n\n        src_len = k.size(1)\n\n        if key_padding_mask is not None:\n            assert key_padding_mask.size(0) == bsz\n            assert key_padding_mask.size(1) == src_len\n\n        if self.add_zero_attn:\n            src_len += 1\n            k = torch.cat([k, k.new_zeros((k.size(0), 1) + k.size()[2:])], dim=1)\n            v = torch.cat([v, v.new_zeros((v.size(0), 1) + v.size()[2:])], dim=1)\n            if attn_mask is not None:\n                attn_mask = torch.cat([attn_mask, attn_mask.new_zeros(attn_mask.size(0), 1)], dim=1)\n            if key_padding_mask is not None:\n                key_padding_mask = torch.cat(\n                    [key_padding_mask, torch.zeros(key_padding_mask.size(0), 1).type_as(key_padding_mask)], dim=1)\n\n        attn_weights = torch.bmm(q, k.transpose(1, 2))\n        assert list(attn_weights.size()) == [bsz * self.num_heads, tgt_len, src_len]\n\n        if attn_mask is not None:\n            attn_mask = attn_mask.unsqueeze(0)\n            if self.onnx_trace:\n                attn_mask = attn_mask.repeat(attn_weights.size(0), 1, 1)\n            attn_weights += attn_mask\n\n        if key_padding_mask is not None:\n            # don't attend to padding symbols\n            attn_weights = attn_weights.view(bsz, self.num_heads, tgt_len, src_len)\n            if self.onnx_trace:\n                attn_weights = torch.where(\n                    key_padding_mask.unsqueeze(1).unsqueeze(2),\n                    torch.Tensor([float(\"-Inf\")]),\n                    attn_weights.float()\n                ).type_as(attn_weights)\n            else:\n                attn_weights = attn_weights.float().masked_fill(\n                    key_padding_mask.unsqueeze(1).unsqueeze(2),\n                    float('-inf'),\n                ).type_as(attn_weights)  # FP16 support: cast to float and back\n            attn_weights = attn_weights.view(bsz * self.num_heads, tgt_len, src_len)\n"}