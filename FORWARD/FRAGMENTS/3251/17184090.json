{"BEFORE":"        target = batch[\"targets\"].to(device)\n\n        assert predict.shape == target.shape, 'predict & target shape do not match'\n        dice = BinaryDiceLoss()\n        total_loss = 0\n        predict = F.softmax(predict, dim=1)\n\n        for i in range(target.shape[1]):\n            if i != self.ignore_index:\n                dice_loss, _ = dice(predict[:, i], {'targets': target[:, i]}, device)\n                if self.weight is not None:\n                    assert self.weight.shape[0] == target.shape[1], \\\n                        'Expect weight shape [{}], get[{}]'.format(target.shape[1], self.weight.shape[0])\n                    dice_loss *= self.weights[i]\n                total_loss += dice_loss\n\n        loss = total_loss\/target.shape[1]\n","AFTER":"        targets = batch[\"targets\"].to(device)\n        \n        inputs = F.softmax(predict, dim=1)       \n        \n        #flatten label and prediction tensors\n        inputs = inputs.view(-1)\n        targets = targets.view(-1)\n        \n        intersection = (inputs * targets).sum()                            \n        dice = (2.*intersection + self.eps)\/(inputs.sum() + targets.sum() + self.eps)  \n        \n        loss =  1 - dice\n"}