{"BEFORE":"        base_mask = torch.clip(p, min=0, max=1)\n\n        signal_shape = list(base_mask.shape)\n        signal_shape[-1] *= self.frame_period\n\n        mask = torch.ne(base_mask, 0).unsqueeze(-1)\n        size = [-1] * mask.dim()\n        size[-1] = self.frame_period\n        mask = mask.expand(size)\n        mask = mask.reshape(signal_shape)\n\n        # Extend right side for interpolation.\n        tmp_mask = torch.cat((base_mask[..., :1] * 0, base_mask), dim=-1)\n        tmp_mask = torch.eq(tmp_mask[..., 1:] - tmp_mask[..., :-1], -1)\n        p[tmp_mask] = torch.roll(p, 1, dims=-1)[tmp_mask]\n\n        # Interpolate pitch.\n        d = p.dim()\n        if d == 2 or d == 3:\n            p = p.transpose(-1, -2)\n        p = self.linear_intpl(p)\n        if d == 2 or d == 3:\n            p = p.transpose(-1, -2)\n        p *= mask\n\n        # Compute phase.\n        q = torch.nan_to_num(torch.reciprocal(p), posinf=0)\n        s = torch.cumsum(q.double(), dim=-1)\n        bias, _ = torch.cummax(s * ~mask, dim=-1)\n        phase = (s - bias).to(p.dtype)\n\n        if self.voiced_region == \"pulse\":\n            r = torch.ceil(phase)\n            r = torch.cat((r[..., :1] * 0, r), dim=-1)\n            pulse_pos = torch.ge(r[..., 1:] - r[..., :-1], 1)\n            e = torch.zeros(*signal_shape, device=p.device, requires_grad=False)\n","AFTER":"        base_mask = torch.clip(p, min=0, max=1)\n        mask = torch.ne(base_mask, 0)\n        mask = torch.repeat_interleave(mask, self.frame_period, dim=-1)\n\n        # Extend right side for interpolation.\n        tmp_mask = torch.cat((base_mask[..., :1] * 0, base_mask), dim=-1)\n        tmp_mask = torch.eq(tmp_mask[..., 1:] - tmp_mask[..., :-1], -1)\n        p[tmp_mask] = torch.roll(p, 1, dims=-1)[tmp_mask]\n\n        # Interpolate pitch.\n        d = p.dim()\n        if d == 2 or d == 3:\n            p = p.transpose(-1, -2)\n        p = self.linear_intpl(p)\n        if d == 2 or d == 3:\n            p = p.transpose(-1, -2)\n        p *= mask\n\n        # Compute phase.\n        q = torch.nan_to_num(torch.reciprocal(p), posinf=0)\n        s = torch.cumsum(q.double(), dim=-1)\n        bias, _ = torch.cummax(s * ~mask, dim=-1)\n        phase = (s - bias).to(p.dtype)\n\n        if self.voiced_region == \"pulse\":\n            r = torch.ceil(phase)\n            r = torch.cat((r[..., :1] * 0, r), dim=-1)\n            pulse_pos = torch.ge(r[..., 1:] - r[..., :-1], 1)\n            e = torch.zeros_like(p)\n"}