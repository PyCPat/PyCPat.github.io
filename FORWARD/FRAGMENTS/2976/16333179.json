{"BEFORE":"    loss_semantic = torch.tensor(0.0).to(self.device)\n\n    loss_triplet = self.triplet_loss(anchor_output, positive_output, negative_output)\n\n    # Create targets for the domain loss(INDIRECTLY adversarial for the main model - as imposed by the GRL after every output)\n    batch_size = anchor_output.shape[0]\n    targets_sketch = torch.zeros(batch_size).to(self.device)\n    targets_photos = torch.ones(batch_size).to(self.device)\n\n#     if epoch < 5:\n#       lmbda = 0\n#     elif epoch < 25:\n#       lmbda = (epoch-5)\/20.0\n#     else:\n#       lmbda = 1.0\n\n    lmbda = epoch\/25.0 if epoch <= 25 else 1.0\n\n\n    loss_domain = self.domain_loss(grad_reverse(anchor_output, lmbda), targets_sketch) + self.domain_loss(grad_reverse(positive_output, lmbda), targets_photos) + self.domain_loss(grad_reverse(negative_output, lmbda), targets_photos)\n    loss_domain \/= 3.0\n","AFTER":"    loss_semantic = self.semantic_loss(anchor_output, embedding)\n    loss_semantic += self.semantic_loss(positive_output, embedding)  \n    loss_semantic += self.semantic_loss(grad_reverse(negative_output, self.grl_lambda), embedding)\n    loss_semantic = loss_semantic.mean()\n\n    # loss_semantic = torch.tensor(0.0).to(self.device)\n\n    loss_triplet = self.triplet_loss(anchor_output, positive_output, negative_output)\n\n    # Create targets for the domain loss(INDIRECTLY adversarial for the main model - as imposed by the GRL after every output)\n    batch_size = anchor_output.shape[0]\n    targets_sketch = torch.zeros(batch_size).to(self.device)\n    targets_photos = torch.ones(batch_size).to(self.device)\n\n    if epoch < 5:\n      lmbda = 0\n    elif epoch < 25:\n      lmbda = (epoch-5)\/20.0\n    else:\n      lmbda = 1.0\n\n    # lmbda = epoch\/25.0 if epoch <= 25 else 1.0\n\n\n    loss_domain = self.domain_loss(grad_reverse(anchor_output, lmbda), targets_sketch) + self.domain_loss(grad_reverse(positive_output, lmbda), targets_photos) + self.domain_loss(grad_reverse(negative_output, lmbda), targets_photos)\n"}